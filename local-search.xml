<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>花店</title>
    <link href="/2020/03/09/%E8%8A%B1%E5%BA%97/"/>
    <url>/2020/03/09/%E8%8A%B1%E5%BA%97/</url>
    
    <content type="html"><![CDATA[<p>这个世界会变好的</p><a id="more"></a><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7823.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7824.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7826.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7835.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7837.png" srcset="/img/loading.gif" alt=""></p><p>这是我第一次去花店，第二次送花给妈妈。</p><p>在我很小的时候，我曾经从油菜地里摘过一朵油菜花送给妈妈。每每说起这件事，她总是笑得很开心，我也会在她笑得时候回忆起我曾经对她的依赖。</p><p>那时候我在读小学，她还年轻，头上没有那么多白发。开学前的一天她会把学费整齐塞进信封，然后放入我书包的夹层里，嘱咐我不要弄丢。第二天一早我来到学校，拿出信封里的钱，用铅笔在六张一百元上写上自己的名字，再塞回信封，在干净的信封正面又写上一遍名字，才上交给老师。那时候我只觉得这些钱很值钱，这么多钱也只有那一天可见，直到多年以后看见妈妈腿上食指般粗的血管，我才真的明白那每年都要交的六百块钱究竟意味着什么。那时候家里很穷，她在服装厂上班，每天要站十几个小时。</p><p>小时候过年的新衣服都是妈妈买给我的。临近过年了，我总是很期待坐妈妈的电瓶车去镇上买衣服。那经常会花上一整天时间，因为那些衣服都得是我喜欢并且能杀下去价的。新衣服买回来并不会直接穿，我总会很有耐心的等到大年初一清早才心满意足地穿上，当然，在这之前我已经无数次地拆开包装，如考古学家对待文物一般。</p><p>小学毕业，我的成绩不错，想去城里上学。那是一个民办初中，简单的面试很顺利，摇号也选上了，可是学费按学期交且高得离谱，妈妈已无法负担。正巧那时候城市规划的红圈圈入了我家这栋老宅，有了这笔钱我才顺利入学。也许是学校离家太远，也许是成长的必然，我和妈妈似乎渐渐疏远了。</p><p>有段时间我开始频繁的眨眼，妈妈看见了就会让我不要眨眼睛，可是我并不能控制。她不通情理的要求让我很恼怒，有个晚上她再次要求后我失控的对她吼道，为什么我眨眼睛你也要管。她愣了半响，然后开始打我。那是她唯一一次打我，至今我还记得那有多痛，但是我不敢哭，我知道我伤了她的心。</p><p>第二天她带我去浙二医院看眼睛，我近视了。得知我以后都要戴眼镜，她很伤心，也很后悔。检查时还发现我的左眼天生弱视，医生说我已经过了年纪，治不好了。她还是执意买了一台昂贵的治疗仪，回家路上反复的叮嘱我要按时治疗。</p><p>后来我去外地读大学，妈妈总说要来学校看我，但因为种种原因直到毕业了也没有来。现在她也偶尔说起，说那是儿子第一次去外地生活，很可惜没有去看我。</p><p>大学毕业后的一个月，我父母离婚了。</p><p>那天晚上我和父母三人坐在客厅沙发上，做最后的决定。我同意离婚，因为我知道妈妈那么多年来都是为了我能有一个完整的家才坚持下来的，她不幸福。三人说好明天一早去办手续，妈妈突然哭着对我说，对不起儿子，妈妈不想离婚的，对不起……</p><p>是我对不起妈妈，其实我成长的很好啊，我没有被你们婚姻影响啊，为什么你要牺牲自己的幸福呢。</p><p>这个世界就是那么荒谬，妈妈没有得到多少幸福，却给予了我一生追忆的幸福。她总是告诫我做人要诚实、善良、懂得感恩，可是世上那么多人，有几人这样对待她呢。</p><p>我逐渐意识到，爱也是一种责任，她爱我越深，我所背负的也越重。我必须照顾好爱我的人，那是对抗荒谬世界的唯一办法。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯(Backtracking)</title>
    <link href="/2020/03/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>“想回到过去，试着让故事继续”</p><a id="more"></a><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p><strong>回溯</strong>（backtracking）是<strong>暴力搜索法</strong>中的一种。</p><p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。</p><blockquote><p>约束满足问题：在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解。</p></blockquote><p>回溯法采用<strong>试错</strong>的思想，它尝试<strong>分步</strong>的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将<strong>撤销</strong>上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案，找到答案即算法运行至<strong>终止条件</strong>。</p><p>回溯法通常用最简单的<strong>递归</strong>方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p>在最坏的情况下，回溯法会导致一次<strong>复杂度</strong>为<strong>指数时间</strong>的计算。</p><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">leetcode 46. 全排列</a>：给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p>用比较通用的回溯算法可以这样解答：</p><pre><code class="lang-python">class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        size = len(nums)        res = []        # 记录已经选择过的数        visited = set()        def backtrack(numList, visited):                       # 当所有数字都选完了，终止            if len(visited) == size:                res.append(numList[:])                return            # 遍历所有可能的选择            for i in range(size):                # 如果这个数已在前面出现过了，跳过                if i in visited: continue                                 visited.add(i)                numList.append(nums[i])                 # 递归                backtrack(numList,visited)                          # 撤销对临时数组和visited的操作                numList.pop()                visited.remove(i)        backtrack([], visited)        return res</code></pre><p>全排列问题能很好的体现回溯的特点：</p><ul><li><strong>试错：</strong>判断当前数是否在前面出现过</li><li><strong>分步：</strong>遍历所有数</li><li><strong>撤销：</strong>推出递归后需要撤销之前的改动以安全地进入下一个循环</li><li><strong>终止条件：</strong>所有数都已遍历，或者临时数组长度等于原数组</li></ul><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>在经典的教科书中，<strong><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">八皇后问题</a></strong>展示了回溯法的用例。</p><p><strong>八皇后问题</strong>是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。</p><p><img src="2020-03-08 142051.png" srcset="/img/loading.gif" alt=""></p><p>上图就是其中的一个解，八个皇后在8x8棋盘上共有4,426,165,368（<script type="math/tex">\binom{64}{8}</script>）种摆放方法，但只有92个<strong>互不相同</strong>的解。如果将旋转和对称的解归为一种的话，则一共有12个独立解。<a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">wiki有完整解</a></p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">leetcode 51. N皇后</a>是八皇后问题的推广：如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code class="lang-txt">输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98</a></li><li><a href="https://zh.wikipedia.org/wiki/回溯法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>回溯</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo暗色背景下valine的优化</title>
    <link href="/2020/03/07/Hexo%E6%9A%97%E8%89%B2%E8%83%8C%E6%99%AF%E4%B8%8Bvaline%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/07/Hexo%E6%9A%97%E8%89%B2%E8%83%8C%E6%99%AF%E4%B8%8Bvaline%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>暗色背景下，通过修改CSS改变valine留言的外观，字体颜色，边框等</p><a id="more"></a><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>在布置完<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid主题</a>后我发现暗色背景下的valine字体还是黑色的，很难辨识，再请教原作者后了解到可以使用自定义CSS的方式修改网页的布局。在Chrome浏览器中打开自己的网页，右键点击想修改的元素，选择检查就可以看到CSS了。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/Inked2020-03-07%20195959_LI.jpg" srcset="/img/loading.gif" alt=""></p><p>上图中的配置项可以修改背景，边框，字体等，其中有一些划去的项表示有冲突且优先级不高的设置，所以没有执行。我们修改CSS的原理类似，添加新的设置并且设置更高的优先级来改变原本的样式。</p><h1 id="自定义CSS"><a href="#自定义CSS" class="headerlink" title="自定义CSS"></a>自定义CSS</h1><p>以fluid主题为例（其他很多主题也有类似自定义CSS的功能），具体步骤如下：</p><ol><li><p>在<code>\hexo\themes\fluid\source\css</code>下创建<code>custom.css</code>文件，并在主题的配置文件<code>_config.yml</code>中添加如下路径。</p><pre><code class="lang-yaml"># 指定自定义 css 文件路径，路径是相对 source 目录custom_css: /css/custom.css</code></pre></li><li><p>在浏览器中找到需要修改的部分代码，修改后添加到<code>custom.css</code>，并在语句后面添加<code>!important</code>提高优先级以确保覆盖原有设置。例如修改valine输入的字体的颜色和高度就可以这样设置：</p><pre><code class="lang-css">.v * {    line-height: 1 !important;    color: #eee !important;}</code></pre></li><li><p>保存文件，<code>hexo clean</code> and <code>hexo d -g</code>。</p></li></ol><h1 id="本博客的例子"><a href="#本博客的例子" class="headerlink" title="本博客的例子"></a>本博客的例子</h1><p>由于我对CSS不熟悉，自己的valine只做了一些简单的修改：</p><pre><code class="lang-css">/*valine 评论系统样式*/.v * {    line-height: 1 !important;    color: #eee !important;}.v .vwrap .vheader .vinput {    border-bottom: 1px solid #000000 !important;}.v .vbtn {    border: 1px solid #333333 !important;    background: #000000 !important;}.v .vlist .vcard .vhead .vsys {    background: #000000 !important;}.v .vwrap{  border: 2px solid black !important;}.v .vlist .vcard .vquote {    border-left: 1px solid #000000 !important;}.v .vlist .vcard .vh {    border-bottom: 1px solid #333 !important;}/*设置评论头像旋转*/.v .vlist .vcard .vimg:hover {    -webkit-transform: rotate(360deg);    -moz-transform: rotate(360deg);    -ms-transform: rotate(360deg);    -transform: rotate(360deg);}/**/</code></pre><p>玩的开心！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy数据分析</title>
    <link href="/2020/02/29/NumPy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2020/02/29/NumPy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>NumPy数据分析与机器学习</p><a id="more"></a><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><h2 id="导入数字和文本的数据集"><a href="#导入数字和文本的数据集" class="headerlink" title="导入数字和文本的数据集"></a>导入数字和文本的数据集</h2><p>导入鸢尾属植物数据集，保持文本不变。</p><pre><code class="lang-python"># Solutionurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)# Print the first 3 rowsiris[:3]# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;]], dtype=object)</code></pre><p><strong>补充：</strong>在python3.x中字符串编码是<code>unicode</code>。对数据中<code>bytes</code>类型的字符串会用前缀<code>b</code>。</p><p>提取特定列：</p><pre><code class="lang-python"># **给定：**url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)print(iris_1d.shape)# Solution:species = np.array([row[4] for row in iris_1d])species[:5]# &gt; (150,)# &gt; array([b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;,# &gt;        b&#39;Iris-setosa&#39;],# &gt;       dtype=&#39;|S18&#39;)</code></pre><h2 id="将1维元组数组转换为2维numpy数组"><a href="#将1维元组数组转换为2维numpy数组" class="headerlink" title="将1维元组数组转换为2维numpy数组"></a>将1维元组数组转换为2维numpy数组</h2><p>通过省略鸢尾属植物数据集种类的文本字段，将一维鸢尾属植物数据集转换为二维数组iris_2d。</p><pre><code class="lang-python"># **给定：**url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)# Solution:# Method 1: Convert each row to a list and get the first 4 itemsiris_2d = np.array([row.tolist()[:4] for row in iris_1d])iris_2d[:4]# Alt Method 2: Import only the first 4 columns from source urliris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[:4]# &gt; array([[ 5.1,  3.5,  1.4,  0.2],# &gt;        [ 4.9,  3. ,  1.4,  0.2],# &gt;        [ 4.7,  3.2,  1.3,  0.2],# &gt;        [ 4.6,  3.1,  1.5,  0.2]])</code></pre><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="均值、中位数及标准差"><a href="#均值、中位数及标准差" class="headerlink" title="均值、中位数及标准差"></a>均值、中位数及标准差</h2><pre><code class="lang-python">mu, med, sd = np.mean(sepallength), np.median(sepallength), np.std(sepallength)</code></pre><h2 id="垂直叠加两个数组"><a href="#垂直叠加两个数组" class="headerlink" title="垂直叠加两个数组"></a>垂直叠加两个数组</h2><p><strong>给定：</strong></p><pre><code class="lang-python">a = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python"># &gt; array([[0, 1, 2, 3, 4],# &gt;        [5, 6, 7, 8, 9],# &gt;        [1, 1, 1, 1, 1],# &gt;        [1, 1, 1, 1, 1]])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">a = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)# Answers# Method 1:np.concatenate([a, b], axis=0)# Method 2 (v may means vertical):np.vstack([a, b])# Method 3 (r may means row):np.r_[a, b]# &gt; array([[0, 1, 2, 3, 4],# &gt;        [5, 6, 7, 8, 9],# &gt;        [1, 1, 1, 1, 1],# &gt;        [1, 1, 1, 1, 1]])</code></pre><p>类似的我们可以用以下方法水平叠加两个数组：</p><pre><code class="lang-python"># 使用第二轴concatenatenp.concatenate([a, b], axis=1)# horizontal stacknp.hstack([a, b])# col:np.c_[a, b]# &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],# &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</code></pre><h2 id="复制叠加数组"><a href="#复制叠加数组" class="headerlink" title="复制叠加数组"></a>复制叠加数组</h2><pre><code class="lang-python">np.repeat(a, 3)# &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3])np.tile(a, 3)# &gt; array([1, 2, 3, 1, 2, 3, 1, 2, 3])</code></pre><h2 id="获取两个数组的公共项"><a href="#获取两个数组的公共项" class="headerlink" title="获取两个数组的公共项"></a>获取两个数组的公共项</h2><p><strong>给定：</strong></p><pre><code class="lang-python">a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python">array([2, 4])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])np.intersect1d(a,b)# &gt; array([2, 4])</code></pre><p><strong>补充：</strong></p><ol><li>并集, <code>np.union1d(s ,t)</code>，返回排序的、去重的两个list的合集</li><li>交集, <code>np.intersect1d(s, t, assume_unique=True)</code>返回排序的、去重的两个list的交集，<code>assume_unique</code>保证传入的两个list是去重的，这可以加快运算速度。</li><li>差集, <code>np.setdiff1d(s, t, assume_unique=True)</code>, 返回排序的，去重的差集，assume_unique参数同上。</li></ol><h2 id="使用自定义函数处理数据"><a href="#使用自定义函数处理数据" class="headerlink" title="使用自定义函数处理数据"></a>使用自定义函数处理数据</h2><p><strong>给定：</strong></p><pre><code class="lang-python">def maxx(x, y):    &quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;    if x &gt;= y:        return x    else:        return ymaxx(1, 5)# &gt; 5</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python">a = np.array([5, 7, 9, 8, 6, 4, 5])b = np.array([6, 3, 4, 8, 9, 7, 1])pair_max(a, b)# &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">def maxx(x, y):    &quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;    if x &gt;= y:        return x    else:        return ypair_max = np.vectorize(maxx, otypes=[float])a = np.array([5, 7, 9, 8, 6, 4, 5])b = np.array([6, 3, 4, 8, 9, 7, 1])pair_max(a, b)# &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</code></pre><h2 id="交换二维数组中的两列"><a href="#交换二维数组中的两列" class="headerlink" title="交换二维数组中的两列"></a>交换二维数组中的两列</h2><p><strong>给定：</strong></p><pre><code class="lang-python">arr = np.arange(9).reshape(3,3)arr</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python"># Inputarr = np.arange(9).reshape(3,3)arr# Solutionarr[:, [1,0,2]]# &gt; array([[1, 0, 2],# &gt;        [4, 3, 5],# &gt;        [7, 6, 8]])</code></pre><p>本质上就是花式索引（Fancy indexing）类似的，交换两行的方法如下：</p><pre><code class="lang-python"># Solutionarr[[1,0,2], :]# &gt; array([[3, 4, 5],# &gt;        [0, 1, 2],# &gt;        [6, 7, 8]])</code></pre><h2 id="创建随机的二维数组"><a href="#创建随机的二维数组" class="headerlink" title="创建随机的二维数组"></a>创建随机的二维数组</h2><pre><code class="lang-python"># Solution Method 1:rand_arr = np.random.randint(low=5, high=10, size=(5,3)) + np.random.random((5,3))# Solution Method 2:rand_arr = np.random.uniform(5,10, size=(5,3))# &gt; [[ 8.50061025  9.10531502  6.85867783]# &gt;  [ 9.76262069  9.87717411  7.13466701]# &gt;  [ 7.48966403  8.33409158  6.16808631]# &gt;  [ 7.75010551  9.94535696  5.27373226]# &gt;  [ 8.0850361   5.56165518  7.31244004]]</code></pre><p>方法一是生成<code>[5,9]</code>的随机整数加上<code>[0,1]</code>的浮点数。</p><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><pre><code class="lang-python"># Inputa = np.array([1,2,3,4,5])b = np.array([4,5,6,7,8])# Solutiondist = np.linalg.norm(a-b)dist# &gt; 6.7082039324993694</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="只打印小数点后三位"><a href="#只打印小数点后三位" class="headerlink" title="只打印小数点后三位"></a>只打印小数点后三位</h3><pre><code class="lang-python">np.set_printoptions(precision=3)</code></pre><p>设置一次只有都会保持该状态。使用该函数时，下同。</p><h3 id="e式科学记数法"><a href="#e式科学记数法" class="headerlink" title="e式科学记数法"></a>e式科学记数法</h3><pre><code class="lang-python">np.set_printoptions(suppress=False)</code></pre><h3 id="限制数组输出中打印的项目数"><a href="#限制数组输出中打印的项目数" class="headerlink" title="限制数组输出中打印的项目数"></a>限制数组输出中打印的项目数</h3><pre><code class="lang-python">np.set_printoptions(threshold=6)</code></pre><p>如果需要输出全部，使用</p><pre><code class="lang-python">np.set_printoptions(threshold=np.nan)</code></pre><h1 id="机器学习相关"><a href="#机器学习相关" class="headerlink" title="机器学习相关"></a>机器学习相关</h1><h2 id="Min-Max-Normalization"><a href="#Min-Max-Normalization" class="headerlink" title="Min-Max Normalization"></a>Min-Max Normalization</h2><pre><code class="lang-python">arr = np.array([1, 2, 3, 4, 5])arr_max, arr_min = arr.max(), arr.min()# Solution Method 1:(arr - arr_min) / (arr_max - arr_min)# Solution Method 2:(arr - arr_min) / arr.ptp()# &gt; [0.   0.25 0.5  0.75 1.  ]</code></pre><h2 id="计算Softmax得分"><a href="#计算Softmax得分" class="headerlink" title="计算Softmax得分"></a>计算Softmax得分</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)sepallength = np.array([float(row[0]) for row in iris])# Solutiondef softmax(x):    &quot;&quot;&quot;Compute softmax values for each sets of scores in x.    https://stackoverflow.com/questions/34968722/how-to-implement-the-softmax-function-in-python&quot;&quot;&quot;    e_x = np.exp(x - np.max(x))    return e_x / e_x.sum(axis=0)print(softmax(sepallength))# &gt; [ 0.002  0.002  0.001  0.001  0.002  0.003  0.001  0.002  0.001  0.002# &gt;   0.003  0.002  0.002  0.001  0.004  0.004  0.003  0.002  0.004  0.002# &gt;   0.003  0.002  0.001  0.002  0.002  0.002  0.002  0.002  0.002  0.001# &gt;   0.002  0.003  0.002  0.003  0.002  0.002  0.003  0.002  0.001  0.002# &gt;   0.002  0.001  0.001  0.002  0.002  0.002  0.002  0.001  0.003  0.002# &gt;   0.015  0.008  0.013  0.003  0.009  0.004  0.007  0.002  0.01   0.002# &gt;   0.002  0.005  0.005  0.006  0.004  0.011  0.004  0.004  0.007  0.004# &gt;   0.005  0.006  0.007  0.006  0.008  0.01   0.012  0.011  0.005  0.004# &gt;   0.003  0.003  0.004  0.005  0.003  0.005  0.011  0.007  0.004  0.003# &gt;   0.003  0.006  0.004  0.002  0.004  0.004  0.004  0.007  0.002  0.004# &gt;   0.007  0.004  0.016  0.007  0.009  0.027  0.002  0.02   0.011  0.018# &gt;   0.009  0.008  0.012  0.004  0.004  0.008  0.009  0.03   0.03   0.005# &gt;   0.013  0.004  0.03   0.007  0.011  0.018  0.007  0.006  0.008  0.018# &gt;   0.022  0.037  0.008  0.007  0.006  0.03   0.007  0.008  0.005  0.013# &gt;   0.011  0.013  0.004  0.012  0.011  0.011  0.007  0.009  0.007  0.005]</code></pre><p>Softmax可以见<a href="http://cs231n.github.io/linear-classify/#softmax" target="_blank" rel="noopener">这篇</a>。</p><h2 id="数组的百分位数"><a href="#数组的百分位数" class="headerlink" title="数组的百分位数"></a>数组的百分位数</h2><p>找到鸢尾属植物数据集的第5和第95百分位数</p><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;sepallength = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0])# Solutionnp.percentile(sepallength, q=[5, 95])# &gt; array([ 4.6  ,  7.255])</code></pre><h2 id="找到数组中缺失值的位置"><a href="#找到数组中缺失值的位置" class="headerlink" title="找到数组中缺失值的位置"></a>找到数组中缺失值的位置</h2><p>在iris_2d的sepallength中查找缺失值的数量和位置（第1列）</p><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan# Solutionprint(&quot;Number of missing values: \n&quot;, np.isnan(iris_2d[:, 0]).sum())print(&quot;Position of missing values: \n&quot;, np.where(np.isnan(iris_2d[:, 0])))# &gt; Number of missing values: # &gt;  5# &gt; Position of missing values: # &gt;  (array([ 39,  88,  99, 130, 147]),)</code></pre><p><code>np.isnan()</code>会返回一个布尔型的数组。</p><h2 id="从数组中删除包含缺失值的行"><a href="#从数组中删除包含缺失值的行" class="headerlink" title="从数组中删除包含缺失值的行"></a>从数组中删除包含缺失值的行</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan # 手动插入一些nan# Solution# No direct numpy function for this.# Method 1:any_nan_in_row = np.array([~np.any(np.isnan(row)) for row in iris_2d]) # ~表示按位取反iris_2d[any_nan_in_row][:5]# Method 2: (By Rong)iris_2d[np.sum(np.isnan(iris_2d), axis = 1) == 0][:5]# &gt; array([[ 4.9,  3. ,  1.4,  0.2],# &gt;        [ 4.7,  3.2,  1.3,  0.2],# &gt;        [ 4.6,  3.1,  1.5,  0.2],# &gt;        [ 5. ,  3.6,  1.4,  0.2],# &gt;        [ 5.4,  3.9,  1.7,  0.4]])</code></pre><p><code>numpy.any</code>(<em>a</em>, <em>axis=None**</em>,<strong> <em>out=None</em></strong>,<em>* </em>keepdims=<no value>*)有真值时返回1，没有时返回0。<br>注意<code>np.nan == np.nan</code>返回的是<code>False</code>，需要使用<code>np.isnan()</code>。</p><h2 id="数组两列之间的相关性"><a href="#数组两列之间的相关性" class="headerlink" title="数组两列之间的相关性"></a>数组两列之间的相关性</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])# Solution 1np.corrcoef(iris[:, 0], iris[:, 2])[0, 1]# Solution 2from scipy.stats.stats import pearsonr  corr, p_value = pearsonr(iris[:, 0], iris[:, 2])print(corr)# Correlation coef indicates the degree of linear relationship between two numeric variables.# It can range between -1 to +1.# The p-value roughly indicates the probability of an uncorrelated system producing # datasets that have a correlation at least as extreme as the one computed.# The lower the p-value (&lt;0.01), stronger is the significance of the relationship.# It is not an indicator of the strength.# &gt; 0.871754157305</code></pre><p>协方差和相关系数请见<a href="https://blog.csdn.net/iloveyousunna/article/details/77948219" target="_blank" rel="noopener">这篇</a>。</p><h2 id="数组的现有列中创建新列"><a href="#数组的现有列中创建新列" class="headerlink" title="数组的现有列中创建新列"></a>数组的现有列中创建新列</h2><p>在iris_2d中为卷创建一个新列，其中volume是<code>（pi x petallength x sepal_length ^ 2）/ 3</code></p><pre><code class="lang-python"># Compute volumesepallength = iris_2d[:, 0].astype(&#39;float&#39;)petallength = iris_2d[:, 2].astype(&#39;float&#39;)volume = (np.pi * petallength * (sepallength**2))/3# Introduce new dimension to match iris_2d&#39;svolume = volume[:, np.newaxis]# Add the new columnout = np.hstack([iris_2d, volume])# Viewout[:4]# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 38.13265162927291],# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 35.200498485922445],# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 30.0723720777127],# &gt;        [b&#39;4.6&#39;, b&#39;3.1&#39;, b&#39;1.5&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 33.238050274980004]], dtype=object)</code></pre><h2 id="概率抽样"><a href="#概率抽样" class="headerlink" title="概率抽样"></a>概率抽样</h2><p>随机抽鸢尾属植物的种类，使得刚毛的数量是云芝和维吉尼亚的两倍</p><pre><code class="lang-python"># Get the species columnspecies = iris[:, 4]# Approach 1: Generate Probablisticallynp.random.seed(100)a = np.array([&#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;])species_out = np.random.choice(a, 150, p=[0.5, 0.25, 0.25])# Approach 2: Probablistic Sampling (preferred)np.random.seed(100)probs = np.r_[np.linspace(0, 0.500, num=50), np.linspace(0.501, .750, num=50), np.linspace(.751, 1.0, num=50)]index = np.searchsorted(probs, np.random.random(150))species_out = species[index]print(np.unique(species_out, return_counts=True))# &gt; (array([b&#39;Iris-setosa&#39;, b&#39;Iris-versicolor&#39;, b&#39;Iris-virginica&#39;], dtype=object), array([77, 37, 36]))</code></pre><p>方法2是首选方法，因为它创建了一个索引变量，该变量可用于取样2维表格数据。</p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>根据sepallength列对数据集进行排序。</p><pre><code class="lang-python"># Sort by column position 0: SepalLengthprint(iris[iris[:,0].argsort()][:5])</code></pre><p>利用<code>unique()</code>获取第K大的值：</p><pre><code class="lang-python"># Get the species and petal length columnspetal_len_setosa = iris[iris[:, 4] == b&#39;Iris-setosa&#39;, [2]].astype(&#39;float&#39;)# Get the second last valuenp.unique(np.sort(petal_len_setosa))[-2]</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/advanced/numpy_exercises_for_data_analysis.html#numpy数据分析问答" target="_blank" rel="noopener">https://www.numpy.org.cn/article/advanced/numpy_exercises_for_data_analysis.html#numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%97%AE%E7%AD%94</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>NumPy</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy基础</title>
    <link href="/2020/02/27/NumPy/"/>
    <url>/2020/02/27/NumPy/</url>
    
    <content type="html"><![CDATA[<p>python常用库——NumPy</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词—— <code>Numerical</code>和<code>Python</code>。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><h1 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h1><p>NumPy围绕<code>ndarrays</code>展开的。它可以完成如下操作：</p><pre><code class="lang-python">a = np.array([1, 2, 3])   # Create a rank 1 arrayprint(type(a))            # Prints &quot;&lt;class &#39;numpy.ndarray&#39;&gt;&quot;print(a.shape)            # Prints &quot;(3,)&quot;print(a[0], a[1], a[2])   # Prints &quot;1 2 3&quot;a[0] = 5                  # Change an element of the arrayprint(a)                  # Prints &quot;[5, 2, 3]&quot;b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 arrayprint(b.shape)                     # Prints &quot;(2, 3)&quot;print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</code></pre><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>可以通过<code>ndarray</code>类的属性获取数组属性：</p><pre><code class="lang-python"># Array propertiesa = np.array([[11, 12, 13, 14, 15],              [16, 17, 18, 19, 20],              [21, 22, 23, 24, 25],              [26, 27, 28 ,29, 30],              [31, 32, 33, 34, 35]])print(type(a)) # &gt;&gt;&gt;&lt;class &#39;numpy.ndarray&#39;&gt;# 数据类型print(a.dtype) # &gt;&gt;&gt;int64# 总数据量print(a.size) # &gt;&gt;&gt;25# 数组形状print(a.shape) # &gt;&gt;&gt;(5, 5)# 每项占用的字节数，这里int64占用8字节print(a.itemsize) # &gt;&gt;&gt;8# 数组维度print(a.ndim) # &gt;&gt;&gt;2# 所有数据消耗的字节数，小于等于数组占据的总字节数print(a.nbytes) # &gt;&gt;&gt;200</code></pre><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p><code>ndarray</code>支持一下运算操作，</p><pre><code class="lang-python">import numpy as np# Basic Operatorsa = np.arange(25)a = a.reshape((5, 5))print(a)b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45,              4, 92, 5, 55, 63, 43, 35, 6, 53, 24,              56, 3, 56, 44, 78])b = b.reshape((5,5))print(a + b)print(a - b)print(a * b)print(a / b)print(a ** 2)print(a &lt; b)print(a &gt; b)print(a.dot(b))</code></pre><p>除了<code>dot()</code>之外，这些操作符都是对数组进行逐元素运算。比如<code>(a, b, c) + (d, e, f)</code>的结果就是<code>(a+d, b+e, c+f)</code>。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。注意，当使用逻辑运算符比如 “&lt;” 和 “&gt;” 的时候，返回的将是一个布尔型数组。<code>dot()</code> 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。</p><p>NumPy还提供了一些别的用于处理数组的好用的运算符。</p><pre><code class="lang-python"># dot, sum, min, max, cumsuma = np.arange(10)print(a.sum()) # &gt;&gt;&gt;45print(a.min()) # &gt;&gt;&gt;0print(a.max()) # &gt;&gt;&gt;9print(a.cumsum()) # &gt;&gt;&gt;[ 0  1  3  6 10 15 21 28 36 45]</code></pre><p><code>sum()</code>、<code>min()</code>和<code>max()</code>函数的作用非常明显。将所有元素相加，找出最小和最大元素。<code>cumsum()</code>函数保存从第二个数开始每个数和之前所有数之和。</p><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p><img src="numpy_2D_slicing_diagram-1.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引是获取数组中多个特定元素的有效方法：</p><pre><code class="lang-python"># Fancy indexinga = np.arange(0, 100)a = a.reshape(10, 10)indices = [1, 5, -1]b = a[1, indices]print(b) # &gt;&gt;&gt;[11 15 19]</code></pre><h3 id="布尔屏蔽"><a href="#布尔屏蔽" class="headerlink" title="布尔屏蔽"></a>布尔屏蔽</h3><p>布尔屏蔽是根据指定的条件检索数组中的元素：</p><pre><code class="lang-python"># Boolean maskingimport numpy as npimport matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)mask = b &gt;= 0plt.plot(a[mask], b[mask], &#39;bo&#39;)mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], &#39;go&#39;)plt.show()</code></pre><p>之所以叫布尔屏蔽，应该是这里的<code>mask</code>是由布尔值组成的。结果如下图：</p><p><img src="Figure_1.png" srcset="/img/loading.gif" alt=""></p><h3 id="缺省索引"><a href="#缺省索引" class="headerlink" title="缺省索引"></a>缺省索引</h3><p>不完全索引是从多维数组的第一个维度获取索引或切片的一种方便方法。</p><pre><code class="lang-python"># Incomplete Indexinga = np.arange(0, 100, 10)b = a[:5]c = a[a &lt; 50]print(b) # &gt;&gt;&gt;[ 0 10 20 30 40]print(c) # &gt;&gt;&gt;[ 0 10 20 30 40]</code></pre><h3 id="Where-函数"><a href="#Where-函数" class="headerlink" title="Where 函数"></a>Where 函数</h3><p><code>where()</code>函数分为两种情况，三个参数和单个参数。</p><ol><li>三个参数<code>where(cond, x, y)</code>：满足条件cond输出x，不满足输出y。</li><li>一个参数<code>where(array)</code>：输出<code>array</code>中真值（非零值）的坐标。</li></ol><pre><code class="lang-python"># Wherea = np.arange(0, 100, 10)a=a.reshape(2, 5)print(a)&#39;&#39;&#39;&gt;&gt;&gt;[[ 0 10 20 30 40] [50 60 70 80 90]]&#39;&#39;&#39;print(a % 20 == 0)&#39;&#39;&#39;&gt;&gt;&gt;[[ True False  True False  True] [False  True False  True False]]&#39;&#39;&#39;b = np.where(a % 20 == 0) c = np.where(a % 20 == 0)[0]print(b) # &gt;&gt;&gt;(array([0, 0, 0, 1, 1], dtype=int64), array([0, 2, 4, 1, 3], dtype=int64))print(c) # &gt;&gt;&gt;[0 0 0 1 1]</code></pre><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>当维度不同的两个数组做运算时，自动将维度小的扩展成和另一个数组相同形状的处理就是广播。以下内容详情见参考[2]。</p><p>将两个数组一起广播遵循以下规则：</p><ol><li>如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。</li><li>如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。</li><li>如果数组在所有维度上兼容，则可以一起广播。</li><li>广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li><li>在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样</li></ol><pre><code class="lang-python">import numpy as np# Compute outer product of vectorsv = np.array([1,2,3])  # v has shape (3,)w = np.array([4,5])    # w has shape (2,)# To compute an outer product, we first reshape v to be a column# vector of shape (3, 1); we can then broadcast it against w to yield# an output of shape (3, 2), which is the outer product of v and w:# [[ 4  5]#  [ 8 10]#  [12 15]]print(np.reshape(v, (3, 1)) * w)# Add a vector to each row of a matrixx = np.array([[1,2,3], [4,5,6]])# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),# giving the following matrix:# [[2 4 6]#  [5 7 9]]print(x + v)# Add a vector to each column of a matrix# x has shape (2, 3) and w has shape (2,).# If we transpose x then it has shape (3, 2) and can be broadcast# against w to yield a result of shape (3, 2); transposing this result# yields the final result of shape (2, 3) which is the matrix x with# the vector w added to each column. Gives the following matrix:# [[ 5  6  7]#  [ 9 10 11]]print((x.T + w).T)# Another solution is to reshape w to be a column vector of shape (2, 1);# we can then broadcast it directly against x to produce the same# output.print(x + np.reshape(w, (2, 1)))# Multiply a matrix by a constant:# x has shape (2, 3). Numpy treats scalars as arrays of shape ();# these can be broadcast together to shape (2, 3), producing the# following array:# [[ 2  4  6]#  [ 8 10 12]]print(x * 2)</code></pre><p>注意：对一个<code>array</code>转置可以使用<code>array.T</code>，或者使用<code>np.reshape()</code>。对于矩阵可使用<code>np.transpose()</code>。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="arange-和linspace"><a href="#arange-和linspace" class="headerlink" title="arange()和linspace()"></a>arange()和linspace()</h2><p><code>arange()</code>类似于内置函数<code>range()</code>，通过指定开始值、终值和步长创建表示等差数列的一维数组，<strong>得到的结果数组不包含终值</strong>。</p><p><code>linspace()</code>通过指定开始值、终值和元素个数创建表示等差数列的一维数组。</p><pre><code class="lang-python">numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)</code></pre><ul><li>在<code>start</code>和<code>stop</code>之间返回均匀间隔的<code>num</code>个数据</li><li><code>endpoint</code>控制是否包含<code>stop</code>点</li><li><code>retstep</code>控制是否返回间隔</li><li><code>axis</code>仅当<code>start</code>和<code>stop</code>为<code>array</code>时才有效，传入一维<code>array</code>时可取0或-1，<code>axis = -1</code> 相当于转置</li></ul><pre><code class="lang-python">a = np.linspace(1, 5, num=5, endpoint=True, retstep=True)print(a) # &gt;&gt;&gt;(array([1., 2., 3., 4., 5.]), 1.0)b = np.linspace([1,3,5], [1,5,7], num=5, endpoint=True, retstep=True, axis=0)print(b) &#39;&#39;&#39;&gt;&gt;&gt;(array([[1. , 1. , 1. , 1. , 1. ],       [3. , 3.5, 4. , 4.5, 5. ],       [5. , 5.5, 6. , 6.5, 7. ]]), array([0. , 0.5, 0.5]))&#39;&#39;&#39; c = np.linspace([1,3,5], [1,5,7], num=5, endpoint=True, retstep=True, axis=-1)print(c)&#39;&#39;&#39;&gt;&gt;&gt;(array([[1. , 3. , 5. ],       [1. , 3.5, 5.5],       [1. , 4. , 6. ],       [1. , 4.5, 6.5],       [1. , 5. , 7. ]]), array([0. , 0.5, 0.5]))&#39;&#39;&#39;</code></pre><p>当然也可以这样用：</p><pre><code class="lang-python">d = np.linspace([[1,3],[5,7]], [[1,5],[7,9]], num=5, endpoint=True, retstep=True, axis=2)</code></pre><p>多维数组的<code>axis</code>有些难理解，可以参考<a href="https://blog.csdn.net/m0_37673307/article/details/82118030" target="_blank" rel="noopener">这篇</a>，当传入n维数组时，<code>axis=n-1</code>与<code>axis=-1</code>等效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/basics/an_introduction_to_scientific_python_numpy.html#创建一个数组" target="_blank" rel="noopener">https://www.numpy.org.cn/article/basics/an_introduction_to_scientific_python_numpy.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84</a></li><li><a href="http://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">http://cs231n.github.io/python-numpy-tutorial/</a></li><li><a href="https://www.zhihu.com/question/62844162" target="_blank" rel="noopener">https://www.zhihu.com/question/62844162</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记五</title>
    <link href="/2020/02/22/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <url>/2020/02/22/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>图像梯度和边缘检测</p><a id="more"></a><h1 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h1><p>在谈及梯度之前需要先找到函数，图片是二维的离散函数，二维意味着需要找到求梯度的方向，离散意味着对于图片的梯度不是导数而是差分。下式就是按照水平从左到右方向每隔一个像素点求差分：</p><script type="math/tex; mode=display">\Delta f\left ( i,j \right )=f\left ( i+1,j \right )-f\left ( i,j \right )</script><h2 id="Prewitt-operator"><a href="#Prewitt-operator" class="headerlink" title="Prewitt operator"></a>Prewitt operator</h2><p>将上式用卷积的方式处理是就可以是有下面这个卷积核（Prewitt 边缘检测算子）：</p><script type="math/tex; mode=display">Prewitt = \frac{1}{9}\left[ \begin{matrix} -1 & 0 & 1 \newline -1 & 0 & 1 \newline -1 & 0 & 1 \end{matrix} \right]</script><p>使用Prewitt 算子处理后，值比较高的像素点意味着梯度较大，就是更解决边缘；值比较低的像素点意味着梯度较小，就是更解决平滑表面。</p><h2 id="Sobel-operator"><a href="#Sobel-operator" class="headerlink" title="Sobel operator"></a>Sobel operator</h2><p>考虑到对正在处理行的数据需要更多的重视，对Prewitt 边缘检测算子改进就形成了Sobel 边缘检测算子：</p><script type="math/tex; mode=display">Sobel_{x} = \frac{1}{9}\left[ \begin{matrix} -1 & 0 & 1 \newline -2 & 0 & 2 \newline -1 & 0 & 1 \end{matrix} \right]</script><p>如果是从上到下求差分那么算子就转换成：</p><script type="math/tex; mode=display">Sobel_{y} = \frac{1}{9}\left[ \begin{matrix} -1 & -2 & -1 \newline 0 & 0 & 0 \newline 1 & 2 & 1 \end{matrix} \right]</script><p>分别计算偏 x 方向的 <script type="math/tex">G_{x}</script>，偏 y 方向的 <script type="math/tex">G_{y}</script>，求绝对值，压缩到 [0, 255]区间，即 <script type="math/tex">G\left ( x,y \right )=G_{x}+G_{y}</script> 就是 sobel 边缘检测后的图像。</p><h2 id="Scharr-operator"><a href="#Scharr-operator" class="headerlink" title="Scharr operator"></a>Scharr operator</h2><p>Sobel算子在转动上没有完美的对称。因此Scharr想要改进这个特性。它曾提出了更大的5x5核心，不过后来最常被使用的是:</p><script type="math/tex; mode=display">Scharr_{x} = \frac{1}{9}\left[ \begin{matrix} 3 & 0 & -3 \newline 10 & 0 & -10 \newline 3 & 0 & -3 \end{matrix} \right]</script><p>或者：</p><script type="math/tex; mode=display">Scharr_{y} = \frac{1}{9}\left[ \begin{matrix} 3 & 10 & 3 \newline 0 & 0 & 0 \newline -3 & -10 & -3 \end{matrix} \right]</script><h2 id="Laplacian"><a href="#Laplacian" class="headerlink" title="Laplacian"></a>Laplacian</h2><p>上面两种算子都是针对图像这种二维离散函数求一阶差分得到的，而Laplace 算子则是求二阶差分。二阶差分定义如下：</p><script type="math/tex; mode=display">\Delta^{2} \left [f  \right ]\left ( i, j \right )=f\left ( i+1, j \right )-2f\left ( i, j \right )+f\left ( i-1, j \right )</script><p>包含x轴、y轴两个方向的卷积核为：</p><script type="math/tex; mode=display">Laplacian_{2} = \frac{1}{9}\left[ \begin{matrix} 0 & 1 & 0 \newline 1 & -4 & 1 \newline 0 & 1 & 0 \end{matrix} \right]</script><p>包含四个方向的卷积核为：</p><script type="math/tex; mode=display">Laplacian_{4} = \frac{1}{9}\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & -8 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><p>使用Laplace 算子处理后，由于所求为二阶差分，值接近0的像素点更有可能是边缘，但是对于灰度值相近的区域，经过卷积后的值也很接近0。</p><h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h2 id="Sobel"><a href="#Sobel" class="headerlink" title="Sobel"></a>Sobel</h2><pre><code class="lang-python">dst = cv.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/差分" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">https://www.jianshu.com/p/2334bee37de5</a></li><li><a href="https://blog.csdn.net/zhougynui/article/details/78837198" target="_blank" rel="noopener">https://blog.csdn.net/zhougynui/article/details/78837198</a></li><li><a href="https://zh.wikipedia.org/wiki/索貝爾算子" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B4%A2%E8%B2%9D%E7%88%BE%E7%AE%97%E5%AD%90</a></li><li><a href="http://codec.wang/opencv-python-edge-detection/" target="_blank" rel="noopener">http://codec.wang/opencv-python-edge-detection/</a></li><li><a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaa13106761eedf14798f37aa2d60404c9" target="_blank" rel="noopener">https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaa13106761eedf14798f37aa2d60404c9</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记四</title>
    <link href="/2020/02/20/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <url>/2020/02/20/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>NumPy的使用以及图片亮度和对比度分析</p><a id="more"></a><h1 id="OpenCV与NumPy"><a href="#OpenCV与NumPy" class="headerlink" title="OpenCV与NumPy"></a>OpenCV与NumPy</h1><p>OpenCV读取一张图片，返回的实际上是一个<code>numpy.ndarray</code>类。所以一些对<code>numpy.ndarray</code>的操作可以直接对<code>cv2.imread()</code>返回的对象使用。</p><pre><code class="lang-python">import cv2import numpy as npimg = cv2.imread(&#39;connelly.jpg&#39;)print(type(img)) # &lt;class &#39;numpy.ndarray&#39;&gt;rows, cols = img.shape[:2]print(rows, cols) # 210 270</code></pre><h2 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h2><p>根据像素值的行和列坐标可以访问特定像素点。对于BGR图像，它返回一个蓝色、绿色、红色值数组。灰度图像，只返回相应的亮度。</p><pre><code class="lang-python">px = img[100, 120]img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)px_gray = img_gray[100, 120]print(px) # [130 131 181]print(px_gray) # 146</code></pre><p>可以用同样的方式修改像素值。</p><pre><code class="lang-python">img[100, 120] = [255,255,255]</code></pre><p>NumPy是一个用于快速数组计算的优化库。因此，使用原生python的数组简单地访问每个像素值，并修改它将非常缓慢，不推荐这种方法。</p><p>上述方法通常用于选择数组区域，例如前5行和最后3列。对于单个像素访问，但用NumPy数组的方法、<code>array.tem()</code>和<code>array.itemset()</code>会更适合。因为它总是返回一个标量。因此，如果想访问所有的B，G，R值，你需要为所有通道分别调用<code>array.tem()</code>。</p><pre><code class="lang-python"># 获取红色通道值print(img.item(100, 120, 2)) # 181# 修改红色通道值img.itemset((100, 120, 2), 255)</code></pre><h2 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h2><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p><p><code>img.shape</code>可以访问图像的形状。 它返回一组行，列和通道的元组（如果图像是彩色的），如果图像是灰度，则返回的元组仅包含行数和列数。因此，检查加载的图像是灰度还是彩色图像是一种很好的方法。：</p><pre><code class="lang-python">print(img.shape) # (210, 270, 3)</code></pre><p><code>img.size</code>访问的像素总数：</p><pre><code class="lang-python">print(img.size) # 170100</code></pre><p>图像数据类型由<code>img.dtype</code>获得：</p><pre><code class="lang-python">print(img.dtype) # uint8</code></pre><p> <code>img.dtype</code>在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。</p><h2 id="提取ROI"><a href="#提取ROI" class="headerlink" title="提取ROI"></a>提取ROI</h2><p>ROI (Region of Interest)即感兴趣的区域，</p><pre><code class="lang-python">roi = img[100:200, 200:300]</code></pre><ul><li>直接指定范围即可，上面表示行数为<code>100-200</code>，列数为<code>200-300</code>的区域</li></ul><h2 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h2><p>有时需要在B,G,R通道图像上单独工作。需要将BGR图像分割为单个平面或者需要将这些单独的通道连接到BGR图像。可以通过以下方式完成：</p><pre><code class="lang-python">b,g,r = cv2.split(img)img = cv2.merge((b,g,r))</code></pre><p><code>cv2.split()</code> 是一项代价昂贵的的操作（就运算时间而言）。所以只有在需要时才使用这个方法。否则请使用Numpy索引。</p><pre><code class="lang-python">b = img[:,:,0]</code></pre><p>假设，想要将所有红色像素设为零，不需要像这样分割并将其等于零。 可以简单地使用Numpy索引，这样更快。</p><pre><code class="lang-python">img[:,:,2] = 0</code></pre><h1 id="图片亮度和对比度"><a href="#图片亮度和对比度" class="headerlink" title="图片亮度和对比度"></a>图片亮度和对比度</h1><p>简单的改变图片的亮度和对比度可以是一个线性的过程：</p><script type="math/tex; mode=display">g\left (i,j  \right )= \alpha \cdot f\left ( i,j \right )+\beta\tag{1}</script><p>式子1中<script type="math/tex">f\left ( i,j \right )</script>相当于就是原图像每个像素点对应色彩或灰度的映射。直观上看，<script type="math/tex">\alpha</script>决定了对比度，<script type="math/tex">\alpha</script>越大，各像素之间的差别越大，对比度越大。<script type="math/tex">\beta</script>决定了亮度，<script type="math/tex">\beta</script>越大，各像素整体都变大，亮度提升了。</p><p>但其实这种表述并不准确，因为在对图像进行线性处理时存在溢出的问题，当<script type="math/tex">\beta</script>值太大时，<script type="math/tex">g\left (i,j  \right )</script>由于超过数据类型的上限被OpenCV置为特定值（比如CV_8U会被置为255）。对于灰度图，这些值都被置为相同值，相当于这部分像素点对比度调节完全失效了；对于三通道的彩色图，有一部分通道溢出，则会导致对比度比预期小的现象。</p><p>另一个层面上，<script type="math/tex">\alpha</script>的改变也影响了亮度，因为上式中<script type="math/tex">\alpha</script>的变化会统一的放大或缩小所有像素点的灰度值。当想要提高对比度时，如果不变化<script type="math/tex">\beta</script>的值，视觉上的”亮度“还是会提升。不妨把上式改写成如下式子：</p><script type="math/tex; mode=display">g\left (i,j  \right )= \alpha \cdot \left (f\left ( i,j \right )-T  \right )+\beta\tag{2}</script><p>当<script type="math/tex">\alpha</script>大于1时，式子2表示将比T小的像素点的灰度值变得更小，把比T大的像素点的灰度值变得更大，这样当T值等于图像的平均灰度值（当然，是否就是平均灰度值也有待商榷）时就不会带来<script type="math/tex">\alpha</script>的改变影响亮度的问题了。式子1实际上就是式子2中T等于0的特例，所有像素点的灰度值都大于等于0，所以整幅图像的亮度被<script type="math/tex">\alpha</script>影响了。</p><p>完整的调整代码如下：</p><pre><code class="lang-python">import cv2import numpy as npimg = cv2.imread(&#39;connelly.jpg&#39;)# 此处需注意，下面有说明res = np.uint8(np.clip((2 * (np.int16(img) - 60) + 50), 0, 255))tmp = np.hstack((img, res))  # 两张图片横向合并显示cv2.imshow(&#39;image&#39;, tmp)cv2.waitKey(0)</code></pre><p>输出效果如下：</p><p><img src="compare.jpg" srcset="/img/loading.gif" alt=""></p><p>在用python改变图片的亮度和对比度时，有两个问题需要注意，第一个问题是数据类型，式子中其实有一个乘法，这是极有可能出现溢出的，如果代码是这样<code>res = np.uint8(np.clip((2 * img - 60) + 50), 0, 255))</code>，就会出现这样的结果:</p><p><img src="compare_wrong.jpg" srcset="/img/loading.gif" alt=""></p><p>解决的办法有两个，一是改变img的类型：使用<code>np.int16(img)</code>代替<code>img</code>；二是用浮点数<code>2.0</code>代替<code>2</code>，这样<code>2.0 * img</code>的数据类型会自动变成<code>float64</code>。</p><pre><code class="lang-python">print((2.0 * img).dtype) # float64</code></pre><p>第二个问题是对于溢出NumPy和OpenCV的处理方式不同：</p><pre><code class="lang-python">x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y))  # 250 + 10 = 260 =&gt; 255 --255封顶print(x + y)  # 250 + 10 = 260 % 256 = 4 --会溢出</code></pre><p>如果我们使用NumPy处理就需要使用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener"><code>np.clip()</code></a>函数将数据限定在0~255。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/other/py_basic_ops.html#目标" target="_blank" rel="noopener">https://www.numpy.org.cn/article/other/py_basic_ops.html#%E7%9B%AE%E6%A0%87</a></li><li><a href="https://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">https://blog.csdn.net/abc20002929/article/details/40474807</a></li><li><a href="https://docs.opencv.org/2.4/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html#basic-linear-transform" target="_blank" rel="noopener">https://docs.opencv.org/2.4/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html#basic-linear-transform</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NumPy</tag>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记三</title>
    <link href="/2020/02/19/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <url>/2020/02/19/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>图像混合与形态学操作</p><a id="more"></a><h1 id="图片混合"><a href="#图片混合" class="headerlink" title="图片混合"></a>图片混合</h1><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>图像混合<code>cv2.addWeighted()</code>要求两幅图片的形状（高度/宽度/通道数）必须相同，<script type="math/tex">\omega_{1}</script>和<script type="math/tex">\omega_{2}</script>分别为两幅图像的权重，b则是一个偏置：</p><script type="math/tex; mode=display">dst = \omega_{1}\times img1+\omega_{2}\times img2 + b</script><pre><code class="lang-python">img1 = cv2.imread(&#39;img1_name.jpg&#39;)img2 = cv2.imread(&#39;img2_name.png&#39;)res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0)</code></pre><p>特别的，当<script type="math/tex">\omega_{1}</script>和<script type="math/tex">\omega_{2}</script>都为1，b为0时，就是两张图片相加。可以用<code>cv2.add()</code>函数。numpy 中可以直接用<code>res = img1 + img2</code>相加，但这两者的结果并不相同：</p><pre><code class="lang-python">x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y))  # 250 + 10 = 260 =&gt; 255 --255封顶print(x + y)  # 250 + 10 = 260 % 256 = 4 --会溢出</code></pre><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>按位操作包括按位与/或/非/异或操作，如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。</p><ul><li><code>cv2.bitwise_and()</code>：按位与操作 </li><li><code>cv2.bitwise_not()</code>：按位非操作</li><li><code>cv2.bitwise_or()</code>：按位或操作</li><li><code>cv2.bitwise_xor()</code>：按位异或操作</li></ul><p>通过位操作，我们可以得到<a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a>（mask）——用来对另外一幅图片进行局部的遮挡的二值化图片，通过掩膜把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><pre><code class="lang-python">import cv2img1 = cv2.imread(&#39;lena.jpg&#39;)img2 = cv2.imread(&#39;opencv-logo-white.png&#39;)# 把logo放在左上角，所以我们只关心这一块区域rows, cols = img2.shape[:2]roi = img1[:rows, :cols]# 创建掩膜img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)mask_inv = cv2.bitwise_not(mask)# 保留除logo外的背景img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)dst = cv2.add(img1_bg, img2)  # 进行融合img1[:rows, :cols] = dst  # 融合后放在原图上cv2.imshow(&quot;dst&quot;,img1)cv2.waitKey(10000)</code></pre><p><img src="2020-02-20 124157.png" srcset="/img/loading.gif" alt=""></p><h1 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h1><h2 id="腐蚀膨胀"><a href="#腐蚀膨胀" class="headerlink" title="腐蚀膨胀"></a>腐蚀膨胀</h2><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有 0 和 255 ，所以小区域内有一个是 0 该像素点就为 0 。</p><p><img src="cv2_understand_erosion.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-python"># 腐蚀img = cv2.imread(&#39;j.bmp&#39;, 0)kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel)</code></pre><ul><li><code>kernel</code>：结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素：<ul><li>矩形结构：<code>cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))</code>  </li><li>椭圆结构：<code>cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))</code>  </li><li>十字形结构：<code>cv2.getStructuringElement(cv2.MORPH_CROSS, (5, 5))</code></li></ul></li></ul><p><img src="cv2_morphological_struct_element.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片”变胖”：</p><pre><code class="lang-python"># 膨胀dilation = cv2.dilate(img, kernel)</code></pre><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住），其作用是：分离物体，消除小区域。这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p><pre><code class="lang-python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))  # 定义结构元素img = cv2.imread(&#39;j_noise_out.bmp&#39;, 0)opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  # 开运算</code></pre><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p><pre><code class="lang-python">img = cv2.imread(&#39;j_noise_in.bmp&#39;, 0)closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  # 闭运算</code></pre><p><img src="cv2_morphological_opening_closing.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h2><ul><li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li></ul><pre><code class="lang-python">img = cv2.imread(&#39;school.bmp&#39;, 0)gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</code></pre><ul><li>顶帽：原图减去开运算后的图：<code>src - opening</code></li></ul><pre><code class="lang-python">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</code></pre><ul><li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li></ul><pre><code class="lang-python">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://codec.wang/opencv-python-erode-and-dilate/" target="_blank" rel="noopener">http://codec.wang/opencv-python-erode-and-dilate/</a></li><li><a href="http://codec.wang/opencv-python-image-blending/" target="_blank" rel="noopener">http://codec.wang/opencv-python-image-blending/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记二</title>
    <link href="/2020/02/17/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/02/17/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>滤波与阈值分割</p><a id="more"></a><h1 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h1><p>滤波是一种卷积操作，常用于图像的预处理。低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。</p><ul><li>低通滤波器是模糊</li><li>高通滤波器是锐化</li></ul><p>常见噪声有<a href="https://baike.baidu.com/item/椒盐噪声/3455958?fr=aladdin" target="_blank" rel="noopener">椒盐噪声</a>和<a href="https://baike.baidu.com/item/高斯噪声" target="_blank" rel="noopener">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><script type="math/tex; mode=display">kernel_{m} = \frac{1}{9}\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & 1 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><pre><code class="lang-python">img = cv2.imread(&#39;lena.jpg&#39;)blur = cv2.blur(img, (3, 3))  # 均值模糊</code></pre><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><script type="math/tex; mode=display">kernel_{b} = a\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & 1 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><p>用<code>cv2.boxFilter()</code>函数实现，当</p><pre><code class="lang-python"># 前面的均值滤波也可以用方框滤波实现blur = cv2.boxFilter(img, -1, (3, 3), normalize=True)</code></pre><ul><li>参数2：<code>ddtype</code>为目标的数据类型，取-1表示和原图相同</li><li>可选参数<code>normalize</code>为<code>True</code>的时候，方框滤波就是均值滤波，上式中的a就等于1/9；<code>normalize</code>为<code>False</code>的时候，a=1，相当于求区域内的像素和。</li></ul><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小。显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a href="http://codec.wang/opencv-python-smoothing-images/#番外小篇：高斯滤波卷积核" target="_blank" rel="noopener">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核：</p><script type="math/tex; mode=display">kernel_{g} = \left[ \begin{matrix} 0.0625 & 0.125 & 0.0625 \newline 0.125 & 0.25 & 0.125 \newline 0.0625 & 0.125 & 0.0625 \end{matrix} \right]</script><p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><pre><code class="lang-python"># 高斯滤波gaussian = cv2.GaussianBlur(img, (5, 5), 1)</code></pre><p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。</p><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除<strong>椒盐噪声</strong>和<strong>斑点噪声</strong>。中值是一种<strong>非线性操作</strong>，效率相比前面几种线性滤波要慢。</p><pre><code class="lang-python"># 中值滤波median = cv2.medianBlur(img, 5)</code></pre><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了另一种<strong>非线性滤波</strong>双边滤波。双边滤波在高斯滤波的基础上加入了对<strong>灰度信息的权重</strong>，即在邻域内，灰度值越接近中心点灰度值的点的权重更大，灰度值相差大的点权重越小。此权重大小，则由值域高斯函数确定。两者权重系数相乘，得到最终的卷积模板。</p><pre><code class="lang-python"># 双边滤波blur = cv2.bilateralFilter(img, 9, 75, 75)</code></pre><ul><li>参数2：d – Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from <code>sigmaSpace</code> .</li><li>参数3：sigmaColor – Filter sigma in the color space. </li><li>参数4：sigmaSpace – Filter sigma in the coordinate space. </li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p><p>上面的滤波函数都有一个可选参数<code>borderType</code>用来输入padding类型。</p><blockquote><p>BORDER_CONSTANT  <code>iiiiii|abcdefgh|iiiiiii</code> with some specified <code>i</code>  <br>BORDER_REPLICATE  <code>aaaaaa|abcdefgh|hhhhhhh</code>  <br>BORDER_REFLECT  <code>fedcba|abcdefgh|hgfedcb</code>  <br>BORDER_WRAP  <code>cdefgh|abcdefgh|abcdefg</code>  <br>BORDER_REFLECT_101  <code>gfedcb|abcdefgh|gfedcba</code>  <br>BORDER_TRANSPARENT  <code>uvwxyz|absdefgh|ijklmno</code>  <br>BORDER_REFLECT101  same as BORDER_REFLECT_101  <br>BORDER_DEFAULT  same as BORDER_REFLECT_101  <br>BORDER_ISOLATED  do not look outside of ROI</p></blockquote><h2 id="滤波总结"><a href="#滤波总结" class="headerlink" title="滤波总结"></a>滤波总结</h2><ul><li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li><li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li><li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li><li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li><li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li></ul><h1 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h1><h2 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h2><p>固定阈值分割很直接，像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><pre><code class="lang-PYTHON"># 阈值分割ret, th = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</code></pre><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><p><img src="threshold.png" srcset="/img/loading.gif" alt=""></p><p>最常见的就是前两种，相当于二值化。</p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<strong>它并不适用于明暗分布不均的图片</strong>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。</p><pre><code class="lang-python">import matplotlib.pyplot as pltimport cv2# 自适应阈值对比固定阈值img = cv2.imread(&#39;img_name.jpg&#39;, 0)# 固定阈值ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# 自适应阈值th2 = cv2.adaptiveThreshold(    img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 4)th3 = cv2.adaptiveThreshold(    img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 17, 6)titles = [&#39;Original&#39;, &#39;Global(v = 127)&#39;, &#39;Adaptive Mean&#39;, &#39;Adaptive Gaussian&#39;]images = [img, th1, th2, th3]for i in range(4):    plt.subplot(2, 2, i + 1), plt.imshow(images[i], &#39;gray&#39;)    plt.title(titles[i], fontsize=8)    plt.xticks([]), plt.yticks([])plt.show()</code></pre><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><h2 id="Otsu阈值法"><a href="#Otsu阈值法" class="headerlink" title="Otsu阈值法"></a>Otsu阈值法</h2><pre><code class="lang-python"># 先进行高斯滤波，再使用Otsu阈值法blur = cv2.GaussianBlur(img, (5, 5), 0)ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</code></pre><script type="math/tex; mode=display">g=\omega_0\omega_1(\mu_0-\mu_1)^2</script><p><strong>$ g $就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$ g $最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。<a href="http://codec.wang/opencv-python-extra-otsu-thresholding/" target="_blank" rel="noopener">原文地址</a></p><h2 id="背景差分"><a href="#背景差分" class="headerlink" title="背景差分"></a>背景差分</h2><p>背景差分（Background Subtraction, BS）是通过使用<strong>静态</strong>相机来生成前景蒙版（即包含属于场景中的<strong>移动对象</strong>的像素的二进制图像）的通用且广泛使用的技术。 顾名思义，BS是在当前帧和背景模型之间执行减法运算，其中场景的静态部分，或者可视为背景的所有内容将被减去，移动对象将会被提取出来。如下图所示。</p><p><img src="Background_Subtraction_Tutorial_Scheme.png" srcset="/img/loading.gif" alt=""></p><p>后台建模包括两个主要步骤：</p><ul><li>背景初始化 </li><li>当前帧更新 </li></ul><p>官方给出了下面的例子：</p><pre><code class="lang-python">from __future__ import print_functionimport cv2 as cvimport argparseparser = argparse.ArgumentParser(description=&#39;This program shows how to use background subtraction methods provided by OpenCV. You can process both videos and images.&#39;)parser.add_argument(&#39;--input&#39;, type=str, help=&#39;Path to a video or a sequence of image.&#39;, default=&#39;Video_name.mp4&#39;) # 输入视频路径parser.add_argument(&#39;--algo&#39;, type=str, help=&#39;Background subtraction method (KNN, MOG2).&#39;, default=&#39;KNN&#39;) # 输入差分方法: KNN or MOG2args = parser.parse_args()## [create]#create Background Subtractor objectsif args.algo == &#39;MOG2&#39;:    backSub = cv.createBackgroundSubtractorMOG2()else:    backSub = cv.createBackgroundSubtractorKNN()## [create]## [capture]capture = cv.VideoCapture(cv.samples.findFileOrKeep(args.input))if not capture.isOpened:    print(&#39;Unable to open: &#39; + args.input)    exit(0)## [capture]while True:    ret, frame = capture.read()    if frame is None:        break    ## [apply]    #update the background model    fgMask = backSub.apply(frame)    ## [apply]    ## [display_frame_number]    #get the frame number and write it on the current frame    cv.rectangle(frame, (10, 2), (100,20), (255,255,255), -1)    cv.putText(frame, str(capture.get(cv.CAP_PROP_POS_FRAMES)), (15, 15),               cv.FONT_HERSHEY_SIMPLEX, 0.5 , (0,0,0))    ## [display_frame_number]    ## [show]    #show the current frame and the fg masks    cv.imshow(&#39;Frame&#39;, frame)    cv.imshow(&#39;FG Mask&#39;, fgMask)    ## [show]    keyboard = cv.waitKey(30)    if keyboard == ord(&#39;q&#39;) or keyboard == 27:        break</code></pre><p>关于KNN，MOG2，GMG的区别之后再补充。移动的哆啦A梦如图</p><p><img src="114759.png" srcset="/img/loading.gif" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/06. 阈值分割" target="_blank" rel="noopener">https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/06.%20%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2</a></li><li><a href="http://codec.wang/opencv-python-smoothing-images/#目标" target="_blank" rel="noopener">http://codec.wang/opencv-python-smoothing-images/#%E7%9B%AE%E6%A0%87</a></li><li><a href="https://docs.opencv.org/4.2.0/d1/dc5/tutorial_background_subtraction.html" target="_blank" rel="noopener">https://docs.opencv.org/4.2.0/d1/dc5/tutorial_background_subtraction.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记一</title>
    <link href="/2020/02/09/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/09/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>图片与视频的基础操作</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>18年结束毕业设计之后，对OpenCV接触很少了。那时使用的是C++，借由最近使用python较多，学习OpenCV-python算是一种温故。本文主要参考了<a href="http://codec.wang/opencv-python" target="_blank" rel="noopener">OpenCV-Python图像处理教程</a>以及<a href="https://docs.opencv.org/4.2.0/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>需要注意图片的x，y轴排布，三通道以B-G-R排布，灰度图只有一个通道。</p><p><img src="1546842698102_gWO39TIUVK.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><pre><code class="lang-python"># 加载灰度图img = cv2.imread(&#39;lena.jpg&#39;, 0)</code></pre><ul><li>参数1：图片的文件名<ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li>参数2：读入方式，省略即采用默认值<ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><pre><code class="lang-python"># 创建窗口cv2.namedWindow(&#39;lena2&#39;, cv2.WINDOW_NORMAL)</code></pre><ul><li>参数1：窗口名称</li><li>参数2：窗口模式<ul><li><code>cv2.WINDOW_AUTOSIZE</code>表示窗口大小自适应图片</li><li><code>cv2.WINDOW_NORMAL</code>表示窗口大小可调整</li></ul></li></ul><pre><code class="lang-python"># 显示图片cv2.imshow(&#39;lena&#39;, img)</code></pre><ul><li>参数1：窗口名称</li><li>参数2：图片实例</li></ul><pre><code class="lang-python"># 保持图片显示cv2.waitKey(0)</code></pre><ul><li><p>参数：暂停时长，ms</p><p>为0时，表示无限长。</p></li><li><p>传回按键的ascii码, 如<code>ESC:27</code>、<code>s:115</code></p></li></ul><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><pre><code class="lang-python"># 保存图片cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>参数1：是包含后缀名的文件名</li></ul><pre><code class="lang-python">if cv2.waitKey(10000) == 115:     cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>显示10秒，当按下<code>s</code>时，保存图片</li></ul><pre><code class="lang-python">if cv2.waitKey(10000) == ord(&#39;q&#39;):     cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>也可以用<code>ord()</code>，按下<code>q</code>时，保存。</li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>OpenCV中很多简单的操作实际上是NumPy的操作，请参照<a href="https://lil-q.github.io/2020/02/20/OpenCV-python学习笔记四/">第四篇</a>。</p><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><pre><code class="lang-python">px = img[y, x]</code></pre><ul><li>先输入行，再输入列</li><li>对于彩色图像会返回依次为B-G-R三个通道的值组成的列表，例如<code>[100, 110, 120]</code></li><li>对于灰度图或者单通道图，只有一个值。例如<code>100</code></li></ul><pre><code class="lang-python">px_blue = img[y, x, 0]px_green = img[y, x, 1]px_red = img[y, x, 2]</code></pre><ul><li>获取单通道值</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h4><pre><code class="lang-python"># 彩色图像，返回一个包含行数（高度）、列数（宽度）和通道数的元组height, width, channels = img.shape# 灰度图，返回行数和列数的元组height, width = img.shape</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code class="lang-python">img.dtype</code></pre><p>实际上<code>img.dtype</code>现实的是图像的深度<code>depth</code>，C++中<code>type</code>包含图像深度<code>depth</code>（低三位）和通道数<code>channel</code>（高三位）。<code>channel</code>可以是1，2，3，n。<code>depth</code>有以下可选：</p><pre><code class="lang-c++">// &lt;interface.h&gt;#define CV_8U   0#define CV_8S   1#define CV_16U  2#define CV_16S  3#define CV_32S  4#define CV_32F  5#define CV_64F  6#define CV_16F  7</code></pre><ul><li>数字表示一个像素占几位内存，<code>U</code>表示<code>unsigned</code>，<code>S</code>表示<code>signed</code>，F表示<code>float</code></li></ul><h4 id="ROI-Region-of-Interest"><a href="#ROI-Region-of-Interest" class="headerlink" title="ROI (Region of Interest)"></a>ROI (Region of Interest)</h4><pre><code class="lang-python"># 截取ROIroi = img[100:200, 200:300]</code></pre><ul><li>直接指定范围即可，上面表示行数为<code>100-200</code>，列数为<code>200-300</code>的区域</li></ul><h4 id="通道分割和合并"><a href="#通道分割和合并" class="headerlink" title="通道分割和合并"></a>通道分割和合并</h4><pre><code class="lang-python"># 分割b, g, r = cv2.split(img)# 合并img = cv2.merge((b, g, r))</code></pre><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><pre><code class="lang-python">b = img[:, :, 0]</code></pre><h4 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h4><pre><code class="lang-python"># 转换图片类型cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></pre><ul><li>参数2：<a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li>颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code></li></ul><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><pre><code class="lang-python"># 按照指定的宽度、高度缩放图片res = cv2.resize(img, (132, 150))</code></pre><ul><li>参数2：顺序是宽度，高度；并非<code>.shape</code>中高度，宽度，通道的顺序</li></ul><pre><code class="lang-python"># 按照比例缩放，如x,y轴均放大一倍res2 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)</code></pre><ul><li><code>interpolation</code>，插值方法，默认是<code>INTER_LINEAR</code>，<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a>：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Enumerator</th><th></th></tr></thead><tbody><tr><td style="text-align:left">INTER_NEAREST Python: cv.INTER_NEAREST</td><td>nearest neighbor interpolation</td></tr><tr><td style="text-align:left">INTER_LINEAR Python: cv.INTER_LINEAR</td><td>bilinear interpolation</td></tr><tr><td style="text-align:left">INTER_CUBIC Python: cv.INTER_CUBIC</td><td>bicubic interpolation</td></tr><tr><td style="text-align:left">INTER_AREA Python: cv.INTER_AREA</td><td>resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.</td></tr><tr><td style="text-align:left">INTER_LANCZOS4 Python: cv.INTER_LANCZOS4</td><td>Lanczos interpolation over 8x8 neighborhood</td></tr><tr><td style="text-align:left">INTER_LINEAR_EXACT Python: cv.INTER_LINEAR_EXACT</td><td>Bit exact bilinear interpolation</td></tr><tr><td style="text-align:left">INTER_MAX Python: cv.INTER_MAX</td><td>mask for interpolation codes</td></tr><tr><td style="text-align:left">WARP_FILL_OUTLIERS Python: cv.WARP_FILL_OUTLIERS</td><td>flag, fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero</td></tr><tr><td style="text-align:left">WARP_INVERSE_MAP Python: cv.WARP_INVERSE_MAP</td><td>flag, inverse transformationFor example, <a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaa38a6884ac8b6e0b9bed47939b5362f3" target="_blank" rel="noopener">linearPolar</a> or <a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaec3a0b126a85b5ca2c667b16e0ae022d" target="_blank" rel="noopener">logPolar</a> transforms:flag is <strong>not</strong> set: dst(ρ,ϕ)=src(x,y)flag is set:</td></tr></tbody></table></div><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><pre><code class="lang-python">dst = cv2.flip(img, 1)</code></pre><ul><li>参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</li></ul><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><pre><code class="lang-python"># 平移图片import numpy as nprows, cols = img.shape[:2]# 定义平移矩阵，需要是numpy的float32类型# x轴平移100，y轴平移50M = np.float32([[1, 0, 100], [0, 1, 50]])# 用仿射变换实现平移dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#39;shift&#39;, dst)cv2.waitKey(0)</code></pre><ul><li><code>M</code>实际上是<a href="[https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/4289056?fr=aladdin](https://baike.baidu.com/item/仿射变换/4289056?fr=aladdin">仿射矩阵</a>)去除了最后一行，由矩阵<code>A</code>和向量<code>b</code>组成，由于只做平移，<code>A = [[1, 0], [0, 1]]</code></li></ul><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>平移相当于旋转的一种特例，但是由于仿射变换比较复杂，一般直接找很难找到这个矩阵，OpenCV提供了根据变换前后三个点的对应关系来自动求解，<code>M=cv2.getAffineTransform(pos1,pos2)</code>，其中两个位置就是变换前后的对应位置关系。输出的就是仿射矩阵<code>M</code>。然后再使用函数<code>cv2.warpAffine()</code>。</p><pre><code class="lang-python">from matplotlib import pyplot as pltimport cv2import numpy as npimg = cv2.imread(&#39;aier.jpg&#39;)rows,cols = img.shape[:2]pts1 = np.float32([[50,50],[200,50],[50,200]])pts2 = np.float32([[10,100],[200,20],[100,250]])M = cv2.getAffineTransform(pts1,pts2)#第三个参数：变换后的图像大小res = cv2.warpAffine(img,M,(rows,cols))plt.subplot(121)plt.imshow(img[:,:,::-1])plt.subplot(122)plt.imshow(res[:,:,::-1])plt.show()</code></pre><p>如果仅作旋转和缩放，可以使用 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><pre><code class="lang-python"># 45°旋转图片并缩小一半M = cv2.getRotationMatrix2D((cols / 2, rows / 2), 45, 0.5)dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#39;rotation&#39;, dst)cv2.waitKey(0)</code></pre><p>关于仿射和透视请参照<a href="http://codec.wang/opencv-python-extra-warpaffine-warpperspective/" target="_blank" rel="noopener">这里</a></p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><pre><code class="lang-python"># 打开摄像头capture = cv2.VideoCapture(0)</code></pre><ul><li>参数：摄像头的编号</li><li><code>capture</code>相当于创建的<code>VideoCapture</code>对象</li></ul><pre><code class="lang-python"># 获取摄像头画面ret, frame = capture.read()</code></pre><ul><li>返回值<code>ret</code>：布尔值，表示当前这一帧是否获取正确</li><li>返回值<code>frame</code>：一帧图像</li></ul><pre><code class="lang-python"># 获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等cap.get(propId)# 修改属性值cap.set(propId,value)</code></pre><ul><li><code>propId</code>是<code>0~18</code>的数字，代表不同的属性，完整的属性列表：</li></ul><blockquote><p><code>CV_CAP_PROP_POS_MSEC</code>: Current position of the video file in milliseconds.<br><code>CV_CAP_PROP_POS_FRAMES</code>: 0-based index of the frame to be decoded/captured next.<br><code>CV_CAP_PROP_POS_AVI_RATIO</code>: Relative position of the video file: 0 - start of the film, 1 - end of the film.<br><code>CV_CAP_PROP_FRAME_WIDTH</code>: Width of the frames in the video stream.<br><code>CV_CAP_PROP_FRAME_HEIGHT</code>: Height of the frames in the video stream.<br><code>CV_CAP_PROP_FPS</code>: Frame rate.<br><code>CV_CAP_PROP_FOURCC</code>: 4-character code of codec.<br><code>CV_CAP_PROP_FRAME_COUNT</code>: Number of frames in the video file.<br><code>CV_CAP_PROP_FORMAT</code>: Format of the Mat objects returned by retrieve() .<br><code>CV_CAP_PROP_MODE</code>: Backend-specific value indicating the current capture mode.<br><code>CV_CAP_PROP_BRIGHTNESS</code>: Brightness of the image (only for cameras).<br><code>CV_CAP_PROP_CONTRAST</code>: Contrast of the image (only for cameras).<br><code>CV_CAP_PROP_SATURATION</code>: Saturation of the image (only for cameras).<br><code>CV_CAP_PROP_HUE</code>: Hue of the image (only for cameras).<br><code>CV_CAP_PROP_GAIN</code>: Gain of the image (only for cameras).<br><code>CV_CAP_PROP_EXPOSURE</code>: Exposure (only for cameras).<br><code>CV_CAP_PROP_CONVERT_RGB</code>: Boolean flags indicating whether images should be converted to RGB.<br><code>CV_CAP_PROP_WHITE_BALANCE</code>: Currently unsupported<br><code>CV_CAP_PROP_RECTIFICATION</code>: Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend cur- rently)</p></blockquote><h2 id="本地视频"><a href="#本地视频" class="headerlink" title="本地视频"></a>本地视频</h2><pre><code class="lang-python"># 播放本地视频capture = cv2.VideoCapture(&#39;demo_video.mp4&#39;)while(capture.isOpened()):    ret, frame = capture.read()    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    cv2.imshow(&#39;frame&#39;, gray)    if cv2.waitKey(30) == ord(&#39;q&#39;):        break</code></pre><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><pre><code class="lang-python">capture = cv2.VideoCapture(0)# 定义编码方式并创建VideoWriter对象fourcc = cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)outfile = cv2.VideoWriter(&#39;output.avi&#39;, fourcc, 25., (640, 480))while(capture.isOpened()):    ret, frame = capture.read()    if ret:        outfile.write(frame)  # 写入文件        cv2.imshow(&#39;frame&#39;, frame)        if cv2.waitKey(1) == ord(&#39;q&#39;):            break    else:        break</code></pre><ul><li>创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：<ul><li>输出的文件名，如’output.avi’</li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码：<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a></li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul></li></ul><h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><h3 id="特定颜色物体追踪"><a href="#特定颜色物体追踪" class="headerlink" title="特定颜色物体追踪"></a>特定颜色物体追踪</h3><p><strong>HSV</strong>是一个常用于颜色识别的模型，相比<strong>BGR</strong>更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><pre><code class="lang-python">import cv2import numpy as npcapture = cv2.VideoCapture(0)# 蓝色的范围，不同光照条件下不一样，可灵活调整lower_blue = np.array([100, 100, 100])upper_blue = np.array([130, 255, 255])while(True):    # 1.捕获视频中的一帧    ret, frame = capture.read()    # 2.从BGR转换到HSV    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)    # 3.inRange()：介于lower/upper之间的为白色，其余黑色    mask = cv2.inRange(hsv, lower_blue, upper_blue)    # 4.只保留原图中的蓝色部分    res = cv2.bitwise_and(frame, frame, mask=mask)    cv2.imshow(&#39;frame&#39;, frame)    cv2.imshow(&#39;mask&#39;, mask)    cv2.imshow(&#39;res&#39;, res)    if cv2.waitKey(1) == ord(&#39;q&#39;):        break</code></pre><p>我房间比较暗，调低了点<code>lower_blue</code>中的饱和度和亮度，哆啦A梦如图：</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/2020-02-15_.png" srcset="/img/loading.gif" alt=""></p><h1 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h1><pre><code class="lang-python"># 创建一个名为test的窗口cv2.namedWindow(&#39;test&#39;)# 创建一个滑动条cv2.createTrackbar(&#39;R&#39;, &#39;test&#39;, 0, 255, nothing)</code></pre><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值，也可以用<code>cv2.getTrackbarPos()</code>得到：</p><pre><code class="lang-python">r = cv2.getTrackbarPos(&#39;R&#39;, &#39;test&#39;)</code></pre><ul><li>参数1是滑动条的名称</li><li>参数2是窗口的名称。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial" target="_blank" rel="noopener">https://github.com/ex2tron/OpenCV-Python-Tutorial</a></li><li><a href="https://blog.csdn.net/m0_37167788/article/details/78603307" target="_blank" rel="noopener">https://blog.csdn.net/m0_37167788/article/details/78603307</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习</title>
    <link href="/2020/02/05/HTML%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/05/HTML%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>HTML学习笔记</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建网页的标准标记语言。HTML 是一种基础技术，常与 <strong>CSS</strong>、<strong>JavaScript</strong> 一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取 HTML 文件，并将其渲染成可视化网页。HTML 描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。</p><p><h1><a id="title1">标题</a></h1><br>标题（Heading）是通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签进行定义的。<br><code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code> 定义最小的标题。<br></p><pre><code>&lt;h1&gt;演示标题一&lt;/h1&gt;&lt;h2&gt;演示标题二&lt;/h2&gt;&lt;h3&gt;演示标题三&lt;/h3&gt;</code></pre><blockquote><p><h1>演示标题一</h1></p><p><h2>演示标题二</h2></p><h3>演示标题三</h3></blockquote><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落是通过 <code>&lt;p&gt;</code> 标签定义的。</p><pre><code>&lt;p&gt;段落一&lt;/p&gt;&lt;p&gt;段落二&lt;/p&gt;</code></pre><blockquote><p>段落一</p> <p>段落二</p></blockquote><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>使用<code>&lt;br&gt;</code>标签，与 markdown 相同。当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p><p>可使用 <code>&lt;pre&gt;</code> 标签对空行和空格进行控制。</p><pre><code>&lt;p&gt;始不垂翅，&lt;br&gt;终能奋翼&lt;/p&gt;</code></pre><blockquote><p>始不垂翅，<br>终能奋翼</p></blockquote><pre><code>&lt;p&gt;    始不垂翅，    终能奋翼&lt;/p&gt;</code></pre><blockquote><p>    始不垂翅，    终能奋翼</p></blockquote><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><pre><code>&lt;p&gt;下面有一条水平线&lt;/p&gt;&lt;hr&gt;&lt;p&gt;上面有一条水平线&lt;/p&gt;</code></pre><blockquote><p>下面有一条水平线</p><hr><p>上面有一条水平线</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>注释写法如下:</p><pre><code class="lang-HTML">&lt;!-- 这是一个注释 --&gt;</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><pre><code>&lt;b&gt;加粗文本&lt;/b&gt;&lt;br&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;br&gt;&lt;code&gt;电脑自动输出&lt;/code&gt;&lt;br&gt;这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt;</code></pre><blockquote><p><b>加粗文本</b><br><br><i>斜体文本</i><br><br><code>电脑自动输出</code><br><br>这是 <sub> 下标</sub> 和 <sup> 上标</sup></p></blockquote><p>通常标签<code>&lt;strong&gt;</code>替换加粗标签<code>&lt;b&gt;</code>来使用，<code>&lt;em&gt;</code>替换<code>&lt;i&gt;</code>标签使用。</p><p>然而，这些标签的含义是不同的：</p><blockquote><p><code>&lt;b&gt;</code>与<code>&lt;i&gt;</code>定义粗体或斜体文本。</p><p><code>&lt;strong&gt;</code>或者<code>&lt;em&gt;</code>意味着你要呈现的文本是重要的，所以要突出显示。</p></blockquote><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><pre><code>&lt;address&gt;Written by &lt;a href=&quot;mailto:qitiantianc137@outlook.com&quot;&gt;lil-q&lt;/a&gt;.&lt;br&gt; Visit us at:&lt;br&gt;Example.com&lt;br&gt;Box 564, Disneyland&lt;br&gt;USA&lt;/address&gt;</code></pre><blockquote><address>Written by <a href="mailto:qitiantianc137@outlook.com" target="_blank" rel="noopener">lil-q</a>.<br> Visit us at:<br>Example.com<br>Box 564, Disneyland<br>USA</address></blockquote><h2 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h2><pre><code>&lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;&lt;acronym title=&quot;upset&quot;&gt;happy&lt;/acronym&gt;</code></pre><blockquote><p><abbr title="etcetera">etc.</abbr></p><acronym title="upset">happy</acronym></blockquote><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><pre><code>&lt;p&gt;该段落文字从左到右显示。&lt;/p&gt;  &lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;该段落文字从右到左显示。&lt;/bdo&gt;&lt;/p&gt;</code></pre><blockquote><p>该段落文字从左到右显示。</p>  <p><bdo dir="rtl">该段落文字从右到左显示。</bdo></p> </blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>&lt;p&gt;WWF&#39;s goal is to: &lt;q&gt;Build a future where people live in harmony with nature.&lt;/q&gt;We hope they succeed.&lt;/p&gt;</code></pre><blockquote><p>WWF's goal is to: <q>Build a future where people live in harmony with nature.</q>We hope they succeed.</p></blockquote><h2 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h2><pre><code>&lt;p&gt;My favorite color is &lt;del&gt;blue&lt;/del&gt; &lt;ins&gt;red&lt;/ins&gt;!&lt;/p&gt;</code></pre><blockquote><p>My favorite color is <del>blue</del> <ins>red</ins>!</p></blockquote><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><pre><code>&lt;a href=&quot;lil-q.github.io&quot;&gt;链接文本&lt;/a&gt;</code></pre><p><a href="url">链接文本</a></p><h2 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h2><pre><code>&lt;a href=&quot;https://lil-q.github.io/&quot; target=&quot;_blank&quot;&gt;访问主页!&lt;/a&gt;</code></pre><p><a href="https://lil-q.github.io/" target="_blank">访问主页!</a></p><h2 id="id-属性"><a href="#id-属性" class="headerlink" title="id 属性"></a>id 属性</h2><p>在HTML文档中插入ID:</p><pre><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></pre><p>在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”：</p><pre><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><p>或者，从另一个页面创建一个链接到”有用的提示部分(id=”tips”）”：</p><pre><code>&lt;a href=&quot;https://www.xxx.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><p>上面的标题其实藏了一个链接：</p><pre><code>&lt;h1&gt;&lt;a id=&quot;title1&quot;&gt;标题&lt;/a&gt;&lt;/h1&gt;</code></pre><p>下面这个例子将跳回标题章节的位置。</p><pre><code>&lt;a href=&quot;#title1&quot;&gt;返回标题章节&lt;/a&gt;</code></pre><p><a href="#title1">返回标题章节</a></p><h2 id="邮箱设置"><a href="#邮箱设置" class="headerlink" title="邮箱设置"></a>邮箱设置</h2><pre><code>&lt;p&gt;这是一个电子邮件链接：&lt;a href=&quot;mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!&quot; target=&quot;_top&quot;&gt;发送邮件!&lt;/a&gt;&lt;/p&gt;</code></pre><p>这是一个电子邮件链接：<a href="mailto:someone@example.com?cc=someoneelse@example.com&bcc=andsomeoneelse@example.com&subject=Summer%20Party&body=You%20are%20invited%20to%20a%20big%20summer%20party!" target="_top">发送邮件!</a></p><p><strong>注意:</strong> 单词之间的空格使用 %20 代替，以确保浏览器可以正常显示文本。</p><h1 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h1><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code> 元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种 <code>meta</code> 信息。</p><p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;noscript&gt;</code>, and <code>&lt;base&gt;</code>.</p><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p><code>&lt;title&gt;</code> 标签定义了不同文档的标题。</p><p><code>&lt;title&gt;</code> 在 HTML/XHTML 文档中是必须的。</p><p><code>&lt;title&gt;</code> 元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p><code>&lt;base&gt;</code> 标签描述了基本的链接地址/链接目标，该标签作为 HTML 文档中所有的链接标签的默认链接:</p><pre><code>&lt;head&gt;&lt;base href=&quot;http://www.xxx.com/images/&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;</code></pre><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><code>&lt;link&gt;</code> 标签定义了文档与外部资源之间的关系。</p><p><code>&lt;link&gt;</code> 标签通常用于链接到样式表:</p><pre><code>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt;</code></pre><h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.</p><p>在 <code>&lt;style&gt;</code> 元素中你也可以直接添加样式来渲染 HTML 文档:</p><pre><code>&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body {background-color:yellow}p {color:blue}&lt;/style&gt;&lt;/head&gt;</code></pre><h2 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h2><p>meta 标签描述了一些基本的元数据。</p><p><code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><p>为搜索引擎定义关键词:</p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</code></pre><p>为网页定义描述内容:</p><pre><code>&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</code></pre><p>定义网页作者:</p><pre><code>&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</code></pre><p>每30秒钟刷新当前页面:</p><pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></pre><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p><code>&lt;script&gt;</code> 标签用于加载脚本文件，如： JavaScript。</p><p><code>&lt;script&gt;</code> 元素在以后的章节中会详细描述。</p><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>在 HTML 中，图像由<code>&lt;img&gt;</code> 标签定义。</p><p><code>&lt;img&gt;</code> 是空标签，意思是说，它只包含属性，并且没有闭合标签。</p><pre><code>&lt;img src=&quot;https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png&quot; alt=&quot;flower&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</code></pre><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png" srcset="/img/loading.gif" alt="flower" width="300" height="200"></p><ul><li>src 指 “source”。源属性的值是图像的 URL 地址。</li><li>alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。</li><li>height（高度）与 width（宽度）属性用于设置图像的高度与宽度。</li><li>border（边框）可以指定图像的边框宽度。</li><li><a href="https://www.runoob.com/try/try.php?filename=tryhtml_areamap" target="_blank" rel="noopener">图片map的用法</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/html/html-tutorial.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-nCoV疫情数据可视化地图</title>
    <link href="/2020/02/01/%E5%BA%94%E7%94%A8%E4%B8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/"/>
    <url>/2020/02/01/%E5%BA%94%E7%94%A8%E4%B8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>爬取2019-nCoV新型冠状病毒肺炎各省份确诊人数分布数据并制作数据可视化地图</p><a id="more"></a><h1 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h1><p>在学习<a href="https://blog.csdn.net/xufive/article/details/104093197" target="_blank" rel="noopener">该博客</a>的数据爬取时发现数据似乎已经不再更新，所以重新在<a href="https://news.qq.com/zt2020/page/feiyan.htm?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">腾讯新闻网站</a>搜索相关数据。</p><p><img src="213627.png" srcset="/img/loading.gif" alt="shuju"></p><p>使用<code>time</code>、<code>json</code>和<code>requests</code>获取数据。</p><pre><code class="lang-python">import time, json, requestsurl = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39;%int(time.time()*1000)data = json.loads(requests.get(url=url).json()[&#39;data&#39;])print(data)</code></pre><p>可以看到数据如下所示（省略部分内容）：</p><pre><code class="lang-python">{&#39;chinaTotal&#39;: {&#39;date&#39;: &#39;02.01&#39;, &#39;confirm&#39;: &#39;11890&#39;, &#39;suspect&#39;: &#39;17988&#39;, &#39;dead&#39;: &#39;259&#39;, &#39;heal&#39;: &#39;269&#39;}, &#39;lastUpdateTime&#39;: &#39;2020-02-01 21:18:01&#39;, &#39;areaTree&#39;: [{&#39;name&#39;: &#39;中国&#39;, &#39;children&#39;: [{&#39;name&#39;: &#39;湖北&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 7153, &#39;suspect&#39;: 0, &#39;dead&#39;: 249, &#39;heal&#39;: 166}, &#39;today&#39;: {&#39;confirm&#39;: 1347, &#39;suspect&#39;: -49, &#39;dead&#39;: 49, &#39;heal&#39;: 15}}, {&#39;name&#39;: &#39;浙江&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 599, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 20}, &#39;today&#39;: {&#39;confirm&#39;: 62, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 7}}, ...</code></pre><p>我们只获取各个省份确诊人数的信息已经最后更新的时间。</p><pre><code class="lang-python">def catch_distribution():    areaData = {}    url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39;%int(time.time()*1000)    data = json.loads(requests.get(url=url).json()[&#39;data&#39;])    # print(data)    # 获取更新时间    lastUpdateTime = data[&#39;lastUpdateTime&#39;]    # 找到中国信息    for item in data[&#39;areaTree&#39;]:        if item[&#39;name&#39;] == &#39;中国&#39;:            chinaData = item[&#39;children&#39;]            break    # 获取各个省份确诊的人数    for item in chinaData:        areaData[item[&#39;name&#39;]] = item[&#39;total&#39;][&#39;confirm&#39;]    return areaData, lastUpdateTime</code></pre><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>这里使用的是<a href="https://pyecharts.org/#/zh-cn/quickstart" target="_blank" rel="noopener">pyecharts v1</a>，似乎腾讯新闻也是用的这个包。由于湖北人数远高于其他省份，<a href="https://zhuanlan.zhihu.com/p/104026698" target="_blank" rel="noopener">使用连续型的视觉映射效果不好</a>，这里采用了分段式的，可以以10的整数幂为界限传入<code>pieces</code>，<code>time</code>参数即之前得到的最近更新时间。</p><pre><code class="lang-python">def map_visualmap(time, pieces) -&gt; Map:    c = (        Map()        .add(&quot;确诊人数&quot;, data.items(), &quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全国各省份确诊人数分布\n截至: &quot; + time),            visualmap_opts=opts.VisualMapOpts(max_=5000, is_piecewise=True, pieces=pieces)        )    )    return c</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="lang-python">import timeimport jsonimport requestsimport numpy as npfrom pyecharts import options as optsfrom pyecharts.charts import Mapdef catch_distribution():    areaData = {}    url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39; % int(        time.time()*1000)    data = json.loads(requests.get(url=url).json()[&#39;data&#39;])    # 获取更新时间    lastUpdateTime = data[&#39;lastUpdateTime&#39;]    # 找到中国信息    for item in data[&#39;areaTree&#39;]:        if item[&#39;name&#39;] == &#39;中国&#39;:            chinaData = item[&#39;children&#39;]            break    # 获取各个省份确诊的人数    for item in chinaData:        areaData[item[&#39;name&#39;]] = item[&#39;total&#39;][&#39;confirm&#39;]    return areaData, lastUpdateTime# 官网范例中的链式调用def map_visualmap(time, pieces, data) -&gt; Map:    c = (        Map()        .add(&quot;确诊人数&quot;, data.items(), &quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全国各省份确诊人数分布\n截至: &quot; + time),            visualmap_opts=opts.VisualMapOpts(                max_=5000, is_piecewise=True, pieces=pieces)        )    )    return cdata, lastUpdateTime = catch_distribution()pieces = [    {&quot;min&quot;: 1000},    {&quot;min&quot;: 100, &quot;max&quot;: 1000},    {&quot;min&quot;: 10, &quot;max&quot;: 100},    {&quot;max&quot;: 10}]map1 = map_visualmap(lastUpdateTime, pieces, data)map1.render()</code></pre><p>最后的效果如下，</p><p><img src="2sd15400.png" srcset="/img/loading.gif" alt="xiaoguo"></p><p>运行后会在根目录下生成<a href="https://lil-q.github.io/pageDemo/render.html">render.html</a></p><p><a href="https://github.com/lil-q/2019-nCoV-VisualMap/blob/master/2019-nCoV-VisualMap.py" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    
    <categories>
      
      <category>应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL(Structured Query Language)</title>
    <link href="/2020/01/16/SQL-Structured-Query-Language/"/>
    <url>/2020/01/16/SQL-Structured-Query-Language/</url>
    
    <content type="html"><![CDATA[<p>SQL基础语句快查</p><a id="more"></a><p>原教程地址：<a href="http://www.xuesql.cn/" target="_blank" rel="noopener">http://www.xuesql.cn/</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="1-1-什么是SQL-Structured-Query-Language"><a href="#1-1-什么是SQL-Structured-Query-Language" class="headerlink" title="1.1 什么是SQL(Structured Query Language)"></a>1.1 什么是SQL(Structured Query Language)</h2><p><code>SQL</code>, 全称为Structured Query Language（结构化查询语言)。 要讲SQL就绕不开database(数据库), 平时所说的数据库，一般就是指的 <code>Relational database(关系型数据库)</code>。</p><p>大家知道数据库是用来存储大量数据的一种软件，那么SQL呢是用来操作数据里的数据，具体来说SQL可以做数据查询，数据更新，写入数据等等。</p><h2 id="1-2-关系型数据库-Relational-databases"><a href="#1-2-关系型数据库-Relational-databases" class="headerlink" title="1.2 关系型数据库(Relational databases)"></a>1.2 关系型数据库(Relational databases)</h2><p>在学习SQL语法之前有必要解释一下什么是关系型数据库（Relational databases)？数据库由若干张<code>表</code>(Table)组成，这里说的数据Table很像Excel里的表; 正如Excel里的表格，Table也是由 <code>行(rows)</code>和<code>列(columns)</code>组成。</p><p>一个Table存储一个类别的数据，每一行是一条数据，每一列是这种数据的一个属性； Table就像一个二维的表格，<code>列(columns)</code>是有限固定的，<code>行(rows)</code>是无限不固定的。</p><h1 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询(SELECT)"></a>查询(SELECT)</h1><p>Select 查询某些属性列（specific columns）的语法。</p><pre><code class="lang-sql">SELECT column（列名）, another_column, …FROM mytable（表名）;</code></pre><p>Select 查询所有列。</p><pre><code class="lang-sql">SELECT *FROM mytable（表名）;</code></pre><h1 id="条件查询-WHERE"><a href="#条件查询-WHERE" class="headerlink" title="条件查询 (WHERE)"></a>条件查询 (WHERE)</h1><p>条件查询语法。WHERE</p><pre><code class="lang-SQL">SELECT column, another_column, …FROM mytableWHERE condition    AND/OR another_condition    AND/OR …;</code></pre><div class="table-container"><table><thead><tr><th>Operator（关键字）</th><th>Condition（意思）</th><th><strong>SQL Example(例子）</strong></th></tr></thead><tbody><tr><td>=, !=, &lt; &lt;=, &gt;, &gt;=</td><td>Standard numerical operators 基础的 大于，等于等比较</td><td>col_name != 4</td></tr><tr><td>BETWEEN … AND …</td><td>Number is within range of two values (inclusive) 在两个数之间</td><td>col_name BETWEEN 1.5 AND 10.5</td></tr><tr><td>NOT BETWEEN … AND …</td><td>Number is not within range of two values (inclusive) 不在两个数之间</td><td>col_name NOT BETWEEN 1 AND 10</td></tr><tr><td>IN (…)</td><td>Number exists in a list 在一个列表</td><td>col_name IN (2, 4, 6)</td></tr><tr><td>NOT IN (…)</td><td>Number does not exist in a list 不在一个列表</td><td>col_name NOT IN (1, 3, 5)</td></tr></tbody></table></div><h1 id="模糊查询-LIKE-和-通配符-）"><a href="#模糊查询-LIKE-和-通配符-）" class="headerlink" title="模糊查询(LIKE) 和 通配符(%）"></a>模糊查询(LIKE) 和 通配符(%）</h1><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE “ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col<em>name LIKE “AN</em>“ (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr><tr><td>NOT IN (…)</td><td>String does not exist in a list 不在列表</td><td>col_name NOT IN (“D”, “E”, “F”)</td></tr></tbody></table></div><h1 id="过滤-DISTINCT"><a href="#过滤-DISTINCT" class="headerlink" title="过滤(DISTINCT)"></a>过滤(DISTINCT)</h1><p>选取出唯一的结果的语法</p><pre><code class="lang-sql">SELECT DISTINCT column, another_column, … FROM mytable WHERE condition(s);</code></pre><h1 id="排序-ORDER"><a href="#排序-ORDER" class="headerlink" title="排序(ORDER)"></a>排序(ORDER)</h1><p>结果排序（ordered results）</p><pre><code class="lang-sql">SELECT column, another_column, … FROM mytable WHERE condition(s)ORDER BY column ASC/DESC;</code></pre><p><code>ASC</code>：升序；<code>DESC</code>：降序。</p><h1 id="选取-LIMIT-OFFSET"><a href="#选取-LIMIT-OFFSET" class="headerlink" title="选取(LIMIT, OFFSET)"></a>选取(LIMIT, OFFSET)</h1><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。</p><pre><code class="lang-sql">SELECT column, another_column, …FROM table1WHERE condition(s)ORDER BY column ASC/DESC, another_column ASC/DESC, …LIMIT num_limit OFFSET num_offset;</code></pre><h1 id="多表联合-JOIN"><a href="#多表联合-JOIN" class="headerlink" title="多表联合(JOIN)"></a>多表联合(JOIN)</h1><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键。借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来。</p><p><img src="joins.png" srcset="/img/loading.gif" alt="joins"></p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>用INNER JOIN 连接表的语法。通过<code>ON</code>条件描述的关联关系;<code>INNER JOIN</code> 先将两个表数据连接到一起. 两个表中如果通过ID互相找不到的数据将会舍弃。</p><pre><code class="lang-sql">SELECT table1.column, table2.another_table_column, … FROM table1 （主表） INNER JOIN table2 （要连接的表）        ON table1.id = table2.matching_id WHERE condition(s) ORDER BY table1.column, … ASC/DESC LIMIT num_limit OFFSET num_offset;</code></pre><h2 id="OUTER-JOINs"><a href="#OUTER-JOINs" class="headerlink" title="OUTER JOINs"></a>OUTER JOINs</h2><p><code>INNER JOIN</code> 只会保留两个表都存在的数据（还记得之前的交集吗），这看起来意味着一些数据的丢失，在某些场景下会有问题.</p><p>用LEFT/RIGHT/FULL JOINs 做多表查询</p><pre><code class="lang-sql">SELECT table1.column, table2.another_table_column, … FROM table1 （主表） LEFT/RIGHT/FULL JOIN table2 （要连接的表）        ON table1.id = table2.matching_id WHERE condition(s) ORDER BY table1.column, … ASC/DESC LIMIT num_limit OFFSET num_offset;</code></pre><h1 id="表达式-AS"><a href="#表达式-AS" class="headerlink" title="表达式(AS)"></a>表达式(AS)</h1><p>当我们用表达式对col属性计算时，很多事可以在SQL内完成，这让SQL更加灵活，但表达式如果长了则很难一下子读懂。所以SQL提供了<code>AS</code>关键字， 来给表达式取一个别名.</p><pre><code class="lang-sql">SELECT col_expression AS expr_descriptionFROM table1 AS newTableNameWHERE condition(s)ORDER BY expr_description ASC/DESCLIMIT num_limit OFFSET num_offset;</code></pre><h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><p>下面介绍几个常用统计函数:</p><div class="table-container"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(column)**</td><td>计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数.</td></tr><tr><td><strong>MIN(column)</strong></td><td>找column最小的一行.</td></tr><tr><td><strong>MAX(column)</strong></td><td>找column最大的一行.</td></tr><tr><td><strong>AVG(column)</strong></td><td>对column所有行取平均值.</td></tr><tr><td><strong>SUM(column)</strong></td><td>对column所有行求和.</td></tr></tbody></table></div><p>当不求整组数据时，可以使用<code>GROUP BY</code> 对数据分组。</p><pre><code class="lang-sql">SELECT column, count(*)*100/(SELECT count(*) FROM table1) FROM table1 WHERE column in (1,3,5,7)GROUP BY column;</code></pre><p>可以通过嵌套一个select来实现百分比的求解。</p><p>数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选就需要使用 <code>HAVING</code> 语法。</p><pre><code class="lang-sql">SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …FROM mytableWHERE conditionGROUP BY columnHAVING group_condition;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的SELECT查询</p><pre><code class="lang-sql">SELECT DISTINCT column, AGG_FUNC(column_or_expression), …FROM mytableJOIN another_table    ON mytable.column = another_table.columnWHERE constraint_expressionGROUP BY columnHAVING constraint_expressionORDER BY column ASC/DESCLIMIT count OFFSET COUNT;</code></pre><h2 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. FROM 和 JOINs</h2><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p><h2 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. WHERE</h2><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h2 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. GROUP BY</h2><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h2 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. HAVING</h2><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p><h2 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. SELECT</h2><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p><h2 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. DISTINCT</h2><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p><h2 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. ORDER BY</h2><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p><h2 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. LIMIT / OFFSET</h2><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>松山湖</title>
    <link href="/2020/01/14/%E6%9D%BE%E5%B1%B1%E6%B9%96/"/>
    <url>/2020/01/14/%E6%9D%BE%E5%B1%B1%E6%B9%96/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>这个镜头和我一样，罹患飞蚊症。大光圈时倒是看不出来，调小了拍风景就变得显眼。不经意看拍的松山湖，还以为有飞鸟击水。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7350.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7367.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7377.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7383.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7475.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch基础</title>
    <link href="/2020/01/02/PyTorch%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/01/02/PyTorch%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>PyTorch官方中文文档学习笔记</p><a id="more"></a><h1 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量(Tensors)"></a>张量(Tensors)</h1><h2 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h2><pre><code class="lang-python"># 创建一个5x3的矩阵，不初始化x_1 = torch.empty(5, 3)# 构造一个随机初始化的矩阵x_2 = torch.rand(5, 3)# 构造一个矩阵全为 0，而且数据类型是 longx_3 = torch.zeros(5, 3, dtype=torch.long)# 构造一个张量，直接使用数据x_4 = torch.tensor([5.5, 3])</code></pre><p>输出：</p><pre><code class="lang-python">x_1: tensor([[1.2875e-35, 0.0000e+00, 1.2875e-35],             [0.0000e+00, 1.7290e-39, 0.0000e+00],             [1.7290e-39, 0.0000e+00, 1.2876e-35],             [0.0000e+00, 1.2876e-35, 0.0000e+00],             [1.2876e-35, 0.0000e+00, 1.2876e-35]])x_2: tensor([[0.8532, 0.0308, 0.7529],             [0.0109, 0.3987, 0.9199],             [0.8618, 0.2898, 0.7708],             [0.8400, 0.3074, 0.9531],             [0.8799, 0.3668, 0.9811]])x_3: tensor([[0, 0, 0],             [0, 0, 0],             [0, 0, 0],             [0, 0, 0],             [0, 0, 0]])x_4: tensor([5.5000, 3.0000])</code></pre><h2 id="张量数据类型"><a href="#张量数据类型" class="headerlink" title="张量数据类型"></a>张量数据类型</h2><p>PyTorch提供了9种用于CPU和GPU的张量类型：</p><div class="table-container"><table><thead><tr><th>Data type</th><th>dtype</th><th>CPU tensor</th><th>GPU tensor</th></tr></thead><tbody><tr><td>32-bit floating point</td><td><code>torch.float32</code> or <code>torch.float</code></td><td><code>torch.FloatTensor</code></td><td><code>torch.cuda.FloatTensor</code></td></tr><tr><td>64-bit floating point</td><td><code>torch.float64</code> or <code>torch.double</code></td><td><code>torch.DoubleTensor</code></td><td><code>torch.cuda.DoubleTensor</code></td></tr><tr><td>16-bit floating point</td><td><code>torch.float16</code> or <code>torch.half</code></td><td><code>torch.HalfTensor</code></td><td><code>torch.cuda.HalfTensor</code></td></tr><tr><td>8-bit integer (unsigned)</td><td><code>torch.uint8</code></td><td><code>torch.ByteTensor</code></td><td><code>torch.cuda.ByteTensor</code></td></tr><tr><td>8-bit integer (signed)</td><td><code>torch.int8</code></td><td><code>torch.CharTensor</code></td><td><code>torch.cuda.CharTensor</code></td></tr><tr><td>16-bit integer (signed)</td><td><code>torch.int16</code> or <code>torch.short</code></td><td><code>torch.ShortTensor</code></td><td><code>torch.cuda.ShortTensor</code></td></tr><tr><td>32-bit integer (signed)</td><td><code>torch.int32</code> or <code>torch.int</code></td><td><code>torch.IntTensor</code></td><td><code>torch.cuda.IntTensor</code></td></tr><tr><td>64-bit integer (signed)</td><td><code>torch.int64</code> or <code>torch.long</code></td><td><code>torch.LongTensor</code></td><td><code>torch.cuda.LongTensor</code></td></tr><tr><td>Boolean</td><td><code>torch.bool</code></td><td><code>torch.BoolTensor</code></td><td><code>torch.cuda.BoolTensor</code></td></tr></tbody></table></div><h2 id="张量的运算"><a href="#张量的运算" class="headerlink" title="张量的运算"></a>张量的运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><pre><code class="lang-python">x_1 = torch.ones(3, 3)print(&#39;x_1&#39;, x_1, x_1.dtype)x_2 = x_1 * 2print(&#39;x_2&#39;, x_2)# 加法一y_1 = x_1 + x_2print(&#39;y_1&#39;, y_1)# 加法二y_2 = torch.add(x_1, x_2)print(&#39;y_2&#39;, y_2)# 加法三y_3 = x_1.add(x_2)print(&#39;y_3&#39;, y_3)print(&#39;x_1&#39;, x_1)# 加法四(in-place)y_3 = x_1.add_(x_2)print(&#39;y_3&#39;, y_3)print(&#39;x_1&#39;, x_1)</code></pre><p>输出：</p><pre><code class="lang-python">x_1 tensor([[1., 1., 1.],            [1., 1., 1.],            [1., 1., 1.]]) torch.float32x_2 tensor([[2., 2., 2.],            [2., 2., 2.],            [2., 2., 2.]])# 加法一：y_1 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])# 加法二：y_2 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])# 加法三：y_3 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])x_1 tensor([[1., 1., 1.],            [1., 1., 1.],            [1., 1., 1.]])# 加法四(in-place)：y_3 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])x_1 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre><code class="lang-python"># 哈达玛积(element wise，对应元素相乘)# mul和*等效y_4 = torch.mul(x_1, x_2)y_5 = x_1*x_2# 矩阵相乘# matmul和mm等效y_6 = torch.matmul(x_1, x_2)y_7 = torch.mm(x_1, x_2)y_8 = x_1.mm(x_2)</code></pre><p>输出：</p><pre><code class="lang-python"># 哈达玛积(element wise，对应元素相乘)# mul和*等效# 注意：x_1中的值已经变成3了y_4 tensor([[6., 6., 6.],            [6., 6., 6.],            [6., 6., 6.]])y_5 tensor([[6., 6., 6.],            [6., 6., 6.],            [6., 6., 6.]])# 矩阵相乘# matmul和mm等效y_6 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])y_7 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])y_8 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])</code></pre><h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><p><code>torch.Tensor</code> 是包的核心类。如果将其属性 <code>.requires_grad</code>设置为<code>True</code>，则会开始跟踪针对 <code>tensor</code> 的所有操作。完成计算后，您可以调用 <code>.backward()</code>来自动计算所有梯度。该张量的梯度将累积到<code>.grad</code>属性中。</p><pre><code class="lang-python">import torchx = torch.ones(2, 2)print(x.requires_grad)# print: Falsex.requires_grad_(True)# print: tensor([[1., 1.],#                 [1., 1.]], requires_grad=True)</code></pre><p>还有一个类对于 <code>autograd</code> 实现非常重要那就是 <code>Function</code>。<code>Tensor</code> 和 <code>Function</code> 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息。每个张量都有一个 <code>.grad_fn</code> 属性保存着创建了张量的 <code>Function</code> 的引用，（如果用户自己创建张量，则<code>grad_fn</code> 是 <code>None</code> ）。</p><p>如果你想计算导数，你可以调用 <code>Tensor.backward()</code>。如果 <code>Tensor</code> 是标量（<strong>即它包含一个元素数据，相当于权重是1</strong>），则不需要指定任何参数<code>backward()</code>，但是如果它有更多元素，则需要指定一个<code>gradient</code> 参数（<strong>每个维度的权重</strong>）来指定张量的形状。</p><pre><code class="lang-python">y = x + 2print(y)# print:# tensor([[3., 3.],#         [3., 3.]], grad_fn=&lt;AddBackward0&gt;)print(y.grad_fn)# print: (y 作为操作的结果被创建，所以它有 grad_fn)# &lt;AddBackward0 object at 0x7fe1db427470&gt;z = y * y * 3out = z.mean()print(z, out)# print: # tensor([[27., 27.],#         [27., 27.]], grad_fn=&lt;MulBackward0&gt;) # tensor(27., grad_fn=&lt;MeanBackward0&gt;)out.backward()print(x.grad)# print:# tensor([[4.5000, 4.5000],#        [4.5000, 4.5000]])</code></pre><p>需要输入权重的雅克比向量积的例子：</p><pre><code class="lang-python">x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000:    y = y * 2print(y)# print:# tensor([ -444.6791,   762.9810, -1690.0941], grad_fn=&lt;MulBackward0&gt;)v = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(v)print(x.grad)# print:# tensor([1.0240e+02, 1.0240e+03, 1.0240e-01])</code></pre><p>要停止<code>tensor</code>历史记录的跟踪，可以调用<code>.detach()</code>，它将其与计算历史记录分离，并防止将来的计算被跟踪。还可以将代码块使用 <code>with torch.no_grad():</code> 包装起来。在评估模型时，这是特别有用，因为模型在训练阶段具有 <code>requires_grad = True</code>的可训练参数有利于调参，但在评估阶段我们不需要梯度。</p><pre><code class="lang-python">print(x.requires_grad)print((x ** 2).requires_grad)# print:# True# Truewith torch.no_grad():    print((x ** 2).requires_grad)# print:# False</code></pre><h1 id="数据-Dataset"><a href="#数据-Dataset" class="headerlink" title="数据(Dataset)"></a>数据(Dataset)</h1><p>本节内容针对<a href="http://pytorch123.com/ThirdSection/DataLoding/" target="_blank" rel="noopener">PyTorch中文文档-数据加载和处理</a>。</p><h2 id="建立数据集"><a href="#建立数据集" class="headerlink" title="建立数据集"></a>建立数据集</h2><p><code>torch.utils.data.Dataset</code>是代表自定义数据集方法的<a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">抽象类</a>，你可以自己定义你的数据类继承这个抽象类，非常简单，只需要定义<code>__len__</code>和<code>__getitem__</code>这两个方法就可以。</p><pre><code class="lang-python">class FaceLandmarksDataset(Dataset):    &quot;&quot;&quot;面部标记数据集.&quot;&quot;&quot;    def __init__(self, csv_file, root_dir, transform=None):        &quot;&quot;&quot;        csv_file（string）：带注释的csv文件的路径。        root_dir（string）：包含所有图像的目录。        transform（callable， optional）：一个样本上的可用的可选变换        &quot;&quot;&quot;        self.landmarks_frame = pd.read_csv(csv_file)        self.root_dir = root_dir        self.transform = transform    def __len__(self):        return len(self.landmarks_frame)    def __getitem__(self, idx):        # 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。        # iloc相当于切片。index location        img_name = os.path.join(self.root_dir,                                self.landmarks_frame.iloc[idx, 0])        # skimage.io.imread: 直接返回numpy.ndarray 对象，通道顺序为RGB，通道值默认范围0-255，uint8。        image = io.imread(img_name)        landmarks = self.landmarks_frame.iloc[idx, 1:]        landmarks = np.array([landmarks])        # uint8-&gt;float        landmarks = landmarks.astype(&#39;float&#39;).reshape(-1, 2)        sample = {&#39;image&#39;: image, &#39;landmarks&#39;: landmarks}        if self.transform:            sample = self.transform(sample)        return sample</code></pre><h2 id="数据变形"><a href="#数据变形" class="headerlink" title="数据变形"></a>数据变形</h2><p>通过上面的例子我们会发现图片并不是同样的尺寸。绝大多数神经网络都假定图片的尺寸相同。因此我们需要做一些预处理。让我们创建三个转换: <em> <code>Rescale</code>：缩放图片 </em> <code>RandomCrop</code>：对图片进行随机裁剪。这是一种数据增强操作 * <code>ToTensor</code>：把numpy格式图片转为torch格式图片 (我们需要交换坐标轴).</p><p>我们会把它们写成可调用的类的形式而不是简单的函数，这样就不需要每次调用时传递一遍参数。我们只需要实现<code>__call__</code>方法，必 要的时候实现 <code>__init__</code>方法。我们可以这样调用这些转换:</p><pre><code class="lang-python">tsfm = Transform(params)transformed_sample = tsfm(sample)</code></pre><pre><code class="lang-python">class Rescale(object):    &quot;&quot;&quot;将样本中的图像重新缩放到给定大小。.    Args:        output_size（tuple或int）：所需的输出大小。 如果是元组，则输出为         与output_size匹配。 如果是int，则匹配较小的图像边缘到output_size保持纵横比相同。    &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        self.output_size = output_size    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w = image.shape[:2]        if isinstance(self.output_size, int):            if h &gt; w:                new_h, new_w = self.output_size * h / w, self.output_size            else:                new_h, new_w = self.output_size, self.output_size * w / h        else:            new_h, new_w = self.output_size        new_h, new_w = int(new_h), int(new_w)        img = transform.resize(image, (new_h, new_w))        # h and w are swapped for landmarks because for images,        # x and y axes are axis 1 and 0 respectively        landmarks = landmarks * [new_w / w, new_h / h]        return {&#39;image&#39;: img, &#39;landmarks&#39;: landmarks}class RandomCrop(object):    &quot;&quot;&quot;随机裁剪样本中的图像.    Args:       output_size（tuple或int）：所需的输出大小。 如果是int，方形裁剪是。             &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        if isinstance(output_size, int):            self.output_size = (output_size, output_size)        else:            assert len(output_size) == 2            self.output_size = output_size    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w = image.shape[:2]        new_h, new_w = self.output_size        top = np.random.randint(0, h - new_h)        left = np.random.randint(0, w - new_w)        image = image[top: top + new_h,                      left: left + new_w]        landmarks = landmarks - [left, top]        return {&#39;image&#39;: image, &#39;landmarks&#39;: landmarks}class ToTensor(object):    &quot;&quot;&quot;将样本中的ndarrays转换为Tensors.&quot;&quot;&quot;    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        # 交换颜色轴因为        # numpy包的图片是: H * W * C        # torch包的图片是: C * H * W        image = image.transpose((2, 0, 1))        return {&#39;image&#39;: torch.from_numpy(image),                &#39;landmarks&#39;: torch.from_numpy(landmarks)}</code></pre><p>可以调用一个简单的类 <code>torchvision.transforms.Compose</code>来实现组合变换。</p><pre><code class="lang-python">scale = Rescale(256)crop = RandomCrop(128)composed = transforms.Compose([Rescale(256),                               RandomCrop(224)])</code></pre><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p><code>torch.utils.data.DataLoader</code>是一个提供上述所有这些功能的迭代器。下面使用的参数必须是清楚的。一个值得关注的参数是<code>collate_fn</code>, 可以通过它来决定如何对数据进行批处理。但是绝大多数情况下默认值就能运行良好。</p><pre><code class="lang-python"># Windows下num_workers值取0不会报错，取其他值可能出现多线程bugdataloader = DataLoader(transformed_dataset, batch_size=4,                        shuffle=True, num_workers=4)</code></pre><h1 id="TensorFlow-和-PyTorch"><a href="#TensorFlow-和-PyTorch" class="headerlink" title="TensorFlow 和 PyTorch"></a>TensorFlow 和 PyTorch</h1><p>PyTorch自动求导看起来非常像TensorFlow：这两个框架中，我们都定义计算图，使用自动微分来计算梯度。两者最大的不同就是TensorFlow的计算图是静态的，而PyTorch使用动态的计算图。</p><p>在TensorFlow中，我们定义计算图一次，然后重复执行这个相同的图，可能会提供不同的输入数据。而在PyTorch中，每一个前向通道定义一个新的计算图。</p><p>静态图的好处在于你可以预先对图进行优化。例如，一个框架可能要融合一些图的运算来提升效率，或者产生一个策略来将图分布到多个GPU或机器上。如果重复使用相同的图，那么在重复运行同一个图时，，前期潜在的代价高昂的预先优化的消耗就会被分摊开。</p><p>在TensorFlow中，更新权重值的行为是计算图的一部分; 但在PyTorch中，这发生在计算图形之外。</p><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p>实际中，基本没有人会从零开始（随机初始化）训练一个完整的卷积网络，因为相对于网络，很难得到一个足够大的数据集[网络很深, 需要足够大数据集]。通常的做法是在一个很大的数据集上进行预训练得到卷积网络ConvNet, 然后将这个ConvNet的参数作为目标任务的初始化参数或者固定这些参数。</p><p>转移学习的两个主要场景：</p><ul><li>微调<strong>Convnet</strong>：使用预训练的网络(如在<code>imagenet 1000</code>上训练而来的网络)来初始化自己的网络，而不是随机初始化。其他的训练步骤不变。</li><li>将<strong>Convnet</strong>看成固定的特征提取器:首先固定ConvNet除了最后的全连接层外的其他所有层。最后的全连接层被替换成一个新的随机 初始化的层，只有这个新的层会被训练[只有这层参数会在反向传播时更新]。</li></ul><h2 id="微调Torchvision"><a href="#微调Torchvision" class="headerlink" title="微调Torchvision"></a>微调Torchvision</h2><p><a href="http://pytorch123.com/FourSection/FinetuningTorchVisionModel/" target="_blank" rel="noopener">原文</a>，整理成<code>.py</code>后运行会报错，需要把主程序放入<code>if __name__ == &#39;__main__&#39;:</code>下，或者将<code>num_workers</code>置为0。似乎是一个多进程处理的bug，即使修改，在PyCharm下运行完会进入死循环。</p><pre><code class="lang-python">#!/usr/bin/env python# coding: utf-8from __future__ import print_functionfrom __future__ import divisionimport torchimport torch.nn as nnimport torch.optim as optimimport numpy as npimport torchvisionfrom torchvision import datasets, models, transformsimport matplotlib.pyplot as pltimport timeimport osimport copydef train_model(model, dataloaders, criterion, optimizer, num_epochs=25, is_inception=False):     since = time.time()    val_acc_history = []    best_model_wts = copy.deepcopy(model.state_dict())    best_acc = 0.0    for epoch in range(num_epochs):        print(&#39;Epoch {}/{}&#39;.format(epoch, num_epochs - 1))        print(&#39;-&#39; * 10)        # 每个epoch都有一个训练和验证阶段        for phase in [&#39;train&#39;, &#39;val&#39;]:            if phase == &#39;train&#39;:                model.train()  # Set model to training mode            else:                model.eval()   # Set model to evaluate mode            running_loss = 0.0            running_corrects = 0            # 迭代数据            for inputs, labels in dataloaders[phase]:                inputs = inputs.to(device)                labels = labels.to(device)                # 零参数梯度                optimizer.zero_grad()                # 前向                # 如果只在训练时则跟踪轨迹                with torch.set_grad_enabled(phase == &#39;train&#39;):                    # 获取模型输出并计算损失                    # 开始的特殊情况，因为在训练中它有一个辅助输出。                    # 在训练模式下，我们通过将最终输出和辅助输出相加来计算损耗                    # 但在测试中我们只考虑最终输出。                    if is_inception and phase == &#39;train&#39;:                        # From https://discuss.pytorch.org/t/how-to-optimize-inception-model-with-auxiliary-classifiers/7958                        outputs, aux_outputs = model(inputs)                        loss1 = criterion(outputs, labels)                        loss2 = criterion(aux_outputs, labels)                        loss = loss1 + 0.4*loss2                    else:                        outputs = model(inputs)                        loss = criterion(outputs, labels)                    _, preds = torch.max(outputs, 1)                    # backward + optimize only if in training phase                    if phase == &#39;train&#39;:                        loss.backward()                        optimizer.step()                # 统计                running_loss += loss.item() * inputs.size(0)                running_corrects += torch.sum(preds == labels.data)            epoch_loss = running_loss / len(dataloaders[phase].dataset)            epoch_acc = running_corrects.double() / len(dataloaders[phase].dataset)            print(&#39;{} Loss: {:.4f} Acc: {:.4f}&#39;.format(phase, epoch_loss, epoch_acc))            # deep copy the model            if phase == &#39;val&#39; and epoch_acc &gt; best_acc:                best_acc = epoch_acc                best_model_wts = copy.deepcopy(model.state_dict())            if phase == &#39;val&#39;:                val_acc_history.append(epoch_acc)        print()    time_elapsed = time.time() - since    print(&#39;Training complete in {:.0f}m {:.0f}s&#39;.format(time_elapsed // 60, time_elapsed % 60))    print(&#39;Best val Acc: {:4f}&#39;.format(best_acc))    # load best model weights    model.load_state_dict(best_model_wts)    return model, val_acc_historydef set_parameter_requires_grad(model, feature_extracting):    if feature_extracting:        for param in model.parameters():            param.requires_grad = Falsedef initialize_model(model_name, num_classes, feature_extract, use_pretrained=True):    # 初始化将在此if语句中设置的这些变量。     # 每个变量都是模型特定的。    model_ft = None    input_size = 0    if model_name == &quot;resnet&quot;:        &quot;&quot;&quot; Resnet18 &quot;&quot;&quot;        model_ft = models.resnet18(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.fc.in_features        model_ft.fc = nn.Linear(num_ftrs, num_classes)        input_size = 224    elif model_name == &quot;alexnet&quot;:        &quot;&quot;&quot; Alexnet &quot;&quot;&quot;        model_ft = models.alexnet(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier[6].in_features        model_ft.classifier[6] = nn.Linear(num_ftrs,num_classes)        input_size = 224    elif model_name == &quot;vgg&quot;:        &quot;&quot;&quot; VGG11_bn &quot;&quot;&quot;        model_ft = models.vgg11_bn(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier[6].in_features        model_ft.classifier[6] = nn.Linear(num_ftrs,num_classes)        input_size = 224    elif model_name == &quot;squeezenet&quot;:        &quot;&quot;&quot; Squeezenet &quot;&quot;&quot;        model_ft = models.squeezenet1_0(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        model_ft.classifier[1] = nn.Conv2d(512, num_classes, kernel_size=(1,1), stride=(1,1))        model_ft.num_classes = num_classes        input_size = 224    elif model_name == &quot;densenet&quot;:        &quot;&quot;&quot; Densenet &quot;&quot;&quot;        model_ft = models.densenet121(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier.in_features        model_ft.classifier = nn.Linear(num_ftrs, num_classes)        input_size = 224    elif model_name == &quot;inception&quot;:        &quot;&quot;&quot; Inception v3 Be careful, expects (299,299) sized images and has auxiliary output &quot;&quot;&quot;        model_ft = models.inception_v3(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        # 处理辅助网络        num_ftrs = model_ft.AuxLogits.fc.in_features        model_ft.AuxLogits.fc = nn.Linear(num_ftrs, num_classes)        # 处理主要网络        num_ftrs = model_ft.fc.in_features        model_ft.fc = nn.Linear(num_ftrs,num_classes)        input_size = 299    else:        print(&quot;Invalid model name, exiting...&quot;)        exit()    return model_ft, input_sizeif __name__ == &#39;__main__&#39;:    # 顶级数据目录。 这里我们假设目录的格式符合ImageFolder结构    data_dir = &quot;./hymenoptera_data&quot;    # 从[resnet, alexnet, vgg, squeezenet, densenet, inception]中选择模型    model_name = &quot;squeezenet&quot;    # 数据集中类别数量    num_classes = 2    # 训练的批量大小（根据您的内存量而变化）    batch_size = 8    # 你要训练的epoch数    num_epochs = 15    # 用于特征提取的标志。 当为False时，我们微调整个模型，    # 当True时我们只更新重新形成的图层参数    feature_extract = True    # 在这步中初始化模型    model_ft, input_size = initialize_model(model_name, num_classes, feature_extract, use_pretrained=True)    # 打印我们刚刚实例化的模型    print(&#39;model_ft&#39;)    # 数据扩充和训练规范化    # 只需验证标准化    data_transforms = {        &#39;train&#39;: transforms.Compose([            transforms.RandomResizedCrop(input_size),            transforms.RandomHorizontalFlip(),            transforms.ToTensor(),            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])        ]),        &#39;val&#39;: transforms.Compose([            transforms.Resize(input_size),            transforms.CenterCrop(input_size),            transforms.ToTensor(),            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])        ]),    }    print(&quot;Initializing Datasets and Dataloaders...&quot;)    # 创建训练和验证数据集    image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x]) for x in [&#39;train&#39;, &#39;val&#39;]}    # 创建训练和验证数据加载器    dataloaders_dict = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size, shuffle=True, num_workers=0) for x in [&#39;train&#39;, &#39;val&#39;]}    # 检测我们是否有可用的GPU    device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)    # 将模型发送到GPU    model_ft = model_ft.to(device)    # 在此运行中收集要优化/更新的参数。    # 如果我们正在进行微调，我们将更新所有参数。    # 但如果我们正在进行特征提取方法，我们只会更新刚刚初始化的参数，即`requires_grad`的参数为True。    params_to_update = model_ft.parameters()    print(&quot;Params to learn:&quot;)    if feature_extract:        params_to_update = []        for name,param in model_ft.named_parameters():            if param.requires_grad == True:                params_to_update.append(param)                print(&quot;\t&quot;,name)    else:        for name,param in model_ft.named_parameters():            if param.requires_grad == True:                print(&quot;\t&quot;,name)    # 观察所有参数都在优化    optimizer_ft = optim.SGD(params_to_update, lr=0.001, momentum=0.9)    # 设置损失函数    criterion = nn.CrossEntropyLoss()    # Train and evaluate    model_ft, hist = train_model(model_ft, dataloaders_dict, criterion, optimizer_ft, num_epochs=num_epochs, is_inception=(model_name==&quot;inception&quot;))</code></pre><h1 id="保存与加载模型"><a href="#保存与加载模型" class="headerlink" title="保存与加载模型"></a>保存与加载模型</h1><p>当保存和加载模型时，需要熟悉三个核心功能：</p><ol><li><code>torch.save</code>：将序列化对象保存到磁盘。此函数使用Python的<code>pickle</code>模块进行序列化。使用此函数可以保存如模型、tensor、字典等各种对象。</li><li><code>torch.load</code>：使用pickle的<code>unpickling</code>功能将pickle对象文件反序列化到内存。此功能还可以有助于设备加载数据。</li><li><code>torch.nn.Module.load_state_dict</code>：使用反序列化函数 state_dict 来加载模型的参数字典。</li></ol><h2 id="状态字典-state-dict"><a href="#状态字典-state-dict" class="headerlink" title="状态字典(state_dict)"></a>状态字典(state_dict)</h2><p>在PyTorch中，<code>torch.nn.Module</code>模型的可学习参数（即权重和偏差）包含在模型的参数中，（使用<code>model.parameters()</code>可以进行访问）。 <code>state_dict</code>是Python字典对象，它将每一层映射到其参数张量。注意，只有具有可学习参数的层（如卷积层，线性层等）的模型 才具有<code>state_dict</code>这一项。目标优化<code>torch.optim</code>也有<code>state_dict</code>属性，它包含有关优化器的状态信息，以及使用的超参数。</p><p>因为state_dict的对象是Python字典，所以它们可以很容易的保存、更新、修改和恢复，为PyTorch模型和优化器添加了大量模块。</p><h2 id="保存和加载推理模型"><a href="#保存和加载推理模型" class="headerlink" title="保存和加载推理模型"></a>保存和加载推理模型</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save(model.state_dict(), PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.eval()</code></pre><p>当保存好模型用来推断的时候，只需要保存模型学习到的参数，使用<code>torch.save()</code>函数来保存模型<code>state_dict</code>，在 PyTorch 中最常见的模型保存使‘.pt’或者是‘.pth’作为模型文件扩展名。</p><p>请记住在运行<code>evaluation</code>之前，务必调用<code>model.eval()</code>去设置 dropout 和 batch normalization 为评估。如果不这样做，有可能得到不一致的<code>evaluation</code>结果。 如果你想要恢复训练，请调用<code>model.train()</code>以确保这些层处于训练模式。</p><ul><li>注意</li></ul><p><code>load_state_dict()</code>函数只接受字典对象，而不是保存对象的路径。这就意味着在你传给<code>load_state_dict()</code>函数之前，你必须反序列化 你保存的<code>state_dict</code>。例如，你无法通过 <code>model.load_state_dict(PATH)</code>来加载模型。</p><h2 id="保存和加载-Checkpoint-用于推理-继续训练"><a href="#保存和加载-Checkpoint-用于推理-继续训练" class="headerlink" title="保存和加载 Checkpoint 用于推理/继续训练"></a>保存和加载 Checkpoint 用于推理/继续训练</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save({            &#39;epoch&#39;: epoch,            &#39;model_state_dict&#39;: model.state_dict(),            &#39;optimizer_state_dict&#39;: optimizer.state_dict(),            &#39;loss&#39;: loss,            ...            }, PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">model = TheModelClass(*args, **kwargs)optimizer = TheOptimizerClass(*args, **kwargs)checkpoint = torch.load(PATH)model.load_state_dict(checkpoint[&#39;model_state_dict&#39;])optimizer.load_state_dict(checkpoint[&#39;optimizer_state_dict&#39;])epoch = checkpoint[&#39;epoch&#39;]loss = checkpoint[&#39;loss&#39;]model.eval()# - or -model.train()</code></pre><p>当保存成 Checkpoint 的时候，可用于推理或者是继续训练，保存的不仅仅是模型的 state_dict 。保存优化器的 state_dict 也很重要, 因为它包含作为模型训练更新的缓冲区和参数。你也许想保存其他项目，比如最新记录的训练损失，外部的<code>torch.nn.Embedding</code>层等等。</p><p>要保存多个组件，请在字典中组织它们并使用<code>torch.save()</code>来序列化字典。PyTorch 中常见的保存checkpoint 是使用 .tar 文件扩展名。</p><p>要加载项目，首先需要初始化模型和优化器，然后使用<code>torch.load()</code>来加载本地字典。这里,你可以非常容易的通过简单查询字典来访问你所保存的项目。</p><h2 id="在一个文件中保存多个模型"><a href="#在一个文件中保存多个模型" class="headerlink" title="在一个文件中保存多个模型"></a>在一个文件中保存多个模型</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save({            &#39;modelA_state_dict&#39;: modelA.state_dict(),            &#39;modelB_state_dict&#39;: modelB.state_dict(),            &#39;optimizerA_state_dict&#39;: optimizerA.state_dict(),            &#39;optimizerB_state_dict&#39;: optimizerB.state_dict(),            ...            }, PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">modelA = TheModelAClass(*args, **kwargs)modelB = TheModelBClass(*args, **kwargs)optimizerA = TheOptimizerAClass(*args, **kwargs)optimizerB = TheOptimizerBClass(*args, **kwargs)checkpoint = torch.load(PATH)modelA.load_state_dict(checkpoint[&#39;modelA_state_dict&#39;])modelB.load_state_dict(checkpoint[&#39;modelB_state_dict&#39;])optimizerA.load_state_dict(checkpoint[&#39;optimizerA_state_dict&#39;])optimizerB.load_state_dict(checkpoint[&#39;optimizerB_state_dict&#39;])modelA.eval()modelB.eval()# - or -modelA.train()modelB.train()</code></pre><p>当保存一个模型由多个<code>torch.nn.Modules</code>组成时，例如GAN(对抗生成网络)、sequence-to-sequence (序列到序列模型), 或者是多个模 型融合, 可以采用与保存常规检查点相同的方法。换句话说，保存每个模型的 state_dict 的字典和相对应的优化器。如前所述，可以通 过简单地将它们附加到字典的方式来保存任何其他项目，这样有助于恢复训练。</p><p>PyTorch 中常见的保存 checkpoint 是使用 .tar 文件扩展名。</p><p>要加载项目，首先需要初始化模型和优化器，然后使用<code>torch.load()</code>来加载本地字典。这里，你可以非常容易的通过简单查询字典来访问你所保存的项目。</p><h2 id="使用在不同模型参数下的热启动模式"><a href="#使用在不同模型参数下的热启动模式" class="headerlink" title="使用在不同模型参数下的热启动模式"></a>使用在不同模型参数下的热启动模式</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save(modelA.state_dict(), PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">modelB = TheModelBClass(*args, **kwargs)modelB.load_state_dict(torch.load(PATH), strict=False)</code></pre><p>在迁移学习或训练新的复杂模型时，部分加载模型或加载部分模型是常见的情况。利用训练好的参数，有助于热启动训练过程，并希望帮助你的模型比从头开始训练能够更快地收敛。</p><p>无论是从缺少某些键的 state_dict 加载还是从键的数目多于加载模型的 state_dict , 都可以通过在<code>load_state_dict()</code>函数中将<code>strict</code>参数设置为 False 来忽略非匹配键的函数。</p><p>如果要将参数从一个层加载到另一个层，但是某些键不匹配，主要修改正在加载的 state_dict 中的参数键的名称以匹配要在加载到模型中的键即可。</p><h2 id="通过设备保存-加载模型"><a href="#通过设备保存-加载模型" class="headerlink" title="通过设备保存/加载模型"></a>通过设备保存/加载模型</h2><h3 id="Save-on-GPU-Load-on-CPU"><a href="#Save-on-GPU-Load-on-CPU" class="headerlink" title="Save on GPU, Load on CPU"></a>Save on GPU, Load on CPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&#39;cpu&#39;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH, map_location=device))</code></pre><h3 id="Save-on-GPU-Load-on-GPU"><a href="#Save-on-GPU-Load-on-GPU" class="headerlink" title="Save on GPU, Load on GPU"></a>Save on GPU, Load on GPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&quot;cuda&quot;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.to(device)# Make sure to call input = input.to(device) on any input tensors that you feed to the model</code></pre><p>当在GPU上训练并把模型保存在GPU，只需要使用<code>model.to(torch.device(&#39;cuda&#39;))</code>，将初始化的 model 转换为 CUDA 优化模型。另外，请 务必在所有模型输入上使用<code>.to(torch.device(&#39;cuda&#39;))</code>函数来为模型准备数据。请注意，调用<code>my_tensor.to(device)</code>会在GPU上返回<code>my_tensor</code>的副本。 因此，请记住手动覆盖张量：<code>my_tensor= my_tensor.to(torch.device(&#39;cuda&#39;))</code>。</p><h3 id="Save-on-CPU-Load-on-GPU"><a href="#Save-on-CPU-Load-on-GPU" class="headerlink" title="Save on CPU, Load on GPU"></a>Save on CPU, Load on GPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&quot;cuda&quot;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH, map_location=&quot;cuda:0&quot;))  # Choose whatever GPU device number you wantmodel.to(device)# Make sure to call input = input.to(device) on any input tensors that you feed to the model</code></pre><p>在CPU上训练好并保存的模型加载到GPU时，将<code>torch.load()</code>函数中的<code>map_location</code>参数设置为<code>cuda:device_id</code>。这会将模型加载到 指定的GPU设备。接下来，请务必调用<code>model.to(torch.device(&#39;cuda&#39;))</code>将模型的参数张量转换为 CUDA 张量。最后，确保在所有模型输入上使用 <code>.to(torch.device(&#39;cuda&#39;))</code>函数来为CUDA优化模型。请注意，调用<code>my_tensor.to(device)</code>会在GPU上返回<code>my_tensor</code>的新副本。它不会覆盖<code>my_tensor</code>。 因此， 请手动覆盖张量<code>my_tensor = my_tensor.to(torch.device(&#39;cuda&#39;))</code>。</p><h3 id="Saving-torch-nn-DataParallel-Models"><a href="#Saving-torch-nn-DataParallel-Models" class="headerlink" title="Saving torch.nn.DataParallel Models"></a>Saving <code>torch.nn.DataParallel</code> Models</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.module.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code># Load to whatever device you want</code></pre><p><code>torch.nn.DataParallel</code>是一个模型封装，支持并行GPU使用。要普通保存 DataParallel 模型, 请保存<code>model.module.state_dict()</code>。 这样，你就可以非常灵活地以任何方式加载模型到你想要的设备中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://pytorch123.com/" target="_blank" rel="noopener">http://pytorch123.com/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编程基础</title>
    <link href="/2020/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>总结一些计算机基础知识</p><a id="more"></a><h1 id="储存单位"><a href="#储存单位" class="headerlink" title="储存单位"></a>储存单位</h1><ul><li><strong>位(bit)</strong>：数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。计算机中的CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一个机器周期内可以处理32位二进制数据的计算机。</li><li><strong>字节(byte)</strong>：是8个二进制数，即8 bit 就称为一个字节（Byte）。字节这个词最早起源于1956年前后，由IBM公司提出。最早的拼写方式是bite，但是为了避免与bit混淆用y代替了i。</li><li><strong>字(word)</strong>：字由若干字节构成，字的位数叫字长，一台8位机子：一个字等于1个字节，字长为8位，如果是16位的机子，一个字等于2个字节，字长为16，字是计算机处理数据和运算的单位。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">位</th><th style="text-align:left">范围</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">-128 到 127 或者 0 到 255</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">0 到 255</td></tr><tr><td style="text-align:left">signed char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">-128 到 127</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">-2147483648 到 2147483647</td></tr><tr><td style="text-align:left">unsigned int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">0 到 4294967295</td></tr><tr><td style="text-align:left">signed int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">-2147483648 到 2147483647</td></tr><tr><td style="text-align:left">short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">-32768 到 32767</td></tr><tr><td style="text-align:left">unsigned short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">0 到 65,535</td></tr><tr><td style="text-align:left">signed short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">-32768 到 32767</td></tr><tr><td style="text-align:left">long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left">signed long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left">unsigned long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">0 到 18,446,744,073,709,551,615</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">4 个字节</td><td style="text-align:left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8 个字节</td><td style="text-align:left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td style="text-align:left">long double</td><td style="text-align:left">16 个字节</td><td style="text-align:left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td style="text-align:left">wchar_t</td><td style="text-align:left">2 或 4 个字节</td><td style="text-align:left">1 个宽字符</td></tr></tbody></table></div><p><strong>注意：</strong>不同系统会有所差异。</p><h1 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h1><p>我们知道现在计算机普遍使用二进制来表示，这是因为二进制能够工作的更好。对于二进制数来说，单独的讲某一个位没有太多的意义，但是可以将多个位组合起来，再加上某种解释，就可以用来表示我们日常生活中常用的数字。 计算机中常用表示的数又分为<strong>有符号数</strong>、<strong>无符号数</strong>和<strong>浮点数</strong>。</p><p><img src="20180503165002430.png" srcset="/img/loading.gif" alt="image1"></p><h2 id="无符号"><a href="#无符号" class="headerlink" title="无符号"></a>无符号</h2><p>无符号表示大于或者等于0的数字，是基于传统的二进制表示法进行编码。无符号的二进制数表示一个很重要的特性，也就是对于任何介于0~2^w-1 之间的数值都有一个唯一w为的值编码。</p><h2 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h2><p>有符号数表示可以为正或者为负的数字，通常采用<strong>补码</strong>进行编码。 负数是有符号的数值,对于负数来说，我们最难的就是如何表示它的负号.先来看看什么是<strong>原码</strong>、<strong>补码</strong>、<strong>反码</strong>。</p><p><strong>原码</strong></p><p>原码是计算机中数字的二进制定点表示法。数码序列中最高位表示符号位，符号0表示正数，符号1表示负数，其余位表示数值的大小。</p><p>这样我们使用一个符号位的引用就可以表示正数、负数。对于一个8位二进制数来说，能够表示的范围就是-127(1111 1111)~127(0111 1111)。 但对于原码表示有一个致命的缺点，就是不能参加运算。例如：-1(1000 0001) + 1(0000 0001) = 0(1000 0010) 这个二进制数的实际数值是-2.这显然不对。</p><p><strong>反码</strong></p><p>正数的反码就是它本身。</p><p>负数的反码是在原码的基础上，符号位不变，数值位按位取反。</p><p>这样对于上述-1+1等于-2的问题就解决了。0001 + 1110(-1的反码) = 1111(反码) 转换到对应的数为-0. 但这又带来了一个问题.即0这个数有两种表示法+0和-0。</p><p><strong>补码</strong></p><p>正数的补码是其原码本身。</p><p>负数的补码是在其反码基础上再加1。</p><p>例如：</p><p>【+7】补码 = 0000 0111</p><p>【-7】 补码 = 1111 1001</p><p>我们使用补码来计算时，如果丢弃最高位对的进位，正负相加的确是为0的。而11111111表示的数字是-128，不再是-0。</p><p>至此，我们可以使用补码来表示我们生活中常用的正数、负数；当然，这是我们丢弃了最高位的代价来换取的。</p><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>小数点为定点，用来表示小数的，采用的是BCD码来编码。BCD码将0~9中的每个数用4位二进制数来表示，这样对于32位就可以表示8个数字，表示的数字范围也就是0~999999.99之间的1亿个实数。</p><p>BCD编码也有很多用途，比如银行、超市这种需要用到小数记金额的情况就很合适，但是如果表示很小、或者很大的数就不是很合适了，比如地球到太阳的距离，一个氢原子的半径等等。而且这样编码非常浪费，对于32位整数我们可以表示将近40亿个数字，而BCD编码的数字只能表示1亿个数字。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>IEEE754标准规定，浮点数由“符号”、“指数”和“尾数”3部分构成，float的规格化表示为：<script type="math/tex">±1.*f*×2^{*E*−127}</script><br> ，其中，<em>f</em>是尾数，<em>E</em>是指数。以float为例：<br><img src="20180716165243972.png" srcset="/img/loading.gif" alt="image2"></p><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>srand函数是随机数发生器的初始化函数。</p><pre><code class="lang-c++">void srand(unsigned seed)</code></pre><p><code>srand()</code>需要提供一个种子，这个种子会对应一个随机数，如果使用相同的种子后面的rand()函数会出现一样的随机数。如：<code>srand(1)</code>，直接使用 1 来初始化种子。不过为了防止随机数每次重复，常常使用系统时间来初始化，即使用 time 函数来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数，然后将 time_t 型数据转化为(unsigned)型再传给 srand 函数，即： srand((unsigned) time(&amp;t)); 还有一个经常用法，不需要定义time_t型t变量，即： srand((unsigned) time(NULL))；直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的t数据。</p><pre><code class="lang-c++">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt; /*用到了time函数，所以要有这个头文件*/#define MAX 10int main(void){    int number[MAX] = { 0 };    int i;    srand((unsigned)time(NULL)); /*播种子*/    for (i = 0; i &lt; MAX; i++)    {        number[i] = rand() % 100; /*产生100以内的随机整数*/        printf(&quot;%d &quot;, number[i]);    }    printf(&quot;\n&quot;);    return 0;}</code></pre><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><div class="table-container"><table><thead><tr><th style="text-align:left">转义序列</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">\</td><td style="text-align:left">\ 字符</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">‘ 字符</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“ 字符</td></tr><tr><td style="text-align:left">\?</td><td style="text-align:left">? 字符</td></tr><tr><td style="text-align:left">\a</td><td style="text-align:left">警报铃声</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格键</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行符</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平制表符</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">一到三位的八进制数</td></tr><tr><td style="text-align:left">\xhh . . .</td><td style="text-align:left">一个或多个数字的十六进制数</td></tr></tbody></table></div><h1 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h1><p>在 C++ 中，有两种简单的定义常量的方式：</p><ul><li><p>使用 <strong>#define</strong> 预处理器。</p><pre><code class="lang-c++">#define identifier value</code></pre></li><li><p>使用 <strong>const</strong> 关键字。</p><pre><code class="lang-c++">const type variable = value;</code></pre></li></ul><h1 id="Struct和Class"><a href="#Struct和Class" class="headerlink" title="Struct和Class"></a>Struct和Class</h1><p>C++ 中关键字<code>struct</code>和<code>class</code>都是用来定义类的，二者除了默认访问限定符不同，结构体（包括共用体）默认成员为public，而类默认成员是private型的。其他所有方面都一样。</p><p>数组里的对象，不论是类对象（struct或者class），还是基础数据类型，如果没有给初始化列表，一律执行<strong>值初始化</strong>，即基础数据类型都初始化为0，类对象执行<strong>默认构造函数</strong>（即不接受任何参数的构造函数）。如果struct里面自己定义了一个构造函数，那么编译器不会隐式地声明一个默认构造函数。</p><h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/return9/article/details/79888603" target="_blank" rel="noopener">https://blog.csdn.net/return9/article/details/79888603</a></li><li><a href="https://blog.csdn.net/chihujiang3132/article/details/100930007" target="_blank" rel="noopener">https://blog.csdn.net/chihujiang3132/article/details/100930007</a></li><li><a href="https://blog.csdn.net/whyel/article/details/81067989" target="_blank" rel="noopener">https://blog.csdn.net/whyel/article/details/81067989</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查并集(Union-find algorithm)</title>
    <link href="/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/"/>
    <url>/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</url>
    
    <content type="html"><![CDATA[<p>查并集的进化之路</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p><ul><li>查找（Find）：确定某个元素处于哪个子集；</li><li>合并（Union）：将两个子集合并成一个集合。</li></ul><p>也就是说，不支持集合的分离、删除。</p><h1 id="Quick-Find算法"><a href="#Quick-Find算法" class="headerlink" title="Quick-Find算法"></a>Quick-Find算法</h1><p>以下图为例，连通关系为<code>[(1,2), (0, 1), (0, 3), (4, 7), (5, 6), (5, 7), (7, 8), (8, 9)]</code>。</p><p><img src="uf1.png" srcset="/img/loading.gif" alt="uf"></p><p>首先初始化所有节点，认为它们属于一个组，因此不连通的节点必然就属于不同的组：</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>输入pair<code>(1, 2)</code>，则将<strong>所有</strong><code>group number</code>为<code>0</code>和<code>1</code>的<code>element</code>改为一致（都为<code>0</code>或都为<code>1</code>，这里以较小值为例）。</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td>1</td><td><strong>1</strong></td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>输入pair<code>(0， 1)</code>，这里就需要把<code>element 1</code>和<code>element 2</code>的<code>group number</code>都改为<code>0</code>，：</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td><strong>0</strong></td><td><strong>0</strong></td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>正因为每次都需要找到所有的特定<code>group number</code>的<code>element</code>，所以<code>union</code>的时间复杂度为O(N)，<code>find</code>的时间复杂度为O(1)。N为<code>element</code>的个数，下同。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickFind(object):    id = []    count = 0    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):            return self.id[p]    def union(self, p, q):        idp = self.find(p)        idq = self.find(q)        if idp != idq:            for i in range(len(self.id)):                if self.id[i] == idq: # 将q所在组内的所有节点的id都设为p的当前id                    self.id[i] = idp            self.count -= 1</code></pre><h1 id="Quick-Union算法"><a href="#Quick-Union算法" class="headerlink" title="Quick-Union算法"></a>Quick-Union算法</h1><p>对于只需要实现查找和合并的并查集，O(n)的时间复杂度还是太高了，当时间复杂度需要降低到对数级，我们自然想到了<strong>树</strong>这个数据结构。由于并查集初始化中每一个<code>element</code>对于一个<code>group number</code>，所以可以通过数组中的跳转来实现树的寻找父节点功能。以下图为例，最开始每一个<code>element</code>的父节点都是自身，每次查找沿着父节点向上， 直到根节点。每次合并把找到的两个根节点的其中一个设置为另一个的父节点。</p><p><img src="1339479431_6633.png" srcset="/img/loading.gif" alt="qu"></p><p><code>union</code>和<code>find</code>的时间复杂度取决于树的高度。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickUnion(object):    id = []    count = 0    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):            while (p != self.id[p]):            p = self.id[p]        return p    def union(self, p, q):        root_p = self.find(p)        root_q = self.find(q)        if root_p != root_q:            self.id[root_q] = root_p            self.count -= 1</code></pre><p><em>注意：此时<code>self.id</code>存放的不再是每个元素的组别而是父节点。</em></p><h1 id="Weighted-Quick-Union-算法"><a href="#Weighted-Quick-Union-算法" class="headerlink" title="Weighted Quick-Union 算法"></a>Weighted Quick-Union 算法</h1><p>既然采用了<strong>树</strong>的结构，就有可能出现极端情况，是的树操作的时间复杂度退化成O(N)。为了避免这种情况，常规方法是使用平衡树，而对于并查集，只需要在<code>union</code>时，选择将小的树合并到大树上就可以了。</p><p><img src="1339479587_5986.png" srcset="/img/loading.gif" alt="wqu"></p><p>理论上在平衡树合并两个树时，应当用根的高度来衡量两个树的大小，但是这里使用根节点的子孙节点的数量来衡量，<code>union</code>和<code>find</code>的时间复杂度接近于O(log  N)。这是因为这个方法还可以优化，通过路径压缩可以将<code>union</code>和<code>find</code>的时间复杂度降低至O(1)，而这样做会改变根的高度。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class WeightedQuickUnion(object):    id = []    count = 0    sz = []    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)            self.sz.append(1) # inital size of each tree is 1    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):           while (p != self.id[p]):            p = self.id[p]        return p    def union(self, p, q):        root_p = self.find(p)        root_q = self.find(q)        if root_p != root_q:            if self.sz[root_p] &lt; self.sz[root_q]:                self.id[root_p] = root_q                self.sz[root_q] += self.sz[root_p]            else:                self.id[root_q] = root_p                self.sz[root_p] += self.sz[root_q]                           self.count -=1</code></pre><p>输出<code>self.sz</code>可以看到<code>id = 1</code>和<code>id = 5</code>的组别包含了所有元素，<code>id = 4</code>组中的<code>(4, 7)</code>实际上已经移动到<code>id = 5</code>组中。</p><pre><code class="lang-python">size:  [1, 4, 1, 1, 2, 6, 1, 1, 1, 1]</code></pre><h1 id="Weighted-Quick-Union-With-Path-Compression-算法"><a href="#Weighted-Quick-Union-With-Path-Compression-算法" class="headerlink" title="Weighted Quick-Union With Path Compression 算法"></a>Weighted Quick-Union With Path Compression 算法</h1><p>第一种方法是在<code>find</code>方法的执行过程中保存所有路过的中间节点到一个数组中，然后在<code>while</code>循环结束之后，将这些中间节点的父节点指向根节点。但是这个方法在<code>find</code>操作很频繁时会频繁生成中间节点数组，相应的分配销毁的时间自然就上升了。另一种方法是在寻找<code>q</code>的根节点的同时不断改变父节点，相当于在寻找根节点的同时，不断地将<code>q</code>移动到上一级的节点下，对路径进行了压缩，使整个树结构扁平化。相应的实现如下，实际上只需要在<code>find</code>方法中添加一行代码。</p><pre><code class="lang-python">def find(self, p):           while (p != self.id[p]):            self.id[p] = self.id[self.id[p]]            p = self.id[p]        return p</code></pre><p>这样<code>self.id</code>中保存的既是个元素的组别又是各元素的父节点，正因为如此<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。</p><pre><code class="lang-python">final parent/id list is 1,1,1,1,5,5,5,5,5,5</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-leetcode-200-岛屿数量"><a href="#1-leetcode-200-岛屿数量" class="headerlink" title="1. leetcode 200. 岛屿数量"></a>1. <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode 200. 岛屿数量</a></h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><pre><code class="lang-python">输入:   1 1 1 1 0      ====&gt;     输出: 1          1 1 0 1 0              1 1 0 0 0        1 0 0 0 0</code></pre><p>简单应用<a href="https://lil-q.github.io/2020/01/02/查并集-union-find-algorithm/#Quick-Union算法">Quick-Union算法</a>即可，用<code>dict</code>代替<code>list</code>。</p><pre><code class="lang-python">class Solution:    def numIslands(self, grid: List[List[str]]) -&gt; int:        if not grid or not grid[0]:            return 0         row = len(grid)        col = len(grid[0])        def find(x):            f.setdefault(x, x)            while f[x] != x:                x = f[x]            return x        def union(x, y):            rootx = find(x)            rooty = find(y)            if rootx != rooty:                f[rootx] = rooty                return 1            return 0        s = 0        f = {}        for i in range(row):            for j in range(col):                if grid[i][j] == &#39;1&#39;:                    s += 1                    for x, y in ((1, 0), (0, 1)):                        tmp_i = i + x                        tmp_j = j + y                        if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &#39;1&#39;:                            # 如果需要合并那么总岛屿数就减一，不需要合并则不变（减零）                            s -= union((i, j), (tmp_i, tmp_j))        return s</code></pre><h2 id="2-leetcode-684-冗余连接"><a href="#2-leetcode-684-冗余连接" class="headerlink" title="2. leetcode 684. 冗余连接"></a>2. <a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">leetcode 684. 冗余连接</a></h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:  1 / \2 - 3</code></pre><p>遍历所有的边，<code>union</code>所有边的两个顶点，如果出现两个顶点已经连接的情况，说明已经构成换，删掉这条边即可。实现如下：</p><pre><code class="lang-python">class Solution:    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:        def find(x):            f.setdefault(x,x)            while x != f[x]:                f[x] = f[f[x]]                x = f[x]            return x        def union(x, y):            rootx = find(x)            rooty = find(y)            if rootx != rooty:                f[rootx] = rooty                return 1            return 0        f = {}        for x, y in edges:            if not union(x, y): return[x, y]</code></pre><h2 id="3-leetcode-685-冗余连接-II"><a href="#3-leetcode-685-冗余连接-II" class="headerlink" title="3. leetcode 685. 冗余连接 II"></a>3. <a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">leetcode 685. 冗余连接 II</a></h2><h2 id="4-leetcode-803-打砖块"><a href="#4-leetcode-803-打砖块" class="headerlink" title="4. leetcode 803. 打砖块"></a>4. <a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">leetcode 803. 打砖块</a></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着一步步地深入，我们最终将查并集<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。本文中的四种算法的时间复杂度如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>Algorithm</strong></th><th style="text-align:center"><strong>Constructor</strong></th><th style="text-align:center"><strong>Union</strong></th><th style="text-align:center"><strong>Find</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>Quick-Find</strong></td><td style="text-align:center">N</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center"><strong>Quick-Union</strong></td><td style="text-align:center">N</td><td style="text-align:center">Tree height</td><td style="text-align:center">Tree height</td></tr><tr><td style="text-align:center"><strong>Weighted Quick-Union</strong></td><td style="text-align:center">N</td><td style="text-align:center">near to O(log N)</td><td style="text-align:center">near to O(log N)</td></tr><tr><td style="text-align:center"><strong>Weighted Quick-Union With Path Compression</strong></td><td style="text-align:center">N</td><td style="text-align:center">Very near to O(1)</td><td style="text-align:center">Very near to O(1)</td></tr></tbody></table></div><p>需要注意<code>Path Compression</code>是将各节点压缩到根节点下，所以<code>Weighted</code>仍然有意义。当然如果还需要输出连通路径，这个方法是没办法实现的，需要BFS或DFS算法来实现。</p><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Union-Find" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/Guo15331092/article/details/78702686" target="_blank" rel="noopener">https://blog.csdn.net/Guo15331092/article/details/78702686</a></li><li><a href="https://www.jianshu.com/p/72da76a34db1" target="_blank" rel="noopener">https://www.jianshu.com/p/72da76a34db1</a></li><li><a href="https://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/7655764</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>查并集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图(graph)</title>
    <link href="/2019/12/27/%E5%9B%BE-graph/"/>
    <url>/2019/12/27/%E5%9B%BE-graph/</url>
    
    <content type="html"><![CDATA[<p>生活不就是一张图吗？</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>图</strong>(Graph)用于表示物件与物件之间的关系，是<a href="https://zh.wikipedia.org/wiki/圖論" target="_blank" rel="noopener">图论</a>的基本研究对象。一张图由一些小圆点（称为<strong>顶点</strong>或<strong>结点</strong>）和连结这些圆点的直线或曲线（称为<strong>边</strong>）组成。</p><p>一个图 $G$ 是一个二元组，即序偶 $\langle V,E\rangle$ ，或记作 $G= \langle V,E\rangle$ ，其中 $V$ 是有限非空集合，称为 $G$ 的顶点集， $V$ 中的元素称为顶点或结点； $E$ 称为 $G$ 的边的集合， $\forall e_i \in E$ ，都有 $V$ 中的结点与之对应，称 $e_i$ 为 $G$ 的边。</p><p>简单来说，就是图 $G$ 就是一个结点的集合 $V$ 和边的集合 $E$ ，其中任意一条边都可以表示为两个结点之间的关系。若 $e_i\in E$ 表示为 $\langle u,v\rangle$ ，则有 $u\in V , v\in V$ 。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>无向图：每条边都是无向边的图。</p><p>有向图：每条边都是有向边的图。</p><p>有权图：每条边具有一定的权重(weight)，通常是一个数字</p><p>无权图：每条边均没有权重，也可以理解为权为 1</p><p>连通图：所有的点都有路径相连</p><p>非连通图：存在某两个点没有路径相连</p><p>混合图：在一个图中，有些边是有向边，另一些边是无向边，则该图为混合图。</p><p>有限图：一个图的点集和边集都是有穷集的图。</p><p>零图：边集为空集的图。</p><p>平凡图：仅有一个结点而没有边构成的图。</p><p>关联：若有 $e_i=(u,v)$ 且 $e_i\in E$ ，则称 $u$ 是和 $v$ 相关联的。</p><p>孤立点：无边关联的点。</p><p>自环：若一条边所关联的两个结点重合，则称此边为自环。</p><p>邻接：关联于同一条边的两个点 $u$ 和 $v$ 称为邻接的；关联于同一个点的两条边 $e_1$ 和 $e_2$ 是邻接的（或相邻的）。</p><h2 id="结点的度数"><a href="#结点的度数" class="headerlink" title="结点的度数"></a>结点的度数</h2><p>设图 $G= \langle V,E\rangle$ 为一个有向图， $v\in V$ ，关联于结点 $v$ 的 <strong>边</strong> 的条数，称为点 $v$ 的度数，记作 $\deg(v)$ 。</p><p>注意：一个自环为它的端点增加 2 度。</p><p>当图 $G= \langle V,E\rangle$ 为一个有向图， $v\in V$ ，称以 $v$ 作为始点的边数之和称为结点 $v$ 的出度，记为 $\deg^{+} (v)$ 。将以 $v$ 作为终点的边数之和称为结点 $v$ 的入度，记为 $\deg^{-} (v)$ 。称以 $v$ 作为端点的边数之和为结点 $v$ 的度数或度，记为 $\deg(v)$ 。</p><p>显然， $\forall v\in V,\deg(v)=deg^{+} (v)+\deg^{-} (v)$ 。</p><h2 id="子图的概念"><a href="#子图的概念" class="headerlink" title="子图的概念"></a>子图的概念</h2><p>设有图 $G= \langle V,E\rangle$ 和图 $G’= \langle V’,E’\rangle$ 。</p><p>如果 $V’\subseteq V,E’\subseteq E$ ，则称 $G’$ 是 $G$ 的子图，记作 $G’\subseteq G$ 。</p><p>如果 $G’\subsetneqq G$ ，即 $V’\subset V$ 或 $E’\subset E$ ，则称 $G’$ 是 $G$ 的真子图，记作 $G’\subset G$ 。</p><p>如果 $V’=V,E’\subseteq E$ ，则称 $G’$ 是 $G$ 的生成子图。</p><p>如果 $V’’\subseteq V$ 且 $V’’ \neq \varnothing$ ，以 $V’’$ 为结点集，以两端点均在 $V’’$ 中的边为边集的 $G$ 的子图，称为 $V’’$ 导出的 $G$ 的子图，简称为 $V’’$ 的导出子图。</p><p>如果 $G’’= \langle V’’,E’’\rangle$ 使得 $E’’=E-E’$ ，且 $V’’$ 中仅包含 $E’’$ 中的边所关联的结点，则称 $G’’$ 是子图 $G’$ 相对于原图 $G$ 的补图。</p><h2 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h2><p>树：边数比结点数少一的连通图。更多内容，详见 树相关基础。</p><p>森林：由 $m$ 棵（ $m\ge 0$ ）互不相交的树组成的图。</p><p>基环树：边数和点数相等的连通图。</p><p>仙人掌：每条边至多属于一个简单环的无向连通图。</p><p>在无向图中，关联一对顶点的边多于 $1$ 条，则称这些边为重边（平行边），重边的条数称为重数。</p><p>简单图：不含重边和自环的图。</p><p>多重图：含重边的图。</p><p>完全图：每对不同的顶点之间都恰连有一条边相连的简单无向图。容易证明， $n$ 个顶点的完全图有 $\dfrac{n(n-1)}{2}$ 条边。</p><p>竞赛图：通过在完全图中为每条边分配方向而获得的有向图。</p><p><em>参考资料：离散数学（修订版），田文成 周禄新 编著，天津文学出版社，P184-187</em></p><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>以下图作为例子。</p><p><img src="21cd2731928c7c13057eee000e3697de82ccc058.png" srcset="/img/loading.gif" alt="edge lists"></p><h2 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h2><p>建立一个数组，数组里每个元素是图的一条边。</p><p>这样做有个缺点，每次想要知道两个点之间是否有连边（或者说一条边是否存在），都需要在数组里进行一番查找。而且如果没有对边事先排序的话，就不能使用二分查找的方法（ $O(\log n)$ ），而是每次只能按顺序找（ $O(n)$ ），成本较高。</p><p>什么时候会用到这个方法呢？最简单的一个例子是使用 Kruskal 算法求最小生成树的时候。</p><pre><code class="lang-python">[ [0,1], [0,6], [0,8], [1,4], [1,6], [1,9], [2,4], [2,6], [3,4], [3,5],[3,8], [4,5], [4,9], [7,8], [7,9] ]</code></pre><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵的英文名是 adjacency matrix。它的形式是 <code>bool adj[n][n]</code> ，这里面 $n$ 是节点个数， $adj[i][j]$ 表示 $i$ 和 $j$ 之间是否有边。</p><p>如果边有权值，也可以直接用 <code>int adj[n][n]</code> ，直接把边权存进去。</p><p>它的优点是可以在 $O(1)$ 时间内得到一条边是否存在，缺点是需要占用 $O(n^2)$ 的空间。对于一个稀疏的图（边相对于点数的平方比较少）来说，用邻接矩阵来存的话，成本偏高。</p><p><img src="549bca1a52774846b25caff86d244d03ee63fd38.png" srcset="/img/loading.gif" alt="matrix"></p><pre><code class="lang-python">[ [0, 1, 0, 0, 0, 0, 1, 0, 1, 0],  [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],  [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],  [0, 0, 0, 0, 1, 1, 0, 0, 1, 0],  [0, 1, 1, 1, 0, 1, 0, 0, 0, 1],  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],  [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1],  [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],  [0, 1, 0, 0, 1, 0, 0, 1, 0, 0] ]</code></pre><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表英文名是 adjacency list。它的形式是 <code>vector adj[n]</code> ，用 <code>adj[i]</code> 存以 $i$ 为起点的边。</p><p>用 <code>vector</code> 无法科学地删除，所以常用 <code>list</code> 实现。</p><p>它的特点是可以用来按顺序访问一个结点的出边（或者入边）。</p><p><img src="cc82379521bd84738e86d6cf9552738ca9138420.png" srcset="/img/loading.gif" alt="linklist"></p><pre><code class="lang-python">[ [1, 6, 8],  [0, 4, 6, 9],  [4, 6],  [4, 5, 8],  [1, 2, 3, 5, 9],  [3, 4],  [0, 1, 2],  [8, 9],  [0, 3, 7],  [1, 4, 7] ]</code></pre><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><strong>图的遍历</strong>问题分为四类：</p><ul><li>遍历完所有的<strong>边</strong>而不能有重复，即所谓“欧拉路径问题”（又名<a href="https://zh.wikipedia.org/wiki/一笔画问题" target="_blank" rel="noopener">一笔画问题</a>）；</li><li>遍历完所有的<strong>顶点</strong>而没有重复，即所谓“<a href="https://zh.wikipedia.org/wiki/哈密頓路徑問題" target="_blank" rel="noopener">哈密顿路径问题</a>”。</li><li>遍历完所有的<strong>边</strong>而可以有重复，即所谓“<a href="https://zh.wikipedia.org/wiki/中国邮递员问题" target="_blank" rel="noopener">中国邮递员问题</a>”；</li><li>遍历完所有的<strong>顶点</strong>而可以重复，即所谓“<a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">旅行推销员问题</a>”。</li></ul><p>对于第一和第三类问题已经得到了完满的解决，而第二和第四类问题则只得到了部分解决。</p><p>第一类问题就是研究所谓的<a href="https://zh.wikipedia.org/wiki/欧拉图" target="_blank" rel="noopener">欧拉图</a>的性质，而第二类问题则是研究所谓的<a href="https://zh.wikipedia.org/wiki/哈密顿图" target="_blank" rel="noopener">哈密顿图</a>的性质。</p><p>图的遍历方法有深度优先搜索法和广度(宽度)优先搜索法。以下图为例。</p><p><img src="graph1.png" srcset="/img/loading.gif" alt="graph"></p><p>建立邻接表：</p><pre><code class="lang-python">adjacencylists = [[1, 2, 3],                  [0, 4, 5],                  [0, 6],                  [0, 6],                  [1, 5],                  [1, 4, 6],                  [2, 3, 5]]</code></pre><h2 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索(Depth First Search, DFS)"></a>深度优先搜索(Depth First Search, DFS)</h2><p><strong>深度优先搜索算法</strong>(Depth-First-Search，DFS)是一种用于遍历或搜索<strong>树</strong>或<strong>图</strong>的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p><p><img src="graph2.png" srcset="/img/loading.gif" alt="graph2"></p><h2 id="广度优先搜索-Breadth-First-Search-BFS"><a href="#广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="广度优先搜索(Breadth First Search, BFS)"></a>广度优先搜索(Breadth First Search, BFS)</h2><p><strong>广度优先搜索算法</strong>(Breadth-First-Search，缩写为BFS)，又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种图形搜索算法。简单的说，BFS是从<strong>根节点](<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1)开始，沿着树的宽度遍历树的" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1)开始，沿着树的宽度遍历树的</a></strong>节点**。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。</p><p><img src="graph3.png" srcset="/img/loading.gif" alt="graph3"></p><h2 id="Python的简易实现"><a href="#Python的简易实现" class="headerlink" title="Python的简易实现"></a>Python的简易实现</h2><pre><code class="lang-python"># 设置总节点数num_vertexs = 7# 建立邻接表adjacencylists = [[1, 2, 3],                  [0, 4, 5],                  [0, 6],                  [0, 6],                  [1, 5],                  [1, 4, 6],                  [2, 3, 5]]class graph:    def __init__(self, num_vertexs, adjacencylists):        self.num_vertexs = num_vertexs        self.adjacencylists = adjacencylists    def dfs(self, start):        # 记录节点是否已经访问        visited = [False] * self.num_vertexs        res = []        def helper(v):                if visited[v]:                return            visited[v] = True            res.append(v)            for i in self.adjacencylists[v]:                helper(i)        helper(start)        return res    def bfs(self, start):        visited = [False] * self.num_vertexs        visited[start] = True        res = [start,]        queue = [start,]        while queue:            cur = queue.pop(0)            for i in self.adjacencylists[cur]:                if  not visited[i]:                    queue.append(i)                    visited[i] = True                    res.append(i)        return resif __name__ == &#39;__main__&#39;:        # 实例化    graph = graph(num_vertexs, adjacencylists)    t1 = graph.dfs(0)    print(&quot;深度优先搜索：&quot;, t1)    t2 = graph.bfs(0)    print(&quot;广度优先搜索：&quot;, t2)</code></pre><p>注意：这里用index表示节点名称，最后还需要映射出结果（假设0,1,2,3…分别对应A,B,C,D…下文会使用字典来实现邻接表，这样就不需要这一步了）：</p><pre><code class="lang-python">vertexs = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]t3 = list(map(lambda x: vertexs[x], t1))print(&quot;深度优先搜索：&quot;, t3)t4 = list(map(lambda x: vertexs[x], t2))print(&quot;广度优先搜索：&quot;, t4)</code></pre><p><img src="graph4.png" srcset="/img/loading.gif" alt="graph2"></p><p>输出：</p><pre><code class="lang-python">深度优先搜索： [0, 1, 4, 5, 6, 2, 3]广度优先搜索： [0, 1, 2, 3, 4, 5, 6]深度优先搜索： [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;C&#39;, &#39;D&#39;]广度优先搜索： [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</code></pre><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Dijkstra 算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。Dijkstra 算法属于单源算法，即只能求出某点到其它点最短距离，并不能得出任意两点之间的最短距离，只能用权值为正数的图，存在负数时可能回陷入死循环。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组distances来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：nodes。以下图为例，假设求A点到其他点的距离。</p><p><img src="graph5.png" srcset="/img/loading.gif" alt="graph2"></p><ol><li><p>初始化distances，原点 s 的路径权重被赋为 0 （dis[s] = 0）。把到其他顶点的路径长度设为无穷大。</p><pre><code class="lang-python">distances = {&#39;A&#39;: 0, &#39;B&#39;: inf, &#39;C&#39;: inf, &#39;D&#39;: inf, &#39;E&#39;: inf, &#39;F&#39;: inf, &#39;G&#39;: inf}</code></pre></li><li><p>初始nodes，理论上集合nodes只有顶点s。这里创建了其他节点是方便之后的进堆操作，不用再考虑节点是否存在两种情况。</p><pre><code class="lang-python">nodes = [[0, &#39;A&#39;], [inf, &#39;B&#39;], [inf, &#39;C&#39;], [inf, &#39;D&#39;], [inf, &#39;E&#39;], [inf, &#39;F&#39;], [inf, &#39;G&#39;]]</code></pre></li><li><p>从distances数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到nodes中。</p><pre><code class="lang-python">distances = {&#39;A&#39;: 0, &#39;B&#39;: 4, &#39;C&#39;: 2, &#39;D&#39;: 3, &#39;E&#39;: inf, &#39;F&#39;: inf, &#39;G&#39;: inf} # 加入了A的近邻B，C，Dnodes = [[2, &#39;C&#39;], [3, &#39;D&#39;], [4, &#39;B&#39;], [inf, &#39;G&#39;], [inf, &#39;E&#39;], [inf, &#39;F&#39;]] # A被推出，更新B，C，D</code></pre></li><li><p>重复这个过程，直到nodes为s空或nodes中的最小值是无穷大（与剩下的节点都不连通）时。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">import heapqclass Graph:    def __init__(self):        self.vertices = {}    def add_vertex(self, name, edges):        self.vertices[name] = edges    def shortest_path(self, start, finish):        distances = {} # 记录各点到起点距离        previous = {}  # 记录先前路径，注意：对于求最小路径时，每个点的先前路径是唯一的。        nodes = [] # 优先队列        for vertex in self.vertices:            if vertex == start: # 原点 s 的路径权重被赋为 0 （dis[s] = 0）。把到其他顶点的路径长度设为无穷大。                distances[vertex] = 0                heapq.heappush(nodes, [0, vertex])            else:                distances[vertex] = float(&#39;inf&#39;)                heapq.heappush(nodes, [float(&#39;inf&#39;), vertex])            previous[vertex] = None        while nodes:            smallest = heapq.heappop(nodes)[1] # pop优先队列的第一个节点            if smallest == finish: # 保存路径                path = []                cur = smallest                while cur: # 循环到起点，其先前节点为None，结束                    path.append(cur)                    cur = previous[cur]                path.reverse()            if distances[smallest] == float(&#39;inf&#39;): # 剩余所有节点已不相邻                break                  for neighbor in self.vertices[smallest]: # 获取近邻节点                alt = distances[smallest] + self.vertices[smallest][neighbor]                 if alt &lt; distances[neighbor]: # 得到的路径比之前的近，则更新nodes，previous                    previous[neighbor] = smallest                    distances[neighbor] = alt                    for n in nodes:                        if n[1] == neighbor:                            n[0] = alt                            break                    heapq.heapify(nodes)            #print(distances,nodes)        return distances[finish], path    def __str__(self):        return str(self.vertices)if __name__ == &#39;__main__&#39;:    # 实例化，这个类需要依次传入所有边。    g = Graph()    g.add_vertex(&#39;A&#39;, {&#39;B&#39;: 4, &#39;C&#39;: 2, &#39;D&#39;: 3})    g.add_vertex(&#39;B&#39;, {&#39;A&#39;: 4, &#39;E&#39;: 2, &#39;F&#39;: 5})    g.add_vertex(&#39;C&#39;, {&#39;A&#39;: 2, &#39;G&#39;: 1})    g.add_vertex(&#39;D&#39;, {&#39;A&#39;: 3, &#39;G&#39;: 2})    g.add_vertex(&#39;E&#39;, {&#39;B&#39;: 2, &#39;F&#39;: 4})    g.add_vertex(&#39;F&#39;, {&#39;B&#39;: 5, &#39;E&#39;: 4, &#39;G&#39;: 3})    g.add_vertex(&#39;G&#39;, {&#39;C&#39;: 1, &#39;D&#39;: 2, &#39;F&#39;: 3})    print(g.shortest_path(&#39;A&#39;, &#39;G&#39;))</code></pre><h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>Floyd-Warshall算法</strong>(Floyd-Warshall algorithm)，中文亦称<strong>弗洛伊德算法</strong>，是解决任意两点间的最短路径的一种算法，可以正确处理<strong>有向图</strong>或<strong>负权</strong>（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。</p><p>Floyd 算法是一个经典的动态规划算法。</p><p>设<script type="math/tex">D_{i,j,k}</script>为从<script type="math/tex">i</script>到<script type="math/tex">j</script>的只以<script type="math/tex">(i, j)</script>集合中的节点为中间节点的最短路径的长度。</p><ol><li>若最短路径经过点k，则<script type="math/tex">D_{i,j,k}=D_{i,k,k-1}+D_{k,j,k-1}</script>；</li><li>若最短路径不经过点k，则<script type="math/tex">D_{i,j,k}=D_{i,j,k-1}</script></li></ol><p>因此，<script type="math/tex">D_{i,j,k}=min(D_{i,j,k-1},D_{i,k,k-1}+D_{k,j,k-1})</script>。</p><p>在实际算法中，为了节约空间，可以直接在原来空间上进行迭代，这样空间可降至二维。</p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="1920px-Floyd-Warshall_example.svg.png" srcset="/img/loading.gif" alt="graphh"></p><p><img src="2019-12-30 224429.png" srcset="/img/loading.gif" alt="gg"></p><p>Floyd-Warshall算法的<a href="https://zh.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a>为<script type="math/tex">O(N^{3})</script>，<a href="https://zh.wikipedia.org/wiki/空间复杂度" target="_blank" rel="noopener">空间复杂度</a>为<script type="math/tex">O(N^{2})</script>。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def floyd(graph):    length = len(graph)    path = {}    # 建立初始路径path    for i in range(length):        path[i] = {}        for j in range(length):            if i != j and graph[i][j] != float(&#39;inf&#39;):                path[i][j] = [i, j]    # i为选取的中间节点    for i in range(length):                # j为中间节点i的前节点        for j in range(length):            if i == j:                continue            # k为中间节点i的后节点            for k in range(length):                if k == i or k == j:                    continue                new_len = graph[j][i] + graph[i][k]                if graph[j][k] &gt; new_len:                    graph[j][k] = new_len                    new_node = i                    # 合并路径                    path[j][k] = path[j][i][:-1] + path[i][k]    return graph, pathif __name__ == &#39;__main__&#39;:    ini = float(&#39;inf&#39;)    graph_list = [                      [0, ini, -2, ini],                    [4, 0, 3, ini],                    [ini, ini, 0, 2],                    [ini, -1, ini, 0]                 ]    new_graph, path = floyd(graph_list)    print(new_graph, &#39;\n\n\n&#39;, path)</code></pre><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>对连通<strong>图</strong>进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。</p><p><img src="2-1Z106101951H4.gif" srcset="/img/loading.gif" alt="连通图及其对应的生成树"></p><p>a) 是一张连通图，b) 是其对应的 2 种生成树。</p><p>连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。</p><p>连通图中的生成树必须满足以下 2 个条件：</p><ol><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ol><p>因此，连通图的生成树具有这样的特征，即生成树中<code>边的数量 = 顶点数 - 1</code>。</p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p><strong>普里姆算法</strong>（Prim’s algorithm），<strong>图论</strong>中的一种算法，可在加权连通图里搜索<strong>最小生成树</strong>。意即由此算法搜索到的<strong>边</strong>子集所构成的<strong>树</strong>中，不但包括了连通图里的所有<strong>顶点</strong>，且其所有边的权值之和亦为最小。</p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E</li><li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点(起始点)，Enew = {} 为空</li><li>在集合 E 中选取权值最小的边 <u, v>，其中 u 为集合 Vnew 中的元素，而 v 不在 Vnew 集合当中，并且 v∈V (如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）</li><li>将 v 加入集合 Vnew 中，将 <u, v> 边加入集合 Enew 中</li><li>重复步骤 3、4 直到 Vnew = V</li></ol><p><img src="graph6.png" srcset="/img/loading.gif" alt="g"></p><p>时间复杂度：<script type="math/tex">O(V^2)</script></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def prim(graph, root):    assert type(graph)==dict    nodes = list(graph)    nodes.remove(root)    visited = [root]    path = []    next = None    while nodes:        distance = float(&#39;inf&#39;)         for s in visited:            for d in graph[s]:                if d in visited or s == d:                    continue                if graph[s][d] &lt; distance:                    distance = graph[s][d]                    pre = s                    next = d        path.append((pre, next))        visited.append(next)        nodes.remove(next)    return pathif __name__ == &#39;__main__&#39;:    ini = float(&#39;inf&#39;)    graph_dict = {  &#39;A&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 4,   &#39;C&#39;: 2,   &#39;D&#39;: 3,   &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: ini},                    &#39;B&#39;: {&#39;A&#39;: 4,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: 2,   &#39;F&#39;: 5,   &#39;G&#39;: ini},                    &#39;C&#39;: {&#39;A&#39;: 2,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: 1  },                    &#39;D&#39;: {&#39;A&#39;: 3,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: 2  },                    &#39;E&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 2,   &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: 4,   &#39;G&#39;: ini},                    &#39;F&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 5,   &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: 4,   &#39;F&#39;: ini, &#39;G&#39;: 3  },                    &#39;G&#39;: {&#39;A&#39;: ini, &#39;B&#39;: ini, &#39;C&#39;: 1,   &#39;D&#39;: 2,   &#39;E&#39;: ini, &#39;F&#39;: 3,   &#39;G&#39;: ini},                 }    path = prim(graph_dict, &#39;A&#39;)    print(&quot;path:&quot;, path)</code></pre><p>可以看到输出顺序和上图是一致的：</p><pre><code class="lang-python">path: [(&#39;A&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;G&#39;), (&#39;G&#39;, &#39;D&#39;), (&#39;G&#39;, &#39;F&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;E&#39;)]</code></pre><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p><strong>Kruskal算法</strong>是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。基于<a href="https://lil-q.github.io/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/">并查集</a>的数据结构。</p><p><img src="383px-MST_kruskal_en.gif" srcset="/img/loading.gif" alt="kru"></p><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol><li>新建图<script type="math/tex">G</script>，<script type="math/tex">G</script>中拥有原图中相同的节点，但没有边</li><li>将原图中所有的边按权值从小到大排序</li><li>从权值最小的边开始，如果这条边连接的两个节点于图<script type="math/tex">G</script>中不在同一个连通分量中，则添加这条边到图<script type="math/tex">G</script>中</li><li>重复3，直至图<script type="math/tex">G</script>中所有的节点都在同一个连通分量中</li></ol><p><img src="graph7.png" srcset="/img/loading.gif" alt="kur"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def find(id, p):    while p != id[p]:        id[p] = id[id[p]]        p = id[p]    return pdef union(id, size, p, q):    root_p = find(id, p)    root_q = find(id, q)    if root_p != root_q:        if size[p] &lt; size[q]:            id[root_p] = root_q            size[q] += size[p]        else:            id[root_q] = root_p            size[p] += size[q]def kruskal(graph):    assert type(graph)==dict    edges = [(graph[u][v], u, v) for u in graph for v in graph[u] if graph[u][v] != float(&#39;inf&#39;)]    path = []    id, size = {u:u for u in graph}, {u:0 for u in graph}    for _, u, v in sorted(edges):        if find(id, u) != find(id, v):            path.append((u, v))            union(id, size, u, v)    return path</code></pre><p>输入与理论一致：</p><pre><code class="lang-python">path:  [(&#39;C&#39;, &#39;G&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;E&#39;), (&#39;D&#39;, &#39;G&#39;), (&#39;F&#39;, &#39;G&#39;), (&#39;A&#39;, &#39;B&#39;)]</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-leetcode-778-水位上升的泳池中游泳"><a href="#1-leetcode-778-水位上升的泳池中游泳" class="headerlink" title="1. leetcode 778. 水位上升的泳池中游泳"></a>1. <a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">leetcode 778. 水位上升的泳池中游泳</a></h2><p>在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</p><p>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</p><pre><code class="lang-python">输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]输入: 16解释:0   1   2   3   4             　 512  13  14  15  1611  10  9   8   7   6</code></pre><p>使用简化版的Dijkstra算法。</p><pre><code class="lang-python">class Solution(object):    def swimInWater(self, grid):        N = len(grid)        seen = {(0, 0)} # 记录已经访问过的点        pq = [(grid[0][0], 0, 0)] # 创建优先队列        ans = 0        while pq:            d, r, c = heapq.heappop(pq)            # 更新最小路径中的最大值            ans = max(ans, d)            if r == c == N-1: return ans            # 将有可能经过的点都加入到优先队列            for cr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):                if 0 &lt;= cr &lt; N and 0 &lt;= cc &lt; N and (cr, cc) not in seen:                    heapq.heappush(pq, (grid[cr][cc], cr, cc))                    seen.add((cr, cc))</code></pre><h2 id="2-leetcode-207-课程表"><a href="#2-leetcode-207-课程表" class="headerlink" title="2. leetcode 207. 课程表"></a>2. <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">leetcode 207. 课程表</a></h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>这是典型的有向图的拓扑排序问题。有两种解法，利用入度表和深度有限搜索。</p><h3 id="解法一：入度表"><a href="#解法一：入度表" class="headerlink" title="解法一：入度表"></a>解法一：入度表</h3><ol><li>将边信息转换为邻接表<code>adjacency</code>，同时记录每个点的入度<code>indegrees</code></li><li>取出所有入度为0的点加入队列<code>queue</code></li><li>宽度优先搜索，每从队列里取出一个节点，numCourses -= 1, 环内的节点入度不会为0，所以当有环时, numcourses不为0</li></ol><pre><code class="lang-python">class Solution:    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:        indegrees = [0 for _ in range(numCourses)]        adjacency = [[] for _ in range(numCourses)]        queue = []        # 将边信息转换为邻接表adjacency，同时记录每个点的入度indegrees        for cur, pre in prerequisites:            indegrees[cur] += 1            adjacency[pre].append(cur)        # 取出所有入度为0的点加入队列queue        for i in range(len(indegrees)):            if not indegrees[i]: queue.append(i)        # 宽度优先搜索        while queue:            pre = queue.pop(0)            numCourses -= 1            for cur in adjacency[pre]:                indegrees[cur] -= 1                if not indegrees[cur]: queue.append(cur)        return not numCourses</code></pre><h3 id="解法二：深度优先搜索"><a href="#解法二：深度优先搜索" class="headerlink" title="解法二：深度优先搜索"></a>解法二：深度优先搜索</h3><p>借助一个标志列表 flags，用于判断每个节点 i （课程）的状态：</p><blockquote><p>未被 DFS 访问：i == 0；<br>已被其他节点启动的DFS访问：i == -1；<br>已被当前节点启动的DFS访问：i == 1。 </p></blockquote><pre><code class="lang-python">class Solution(object):    def canFinish(self, numCourses, prerequisites):        # 深度优先搜索        def dfs(i,adjacency,flags):            if flags[i]==1:return False            if flags[i]==-1:return True            flags[i]=1            print(i,adjacency)            for nex in adjacency[i]:                if not dfs(nex,adjacency,flags):return False            flags[i]=-1            return True        # 建立邻接表，并在最后加入一个节点指向所有的节点        flags=[0 for _ in range(numCourses+1)]        adjacency=[[] for _ in range(numCourses)]         adjacency.append([i for i in range(numCourses)])                for cur,pre in prerequisites:            adjacency[pre].append(cur)        # 对最后的dummy节点进行深度优先搜索            return dfs(numCourses,adjacency,flags)</code></pre><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Graph" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/skywang12345/p/3691463.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3691463.html</a></li><li><a href="https://zh.wikipedia.org/wiki/图_(数学" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)</a>)</li><li><a href="https://oi-wiki.org/graph/" target="_blank" rel="noopener">https://oi-wiki.org/graph/</a></li><li><a href="http://data.biancheng.net/view/202.html" target="_blank" rel="noopener">http://data.biancheng.net/view/202.html</a></li><li><a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs</a></li><li><a href="https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组(Array)和哈希表(Hash table)</title>
    <link href="/2019/12/09/%E6%95%B0%E7%BB%84-Array/"/>
    <url>/2019/12/09/%E6%95%B0%E7%BB%84-Array/</url>
    
    <content type="html"><![CDATA[<p>数组和哈希表的学习和python实现</p><a id="more"></a><h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><p><strong>数组数据结构</strong>(array data structure)，简称<strong>数组</strong>(Array)，是由相同类型的元素(element)的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引(index)可以计算出该元素对应的存储地址。</p><p>数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表(list)和字符串(string)。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是向量处理器），经常会针对数组操作进行优化。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>Python中 list 数据结构的复杂度。</p><div class="table-container"><table><thead><tr><th>操作</th><th>操作说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>index(value)</td><td>查找list某个元素的索引</td><td>O(1)</td></tr><tr><td>a = index(value)</td><td>索引赋值</td><td>O(1)</td></tr><tr><td>append(value)</td><td>队尾添加</td><td>O(1)</td></tr><tr><td>pop()</td><td>队尾删除</td><td>O(1)</td></tr><tr><td>pop(index)</td><td>根据索引删除某个元素</td><td>O(n)</td></tr><tr><td>insert(index, value)</td><td>根据索引插入某个元素</td><td>O(n)</td></tr><tr><td>iterration</td><td>列表迭代</td><td>O(n)</td></tr><tr><td>search(in)</td><td>列表搜索（其实就是in关键字）</td><td>O(n)</td></tr><tr><td>slice [x:y]</td><td>切片, 获取x, y为O(1), 获取x,y 中间的值为O(k)</td><td>O(k)</td></tr><tr><td>del slice [x:y]</td><td>删除切片，删除切片后数据需要重新移动/合并</td><td>O(n)</td></tr><tr><td>reverse</td><td>列表反转</td><td>O(n)</td></tr><tr><td>sort</td><td>排序</td><td>O(nlogn)</td></tr></tbody></table></div><h1 id="哈希表-Hash-table"><a href="#哈希表-Hash-table" class="headerlink" title="哈希表(Hash table)"></a>哈希表(Hash table)</h1><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据键(Key)而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。</p><ol><li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值为散列地址。</li><li><strong>数字分析法</strong>：假设关键字是以<em>r</em>为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</li><li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。</li><li><strong>折叠法</strong>：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</li><li><strong>随机数法</strong></li><li><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。不仅可以对关键字直接取模，也可在<strong>折叠法</strong>、<strong>平方取中法</strong>等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。</li></ol><h3 id="1-正整数"><a href="#1-正整数" class="headerlink" title="1. 正整数"></a>1. 正整数</h3><p>获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。</p><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h3><p>将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如</p><pre><code class="lang-python">def getHashCode(str):    hash = 0    for char in str:        hash = int(char) + (31 * hash)    return hash</code></pre><p>上面的哈希值是Horner计算字符串哈希值的方法，公式为:</p><script type="math/tex; mode=display">h = s[0] · 31^{L–1} + … + s[L – 3] · 31^2 + s[L – 2] · 31^1 + s[L – 1] · 31^0</script><p>举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 3045982 = 99·31^3 + 97·31^2 + 108·31^1 + 108·31^0 = 108 + 31· (108 + 31 · (97 + 31 · (99)))。</p><pre><code class="lang-python">print(getHashCode(&quot;call&quot;))&#39;&#39;&#39;输出： 3045982&#39;&#39;&#39;</code></pre><p>如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值。但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串：</p><p><img src="312300343319616.jpg" srcset="/img/loading.gif" alt="hash code collision"></p><p>如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。</p><h2 id="哈希冲撞"><a href="#哈希冲撞" class="headerlink" title="哈希冲撞"></a>哈希冲撞</h2><p>如果将2450个密钥散列到一百万个存储桶中，即使具有完全均匀的随机分布，则根据生日问题，至少有两个密钥散列到同一存储桶的机率大约为95％。<script type="math/tex">1*\frac{10^6-1}{10^6}*\frac{10^6-2}{10^6}</script>…<script type="math/tex">\frac{10^6-2449}{10^6}</script></p><pre><code class="lang-python">res=1n=1000000for i in range(2450):    res*=(n-1)/nprint(res)&#39;&#39;&#39;0.9975529975784029&#39;&#39;&#39;</code></pre><p><a href="https://zh.wikipedia.org/zh-hans/生日攻击" target="_blank" rel="noopener">有兴趣可以了解一下生日攻击。</a></p><h3 id="1-Separate-chaining"><a href="#1-Separate-chaining" class="headerlink" title="1. Separate chaining"></a>1. Separate chaining</h3><p>每一个<code>bucket</code>指向一个数组、链表或其他数据结构。</p><p><img src="675px-Hash_table_5_0_1_1_1_1_1_LL.svg.png" srcset="/img/loading.gif" alt="spe"></p><h3 id="2-Open-addressing"><a href="#2-Open-addressing" class="headerlink" title="2. Open addressing"></a>2. Open addressing</h3><p>每一个<code>bucket</code>存放一个<code>entry record</code>,添加时如果已占用就下移一格，查找同理。</p><p><img src="570px-Hash_table_5_0_1_1_1_1_0_SP.svg.png" srcset="/img/loading.gif" alt="opa"></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>Python中 dict 数据结构的复杂度</p><div class="table-container"><table><thead><tr><th>操作</th><th>操作说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>copy</td><td>复制</td><td>O(n)</td></tr><tr><td>get(value)</td><td>获取</td><td>O(1)</td></tr><tr><td>set(value)</td><td>修改</td><td>O(1)</td></tr><tr><td>delete(value)</td><td>删除</td><td>O(1)</td></tr><tr><td>search(in)</td><td>字典搜索</td><td>O(1)</td></tr><tr><td>iterration</td><td>字典迭代</td><td>O(n)</td></tr></tbody></table></div><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-力扣（leetcode）204-计数质数"><a href="#1-力扣（leetcode）204-计数质数" class="headerlink" title="1. 力扣（leetcode）204. 计数质数"></a>1. <a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">力扣（leetcode）204. 计数质数</a></h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p><pre><code class="lang-python">class Solution:    def countPrimes(self, n: int) -&gt; int:        isPrime = [1] * n         for i in range(2, int(n ** 0.5) + 1):            if isPrime[i]:                for j in range(i * i, n, i):                    isPrime[j] = 0        counts = 0        for i in range(2,len(isPrime)):            if isPrime[i] : counts += 1        return counts</code></pre><h2 id="2-力扣（leetcode）355-设计推特"><a href="#2-力扣（leetcode）355-设计推特" class="headerlink" title="2. 力扣（leetcode）355. 设计推特"></a>2. <a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">力扣（leetcode）355. 设计推特</a></h2><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p><p>postTweet(userId, tweetId): 创建一条新的推文<br>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。<br>follow(followerId, followeeId): 关注一个用户<br>unfollow(followerId, followeeId): 取消关注一个用户</p><pre><code class="lang-python">from collections import defaultdictclass Twitter:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.timeline = defaultdict(list)        self.userId_follower = defaultdict(set)        self.now = 1    class post:        def __init__(self, tweetId, time):            self.id = tweetId            self.time = time            self.next = None    def postTweet(self, userId: int, tweetId: int) -&gt; None:        &quot;&quot;&quot;        Compose a new tweet.        &quot;&quot;&quot;        po = self.post(tweetId, self.now)        if len(self.timeline[userId]) &gt; 0:            po.next = self.timeline[userId][-1]        self.timeline[userId].append(po)        self.now += 1    def getNewsFeed(self, userId):        &quot;&quot;&quot;        Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.        &quot;&quot;&quot;        res = []        queue = []        for uid in self.userId_follower[userId] | {userId}:            if len(self.timeline[uid]) &gt; 0:                queue.append(self.timeline[uid][-1])        if not queue: return []        for _ in range(10):            maxIndex = 0            maxId = 0            f = 0            for i in range(len(queue)):                if queue[i] and (queue[i].time &gt; maxId):                    maxId=queue[i].time                    maxIndex = i                    f = 1            if f == 0 and not queue[0]: break            res.append(queue[maxIndex].id)            queue[maxIndex]=queue[maxIndex].next         return res    def follow(self, followerId: int, followeeId: int) -&gt; None:        &quot;&quot;&quot;        Follower follows a followee. If the operation is invalid, it should be a no-op.        &quot;&quot;&quot;        self.userId_follower[followerId].add(followeeId)    def unfollow(self, followerId: int, followeeId: int) -&gt; None:        &quot;&quot;&quot;        Follower unfollows a followee. If the operation is invalid, it should be a no-op.        &quot;&quot;&quot;        self.userId_follower[followerId].discard(followeeId)</code></pre><p>采用了<a href="https://leetcode-cn.com/problems/design-twitter/solution/mian-xiang-dui-xiang-she-ji-he-bing-k-ge-you-xu-li/" target="_blank" rel="noopener">优先队列</a>的思路</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84</a></li><li><a href="https://zh.wikipedia.org/zh-hans/哈希表" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%93%88%E5%B8%8C%E8%A1%A8</a></li><li><a href="https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html</a></li><li><a href="https://www.jianshu.com/p/fa57d21b9ad7" target="_blank" rel="noopener">https://www.jianshu.com/p/fa57d21b9ad7</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈(Stack)和队列(Queue)</title>
    <link href="/2019/12/08/%E6%A0%88-Stack-%E5%92%8C%E9%98%9F%E5%88%97-Queue/"/>
    <url>/2019/12/08/%E6%A0%88-Stack-%E5%92%8C%E9%98%9F%E5%88%97-Queue/</url>
    
    <content type="html"><![CDATA[<p>栈和队列的学习和python实现</p><a id="more"></a><h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><p><strong>堆栈</strong>(stack)又称为<strong>栈</strong>或<strong>堆叠</strong>，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，top）进行加入数据(push)和移除数据(pop)的运算。因而按照后进先出(LIFO, Last In First Out)原理运作。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>堆栈使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：</p><ul><li>推入：将数据放入堆栈顶端，堆栈顶端移到新放入的数据。</li><li>弹出：将堆栈顶端数据移除，堆栈顶端移到移除后的下一笔数据。</li></ul><p>在python中，可用<code>list</code>模拟栈，<code>append()</code>模拟入栈，<code>pop()</code>模拟出栈。</p><p><img src="300px-Data_stack.svg.png" srcset="/img/loading.gif" alt="stack"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p><a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">力扣（LeetCode）20.有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。注意空字符串可被认为是有效字符串。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><pre><code class="lang-python">class Solution:    def isValid(self, s: str) -&gt; bool:        dic={&#39;)&#39;:&#39;(&#39;,&#39;}&#39;:&#39;{&#39;,&#39;]&#39;:&#39;[&#39;}        stack=[]        for char in s:            # 右括号匹配栈顶的字符            if char in dic:                # 空栈或不匹配，则输出False                if not stack or stack[-1]!=dic[char]:                    return False                # 匹配成功，左括号出栈                else:                    stack.pop()            # 左括号直接插入            else:                stack.append(char)        return True if not stack else False</code></pre></li><li><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">力扣（LeetCode）84. 柱状图中最大的矩形</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="histogram_area.png" srcset="/img/loading.gif" alt="84"></p><pre><code class="lang-python">class Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        stack = [0]        # 增加左右边界        heights = [0] + heights + [0]        res = 0        # 建立一个递增栈，记录index，方便计算宽度        for i in range(1,len(heights)):            # 当出现递减的数时，对栈内大于该数的数处理            while heights[stack[-1]] &gt; heights[i]:                tmp = stack.pop()                res = max(res, (i - stack[-1] - 1) * heights[tmp])            stack.append(i)        return res</code></pre></li><li><h4 id="力扣（LeetCode）316-去除重复字母"><a href="#力扣（LeetCode）316-去除重复字母" class="headerlink" title="力扣（LeetCode）316. 去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">力扣（LeetCode）316. 去除重复字母</a></h4><p>给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><pre><code class="lang-python">class Solution:    def removeDuplicateLetters(self, s: str) -&gt; str:        stack = []        existed = set()        counter = {}        for c in s:            counter[c]=counter.get(c,0)+1        for c in s:            if c not in existed:                 # 后面还有这个数，我们才能放心的删除                while stack and stack[-1] &gt; c and counter[stack[-1]]:                    existed.remove(stack.pop())                stack.append(c)                existed.add(c)            counter[c]-=1        return &#39;&#39;.join(stack)</code></pre><p>其实也是建立了一个递增栈，但是这里需要满足所有的字母最后只出现一次。</p></li></ol><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p><strong>队列</strong>(queue)，是先进先出(FIFO, First-In-First-Out)的线性表。在具体应用中通常用链表或者数组来实现。</p><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><p>队列只允许在后端（<em>rear</em>）进行插入操作，在前端（<em>front</em>）进行删除操作。</p><p>在python中，可用<code>list</code>模拟简单模拟队列，<code>append()</code>模拟插入，<code>pop(0)</code>模拟删除。或使用<code>deque</code>。</p><pre><code class="lang-python">from collections import deque</code></pre><p><a href="https://zhuanlan.zhihu.com/p/45798936" target="_blank" rel="noopener">队列的实现分为顺序存储结构和链式存储结构，前者基于数组实现，后者则实基于单链表。</a>简单来说，顺序储存结构在进行队列删除操作时会留出空的储存空间，最后导致假溢。解决办法是引入了循环向量这个概念，也就是把队列的头尾相连接并且使用顺序存储结构进行数据存储的队列，这时队列称<strong>循环队列</strong>。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><ol><li><h4 id="力扣（leetcode）622-设计循环队列"><a href="#力扣（leetcode）622-设计循环队列" class="headerlink" title="力扣（leetcode）622. 设计循环队列"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">力扣（leetcode）622. 设计循环队列</a></h4><pre><code class="lang-python">class MyCircularQueue:    def __init__(self, k: int):        self.size = k        self.cq = [0]*k        self.eq = 0        self.dq = 0        self.count = 0    def enQueue(self, value: int) -&gt; bool:        if self.count == self.size:            return False        self.cq[self.eq] = value        self.eq += 1        if self.eq == self.size:            self.eq = 0        self.count += 1        return True    def deQueue(self) -&gt; bool:        if self.count == 0:            return False        self.dq += 1        if self.dq == self.size:            self.dq = 0        self.count -= 1        return True    def Front(self) -&gt; int:        if self.count == 0:            return -1        return self.cq[self.dq]    def Rear(self) -&gt; int:        if self.count == 0:            return -1        return self.cq[self.eq-1]    def isEmpty(self) -&gt; bool:        return self.count == 0    def isFull(self) -&gt; bool:        return self.count == self.size</code></pre><p>这里每当头尾指针溢出（也就是等于k时），将其置为0。当然也可以一直使用<code>self.eq%self.size</code>和<code>self.dq%self.size</code>作为指针。</p></li></ol><ol><li><h4 id="力扣（leetcode）102-二叉树的层次遍历"><a href="#力扣（leetcode）102-二叉树的层次遍历" class="headerlink" title="力扣（leetcode）102. 二叉树的层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">力扣（leetcode）102. 二叉树的层次遍历</a></h4><pre><code class="lang-python">from collections import dequeclass Solution:    def levelOrder(self, root):        levels = []        if not root:            return levels                level = 0        queue = deque([root,])        while queue:            levels.append([])            level_length = len(queue)                      for i in range(level_length):                node = queue.popleft()                levels[level].append(node.val)                if node.left:                    queue.append(node.left)                if node.right:                    queue.append(node.right)            level += 1         return levels</code></pre><p>当然如果不分层的话会更直观：</p><pre><code class="lang-python">from collections import dequedef levelOrderTraversal(root):    res=[]    queue = deque([root,])    while queue:        node = queue.popleft()        if node.left :            queue.append(node.left)            if node.right:                queue.append(node.right)                res.append(node.val)    return res</code></pre></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/堆栈" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88</a></li><li><a href="https://zh.wikipedia.org/wiki/队列" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树(Tree)</title>
    <link href="/2019/12/04/%E6%A0%91-tree/"/>
    <url>/2019/12/04/%E6%A0%91-tree/</url>
    
    <content type="html"><![CDATA[<p>之所以叫树是因为他看起来像一棵倒挂的树</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>树</strong>（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点都只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ol><li><strong>节点的度(Degree)</strong>：一个节点含有的子树的个数称为该节点的度</li><li><strong>树的度(Degree of tree)</strong>：一棵树中，最大的节点度称为树的度</li><li><strong>叶节点(Leaf)</strong>：度为零的节点</li><li><strong>分支节点(Branch node)</strong>：度不为零的节点</li><li><strong>父节点(Parent)</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点</li><li><strong>子节点(child)</strong>：一个节点含有的子树的根节点称为该节点的子节点</li><li><strong>兄弟节点(siblings)</strong>：具有相同父节点的节点互称为兄弟节点</li><li><strong>层次(level)</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推</li><li><strong>深度(depth)</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0</li><li><strong>高度(height)</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0</li><li><strong>节点的祖先(ancestor)</strong>：从根到该节点所经分支上的所有节点</li><li><strong>森林(forest)</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林</li></ol><p><img src="height-depth.jpg" srcset="/img/loading.gif" alt="层次深度和高度"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>本文将介绍二叉树(Binary tree)、二叉搜索树(Binary search tree)和字典树(Trie)。关于AVL树(AVL tree)、红黑树(Red–black tree)和Ｂ树(B-tree)，不做深入探讨。</p><p><img src="tree-cate.jpg" srcset="/img/loading.gif" alt="cate"></p><p>这里区分一下完全二叉树、满二叉树、完美二叉树:</p><ol><li>完全二叉树：最后一层的叶子节点均需在最左边</li><li>满二叉树：满足完全二叉树性质，树中除了叶子节点，每个节点都有两个子节点</li><li>完美二叉树：满足满二叉树性质，树的叶子节点铺满最后一层</li></ol><p><img src="BinaryTree2.png" srcset="/img/loading.gif" alt="full"></p><h2 id="二叉树-Binary-tree"><a href="#二叉树-Binary-tree" class="headerlink" title="二叉树(Binary tree)"></a>二叉树(Binary tree)</h2><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p><pre><code class="lang-python"># 建一个单节点class Node(object):    def __init__(self, value):        self.val = value        self.left = None #左节点        self.right = None #右节点&#39;&#39;&#39;# 建一个二叉树#           1 #         /   \ #        2     3#       / \   / \#      4   5 6   7&#39;&#39;&#39;root = Node(1)stack = [root]value = 2for i in range(3):    cur = stack.pop(0)    cur.left = Node(value)    stack.append(cur.left)    value += 1    cur.right = Node(value)    stack.append(cur.right)    value += 1</code></pre><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历有前序遍历、中序遍历、后序遍历和层序遍历等，这里用迭代和递归两个方法介绍。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def preorderTraversal(root):    if not root:        return     print(root.val, end = &#39; &#39;)    preorderTraversal(root.left)    preorderTraversal(root.right)</code></pre><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><pre><code class="lang-python"># 方法一def preorderTraversalIter(root):    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        print(node.val, end = &#39; &#39;)        if node.right:            stack.append(node.right)        if node.left:            stack.append(node.left)# 方法二def preorderTraversalIter(root):    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            print(root.val, end = &#39; &#39;)            root=root.left        root=stack.pop()        root=root.right</code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def inorderTraversal(root):    if not root:        return      inorderTraversal(root.left)    print(root.val)    inorderTraversal(root.right)</code></pre><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><pre><code class="lang-python">def inorderTraversalIter(root):    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            root=root.left        root=stack.pop()        print(root.val, end = &#39; &#39;)        root=root.right</code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def postorderTraversal(root):    if not root:        return      postorderTraversal(root.left)    postorderTraversal(root.right)    print(root.val)</code></pre><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>比较tricky的办法是吧后序遍历转变成中右左遍历的倒序，代码如下</p><pre><code class="lang-python"># 方法一def postorderTraversalIter(root):    res = []    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        if node.left :            stack.append(node.left)        if node.right:            stack.append(node.right)        res.append(node.val)    return res[::-1]# 方法二def postorderTraversalIter(root):    res = []    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            res.append(root.val)            root = root.right        root = stack.pop()        root = root.left    return res[::-1]</code></pre><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><pre><code class="lang-python">def levelOrderTraversal(root):    # 使用列表模拟先进先出队列queue    queue = [root]    while queue:        node = queue.pop(0)        if node.left :            queue.append(node.left)        if node.right:            queue.append(node.right)        print(node.val, end = &#39; &#39;)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code class="lang-python">前序遍历_递归：1 2 4 5 3 6 7 前序遍历_迭代：1 2 4 5 3 6 7 中序遍历_递归：4 2 5 1 6 3 7 中序遍历_迭代：4 2 5 1 6 3 7 后序遍历_递归：4 5 2 6 7 3 1 后序遍历_迭代：4 5 2 6 7 3 1 层序遍历：1 2 3 4 5 6 7</code></pre><h3 id="二叉树的序列化"><a href="#二叉树的序列化" class="headerlink" title="二叉树的序列化"></a>二叉树的序列化</h3><p>「序列化」（serialization），指的是把复杂的数据结构转化为线性结构，以方便存储的过程。序列化得到的线性结构必须能重建出原有的结构，才有意义。</p><h4 id="仅使用一种遍历的序列化方法"><a href="#仅使用一种遍历的序列化方法" class="headerlink" title="仅使用一种遍历的序列化方法"></a>仅使用一种遍历的序列化方法</h4><p>这是最常见的序列化方法。可以采用的遍历顺序包括先序、后序、层序。在遍历时，要把空指针也包含在遍历的结果中。例如，对下图的二叉树，进行先序、后序、层序遍历的结果分别为 12##3#4##、##2###431、123###4##（# 表示空指针）。</p><p><img src="v2-fa1e727f17845ced6ad75d476b9ec3cf_hd.jpg" srcset="/img/loading.gif" alt="xu"></p><pre><code class="lang-python">def reconstruct(root):    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        print(node.val, end=&#39; &#39;)        if node.right:            stack.append(node.right)        else:            print(&#39;#&#39;, end = &#39; &#39;)        if node.left:            stack.append(node.left)        else:            print(&#39;#&#39;, end = &#39; &#39;)</code></pre><p>而仅根据（带空指针的）中序遍历，是不能重建二叉树的。比如，上面这棵树的中序遍历为 #2#1#3#4#。事实上可以证明，任何一棵二叉树的中序遍历结果，都会是空指针与树中结点交替出现的形式，所以空指针没有提供任何额外的信息。<a href="https://zhuanlan.zhihu.com/p/26418233" target="_blank" rel="noopener">原文</a></p><h2 id="二叉搜索树-Binary-search-tree"><a href="#二叉搜索树-Binary-search-tree" class="headerlink" title="二叉搜索树(Binary search tree)"></a>二叉搜索树(Binary search tree)</h2><p><strong>二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li><li>任意节点的左、右子树也分别为二叉查找树</li><li>没有键值相等的节点</li></ol><p><img src="225px-Binary_search_tree.svg.png" srcset="/img/loading.gif" alt="bst"></p><p>空间复杂度：O(<em>n</em>)。</p><p>时间复杂度：</p><div class="table-container"><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">平均</th><th style="text-align:center">最差</th></tr></thead><tbody><tr><td style="text-align:center">搜索</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr></tbody></table></div><h3 id="二叉搜索树的建立"><a href="#二叉搜索树的建立" class="headerlink" title="二叉搜索树的建立"></a>二叉搜索树的建立</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li>若b是空树，则将<code>node</code>所指节点作为根节点插入，否则：</li><li>若<code>node.val</code>等于b的根节点的数据域之值，则返回，否则：</li><li>若<code>node.val</code>小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li><li>把<code>node</code>所指节点插入到右子树中</li></ol><p>新插入节点总是叶子节点，所以数字组成相同但是排序不同的序列所构造的二叉搜索树其实是不同的。但是序列化（见后文）的结果是一致的。</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树</li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/pythonchang-gui-jie-fa-by-lil-q/" target="_blank" rel="noopener">自己做leetcode 450时的解法</a>，非递归，算法有些复杂。</p><pre><code class="lang-python">class Solution:    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:        # 删除节点返回新的子树            def delete(node):            # 没有子节点，返回None            if not node.left and not node.right:return None            # 没有左子节点，返回右子节点            elif not node.left:return node.right            # 没有右子节点，返回左子节点            elif not node.right:return node.left            # 待删除节点度为2，详细讨论            else:                # 左子节点没有右子节点                if not node.left.right:                    node.left.right=node.right                    return node.left                # 右子节点没有左子节点                elif not node.left.right:                    node.left.right=node.right                    return node.left                 # 都不满足，返回左子树最大值                else:                    # 记录父节点pre                    pre=left=node.left                    while left.right:                        pre=left                        left=left.right                    # 保存待最大值的左子树到父节点的右子树                    pre.right=left.left                    left.left=node.left                    left.right=node.right                    return left        if not root:return root                if root.val==key:            root=delete(root)            return root        father=node=root        while node.val!=key:            if node.val&gt;key:                father=node                node=node.left            else:                father=node                node=node.right            if not node:return root        if father.left==node:father.left=delete(node)        else: father.right=delete(node)        return root</code></pre><p>这里给出递归的方式。递归的好处在于不用考虑寻找父节点以及待删除结点到底是父节点的左子节点还是右子节点。</p><p>在二叉查找树删去一个结点，分三种情况讨论：</p><ol><li>若待删除结点p为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li><li>若待删除结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉查找树的特性。</li><li>若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；其二是令p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。</li></ol><p><img src="720px-Binary_search_tree_delete.svg.png" srcset="/img/loading.gif" alt="deletenode"></p><h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><pre><code class="lang-python">class BinarySearchTree:    # 初始化    def __init__(self, value):        self.val = value        self.left=None        self.right=None    # 查找最小值    def find_min(self):        current = self        while current.left:            current = current.left        return current       # 查找最大值    def find_max(self):        current = self        while current.right:            current = current.right        return current       # 插入一个节点    def insert(self, value):        node = BinarySearchTree(value)        current = self        while True:            if value &lt; current.val:                if current.left is None:                    current.left = node                    return                 current = current.left            elif value &gt; current.val:                if current.right is None:                    current.right = node                    return                 current = current.right            else: return self    # 查找节点    def find(self, value):        current = self        while current:            if current.val == value:                return current            current = current.left if value &lt; current.val else current.right        # 此时current==None        return current    # 删除节点    def delete(self,value):        if self.find(value):            if value&lt;self.val:                self.left=self.left.delete(value)                return self            elif value&gt;self.val:                self.right=self.right.delete(value)                return self            elif self.left and self.right:                val=self.right.findMin().val                self.val=val                self.right=self.right.delete(val)                return self            else:                if self.left:                    return self.left                else:                    return self.right        else:            return self</code></pre><p><em>注：代码中没有考虑空树。</em></p><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树(Trie)"></a>字典树(Trie)</h2><p>Trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><pre><code class="lang-python">class Trie:    # 初始化    def __init__(self):        self.lookup = {}    def insert(self, word):        tree = self.lookup        for a in word:            if a not in tree:                tree[a] = {}            tree = tree[a]        # 单词结束标志        tree[&quot;#&quot;] = &quot;#&quot;    def search(self, word):        tree = self.lookup        for a in word:            if a not in tree:                return False            tree = tree[a]        if &quot;#&quot; in tree:            return True        return False      def startsWith(self, prefix):        tree = self.lookup        for a in prefix:            if a not in tree:                return False            tree = tree[a]        return True</code></pre><h2 id="B树-B-tree-和B-树-B-tree"><a href="#B树-B-tree-和B-树-B-tree" class="headerlink" title="B树(B-tree)和B+树(B+ tree)"></a>B树(B-tree)和B+树(B+ tree)</h2><p><strong>B树</strong>（B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</p><p>请参考<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">这篇文章</a></p><h2 id="AVL树-AVL-tree"><a href="#AVL树-AVL-tree" class="headerlink" title="AVL树(AVL tree)"></a>AVL树(AVL tree)</h2><p><strong>AVL树</strong>是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。</p><p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p><h2 id="黑红树-Red–black-tree"><a href="#黑红树-Red–black-tree" class="headerlink" title="黑红树(Red–black tree)"></a>黑红树(Red–black tree)</h2><p><strong>红黑树</strong>是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>下面是一个具体的红黑树的图例：</p><p><img src="675px-Red-black_tree_example.svg.png" srcset="/img/loading.gif" alt="rbt"></p><p>操作有变色，左旋，右旋。</p><h2 id="树堆-treap"><a href="#树堆-treap" class="headerlink" title="树堆(treap)"></a>树堆(treap)</h2><p><strong>树堆</strong>（Treap）是二叉排序树（Binary Sort Tree）与堆（Heap）结合产生的一种拥有堆性质的二叉排序树。</p><p>但是这里要注意两点，第一点是Treap和二叉堆有一点不同，就是二叉堆必须是完全二叉树，而Treap并不一定是；第二点是Treap并不严格满足平衡二叉排序树（AVL树）的要求，即树堆中每个节点的左右子树高度之差的绝对值可能会超过1，只是近似满足平衡二叉排序树的性质。</p><p>Treap每个节点记录两个数据，一个是键值，一个是随机附加的优先级，Treap在以关键码构成二叉排序树的同时，又以结点优先级形成最大堆和最小堆。所以Treap必须满足这两个性质，一是二叉排序树的性质，二是堆的性质。如下图，即为一个树堆。</p><p><img src="330px-TreapAlphaKey.svg.png" srcset="/img/loading.gif" alt="treap"></p><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Tree" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)</a>)</li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-he-di-gui-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-he-di-gui-by-powcai/</a></li><li><a href="https://zhuanlan.zhihu.com/p/26418233" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26418233</a></li><li><a href="https://python123.io/index/topics/data_structure/binary_tree" target="_blank" rel="noopener">https://python123.io/index/topics/data_structure/binary_tree</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/pythonjian-dan-shi-xian-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/pythonjian-dan-shi-xian-by-powcai/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治算法(Divide-and-conquer algorithm)</title>
    <link href="/2019/11/18/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2019/11/18/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>看见O(log n)时间复杂度就想到了分治算法</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换) 。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，<strong>子问题之间没有相关性</strong>，这一点是分治算法跟动态规划的明显<a href="https://zhuanlan.zhihu.com/p/33048876" target="_blank" rel="noopener">区别</a>；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. <a href="https://lil-q.github.io/2019/11/16/排序-Sort-算法/">归并排序</a></h3><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. <a href="https://lil-q.github.io/2019/11/16/排序-Sort-算法/">快速排序</a></h3><h3 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3. 二分查找"></a>3. 二分查找</h3><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。</p><pre><code class="lang-python">def extreme_insertion_index(self, nums, target, left):     &#39;&#39;&#39;    left是一个布尔值，用来决定target==nums[mid]情况下的选择：求左边界时，hi=mid，区间往左走；求右边界时，lo=mid+1，区间往右走。    &#39;&#39;&#39;    lo = 0    hi = len(nums)    while lo &lt; hi:        mid = (lo + hi) // 2        if nums[mid] &gt; target or (left and target == nums[mid]):            hi = mid        else:            lo = mid+1    return lodef searchRange(self, nums, target):    left_idx = self.extreme_insertion_index(nums, target, True)    if left_idx == len(nums) or nums[left_idx] != target:        return [-1, -1]    return [left_idx, self.extreme_insertion_index(nums, target, False)-1]</code></pre><p>上面<code>extreme_insertion_index()</code>的代码是采用左闭右开的区间，也可以改写成以下闭区间的写法：</p><pre><code class="lang-python">def extreme_insertion_index(self, nums, target, left):      lo = 0    hi = len(nums)-1 # 闭区间    while lo &lt;= hi: # 加入=，防止hi-lo=1时漏判        mid = (lo + hi) // 2        if nums[mid] &gt; target or (left and target == nums[mid]):            hi = mid+1 # 需要加一，防止陷入死循环        else:            lo = mid+1    return lo</code></pre><h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h3><p> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">leetcode 105. 从前序与中序遍历序列构造二叉树</a></p><p>根据一棵树的前序遍历与中序遍历构造二叉树（假设树中没有重复的元素）。</p><p>例如，给出</p><pre><code class="lang-python">前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>由于是树，我们很容易意识到左子树和右子树就是两个子问题。对于一个子问题，我们只需要找到根节点，连接左子树，连接右子树。</p><pre><code class="lang-python">class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder: return None        root = TreeNode(preorder[0])        mid = inorder.index(preorder[0])        root.left = self.buildTree(preorder[1:mid + 1], inorder[:mid])        root.right = self.buildTree(preorder[mid + 1:], inorder[mid + 1:])        return root</code></pre><p>官方给出的方法更好，不需要反复传入<code>list</code>并且用<code>dict</code>代替了<code>list.index()</code>：</p><pre><code class="lang-python">class Solution:    def buildTree(self, preorder, inorder):        &quot;&quot;&quot;        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        def helper(in_left = 0, in_right = len(inorder)):            nonlocal pre_idx            # if there is no elements to construct subtrees            if in_left == in_right:                return None            # pick up pre_idx element as a root            root_val = preorder[pre_idx]            root = TreeNode(root_val)            # root splits inorder list            # into left and right subtrees            index = idx_map[root_val]            # recursion             pre_idx += 1            # build left subtree            root.left = helper(in_left, index)            # build right subtree            root.right = helper(index + 1, in_right)            return root        # start from first preorder element        pre_idx = 0        # build a hashmap value -&gt; its index        idx_map = {val:idx for idx, val in enumerate(inorder)}         return helper()</code></pre><p>给出c++版本:</p><pre><code class="lang-c++">class Solution {public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {        int pos = 0;        return buildTree(preorder, pos, inorder, 0, preorder.size() - 1);    }    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int&amp; pos, vector&lt;int&gt;&amp;inorder, int left, int right){        if(pos &gt;= preorder.size()){            return 0;        }        int i = left;        for(i = left; i &lt;= right; i++){            if(inorder[i] == preorder[pos]){                break;            }        }        TreeNode* node = new TreeNode(preorder[pos]);        if (left &lt; i){node-&gt;left = buildTree(preorder, ++pos, inorder, left, i - 1);}        if (i &lt; right){node-&gt;right = buildTree(preorder, ++pos, inorder, i + 1, right);}        return node;      }};</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/分治法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95</a> </li><li><a href="https://hotttao.github.io/2018/11/05/alog/divide/" target="_blank" rel="noopener">https://hotttao.github.io/2018/11/05/alog/divide/</a> </li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>分治</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆(Heap)</title>
    <link href="/2019/11/17/%E5%A0%86-heap/"/>
    <url>/2019/11/17/%E5%A0%86-heap/</url>
    
    <content type="html"><![CDATA[<p>经过努力，最值总会冒上来的！</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>在通常情况下，使用列表储存堆，堆树是一颗<a href="https://www.zhihu.com/question/36134980/answer/87490177" target="_blank" rel="noopener">完全二叉树</a>，二项堆和斐波那契堆不属于二叉树 </li><li>堆树中某个节点的值总是不大于或不小于其孩子节点的值 </li><li>堆树中每个节点的子树都是堆树 </li></ol><p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 本文以最大堆作为例子，最小堆类似。</p><h2 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h2><p>堆的建立并不建立一个新的树，而是对数组进行原地改动，第一个数（index=0）为完全二叉树的level 0，即根，第二个数和第三个数为level 1，以此类推。</p><p><img src="建堆.png" srcset="/img/loading.gif" alt="建堆"></p><p>由于数组是升序数组，我们直接得到了最小堆。但是如果要进行升序排序，算法上需要建立最大堆。也就是说，当原数组是升序时，堆排序算法遇到了最坏情况。本文也以这种情况作为例子。</p><pre><code class="lang-python">nums=[1,2,3,4,5]</code></pre><h3 id="堆的维护"><a href="#堆的维护" class="headerlink" title="堆的维护"></a>堆的维护</h3><p>上图的根节点是1，小于子节点，那么这显然违反了最大堆的性质，这时候需要让该元素在最大堆中逐级下降，维护最大堆的性质。处理一次维护的代码如下：</p><pre><code class="lang-python">def adjust_heap(idx, max_len,nums):    left = 2 * idx + 1    right = 2 * idx + 2    max_loc = idx    if left &lt; max_len and nums[max_loc] &lt; nums[left]:        max_loc = left    if right &lt; max_len and nums[max_loc] &lt; nums[right]:        max_loc = right    if max_loc != idx:        nums[idx], nums[max_loc] = nums[max_loc], nums[idx]        adjust_heap(max_loc, max_len,nums)</code></pre><h3 id="建立最大堆"><a href="#建立最大堆" class="headerlink" title="建立最大堆"></a>建立最大堆</h3><ol><li>自底向上处理， 因为数组<code>list[n//2,n]</code>中的所有元素都在堆树的叶节点中，因此可以看成只包含一个元素的堆， 无需维护。其中<code>n=len(list)</code>。</li><li>从<code>index=n//2-1</code>开始，直到<code>index=0</code>，对每一个节点或根进行一次维护。</li></ol><p><em>注意：一次维护并不是最多只交换一次，而是交换到某节点满足最大堆条件或者<code>index&gt;=n</code>为止。</em></p><p><img src="heapflow.png" srcset="/img/loading.gif" alt="heapflow"></p><pre><code class="lang-python">def build_heap(nums):        n = len(nums)    for i in range(n // 2 - 1, -1, -1):        adjust_heap(i, n,nums)    return numsheap=build_heap(nums)print(&quot;heap:&quot;,heap)#输出：heap: [5, 4, 3, 1, 2]</code></pre><h2 id="最大堆中插入节点"><a href="#最大堆中插入节点" class="headerlink" title="最大堆中插入节点"></a>最大堆中插入节点</h2><p>最大堆的插入节点的思想就是先在堆的最后添加一个节点，也就是在<code>list.append()</code>，然后沿着堆树上升。跟最大堆的初始建立过程大致相同。 </p><pre><code class="lang-python">def heap_insert(heap,num):    heap=heap+[num]    n=len(heap)    i=n-1    while i&gt;0 and heap[(i-1)//2]&lt;num:        heap[i]=heap[(i-1)//2]        i=(i-1)//2    heap[i]=num    return heapheap=heap_insert(heap,6)print(&quot;heapIns:&quot;,heap)#输出：heapIns: [6, 4, 5, 1, 2, 3]</code></pre><p><img src="heapinsert.png" srcset="/img/loading.gif" alt="charu"></p><h2 id="最大堆节点的删除"><a href="#最大堆节点的删除" class="headerlink" title="最大堆节点的删除"></a>最大堆节点的删除</h2><p>对一个节点的删除就是交换该节点和最后一个叶子节点的值，然后从该节点开始一次<code>adjust_heap()</code></p><pre><code class="lang-python">def heap_delete(heap,idx):    n=len(heap)    heap[idx],heap[-1]=heap[-1],heap[idx]    adjust_heap(idx, n - 1,heap)    heap.pop()    return heapheap=heap_delete(heap,0)print(&quot;heapDel:&quot;,heap)#输出：heapDel: [5, 4, 3, 1, 2]</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>特殊地，当我们交换根和最后一个叶子节点时，就能够提出最大值，并且存放在<code>index=-1</code>的位置。然后再对前n-1个数组成的最大堆进行该处理，以此类推，最终完成堆排序。</p><pre><code class="lang-python">def heap_sorted(heap):    for i in range(1, len(heap)):        heap[0], heap[-i] = heap[-i], heap[0]        adjust_heap(0, n - i,heap)    return heapheapSort=heap_sorted(heap)print(&quot;heapSort:&quot;,heapSort)#输出：heapSort: [1, 2, 3, 4, 5]</code></pre><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Heap" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/pai-xu-by-powcai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/pai-xu-by-powcai-2/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法(Sorting algorithm)</title>
    <link href="/2019/11/16/%E6%8E%92%E5%BA%8F-Sort-%E7%AE%97%E6%B3%95/"/>
    <url>/2019/11/16/%E6%8E%92%E5%BA%8F-Sort-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>十种排序算法的python实现及复杂度分析</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>评价排序算法的几个指标：</p><ul><li><strong>时间复杂度</strong>：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是<script type="math/tex">O(nlog_2n)</script>，坏的性能是<script type="math/tex">O(n^2)</script>。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要<script type="math/tex">O(nlog_2n)</script>。</li><li><strong>空间复杂度</strong>：内存使用量</li><li><strong>稳定性</strong>： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是<strong>稳定</strong>的，当有两个相等键值的纪录<strong>R</strong>和<strong>S</strong>，且在原本的列表中<strong>R</strong>出现在<strong>S</strong>之前，在排序过的列表中<strong>R</strong>也将会是在<strong>S</strong>之前。</li><li><strong>依据排序的方法</strong>：插入、交换、选择、合并等等。  </li></ul><p>本文介绍了以下几种排序，推荐<strong>可视化网站<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo</a></strong>，下文代码都采用数组作为输入。</p><div class="table-container"><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(log_2n)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><script type="math/tex">O(n^{1.3})</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">O(n+k)</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><ul><li>均按从小到大排列 </li><li>k代表数值中的”数字”个数</li><li>n代表数据规模</li><li>m代表数据的最大值减最小值</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>数据分区：（无序区，有序区）。<br>从无序区透过交换找出最大元素放到有序区前端。 </p><p><img src="Bubble_sort_animation.gif" srcset="/img/loading.gif" alt="冒泡排序"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="bubble_sort.gif" srcset="/img/loading.gif" alt="冒泡流程"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bubble_sorted(nums):    size = len(nums)    for i in range(size-1):        for j in range(size-1-i):            if nums[j] &gt; nums[j+1]:                nums[j],nums[j+1]=nums[j+1],nums[j]    return nums</code></pre><p>但是，该算法的最优时间复杂度<a href="https://www.cnblogs.com/melon-h/archive/2012/09/20/2694941.html" target="_blank" rel="noopener">并不是O(n)，而是<script type="math/tex">O(n^2)</script></a>。需改写才能实现最优理想状态：</p><pre><code class="lang-python">def bubble_sorted(nums):    size = len(nums)    for i in range(size-1):        didSwap=False        for j in range(size-1-i):            if nums[j] &gt; nums[j+1]:                nums[j],nums[j+1]=nums[j+1],nums[j]                didSwap=True        if didSwap==False:            return    return nums</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数据分区：（有序区，无序区）。<br/>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 </p><p> <img src="Selection_sort_animation.gif" srcset="/img/loading.gif" alt="选择排序"></p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ol><p><img src="selection_sort.gif" srcset="/img/loading.gif" alt="选择流程"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def selection_sorted(nums):    size = len(nums)    for i in range(size-1):        min_index = i        for j in range(i, size):            if nums[j] &lt; nums[min_index]:               min_index = j        nums[i], nums[min_index] = nums[min_index], nums[i]    return nums</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>数据分区：（有序区，无序区）。<br/>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 </p><p><img src="Insertion_sort_animation.gif" srcset="/img/loading.gif" alt="插入排序"></p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><p><img src="insertion_sort.gif" srcset="/img/loading.gif" alt="插入流程"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def insertion_sorted(nums):    size = len(nums)    for i in range(1,size):        cur_num=nums[i]        pre_index=i-1        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:            nums[pre_index+1]=nums[pre_index]            pre_index-=1        nums[pre_index+1]=cur_num    return nums</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>数据分区：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。 <a href="https://lil-q.github.io/2019/11/17/%E5%A0%86-heap/">关于堆</a></p><p><img src="Sorting_heapsort_anim.gif" srcset="/img/loading.gif" alt="heap"></p><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol><li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def heap_sorted(nums):    # 调整最大堆             def adjust_heap(idx, max_len):        left = 2 * idx + 1        right = 2 * idx + 2        max_loc = idx        if left &lt; max_len and nums[max_loc] &lt; nums[left]:            max_loc = left        if right &lt; max_len and nums[max_loc] &lt; nums[right]:            max_loc = right        if max_loc != idx:            nums[idx], nums[max_loc] = nums[max_loc], nums[idx]            adjust_heap(max_loc, max_len)      # 建堆    n = len(nums)    for i in range(n // 2 - 1, -1, -1):        adjust_heap(i, n)    # 排序    for i in range(1, n):        nums[0], nums[-i] = nums[-i], nums[0]        adjust_heap(0, n - i)    return nums</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  </p><p><img src="Merge_sort_animation2.gif" srcset="/img/loading.gif" alt="merge"></p><h3 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h3><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><p><img src="merge_sort.gif" srcset="/img/loading.gif" alt="mergef"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="递归法（Top-down）："><a href="#递归法（Top-down）：" class="headerlink" title="递归法（Top-down）："></a>递归法（Top-down）：</h4><pre><code class="lang-python">def merge(left, right):    result = []    while left and right:        if left[0] &lt;= right[0]:            result.append(left.pop(0))        else:            result.append(right.pop(0))    if left:        result += left    if right:        result += right    return resultdef merge_sort(L):    if len(L) &lt;= 1:        return L    mid = len(L) // 2    left = L[:mid]    right = L[mid:]    left = merge_sort(left)    right = merge_sort(right)    return merge(left, right)</code></pre><p><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44223225" target="_blank" rel="noopener">时间复杂度是O(nlogn)，归并的空间复杂度为临时的数组和递归时压入栈的数据占用的空间：n + logn，所以空间复杂度为: O(n)</a> 。</p><h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>重写merge()，实现O(1)</p><pre><code class="lang-python">def merge_iter(nums,l1,l2,r2):    r1=l2-1    while r1&gt;=l1 and r2&gt;=l2:        if nums[r1]&gt;nums[r2]:            tmp=nums[r2] # 暂存较小值            nums[r2]=nums[r1]            tmp_r1=r1-1             # 将前半数组的大于tmp的值后移一个单位            while nums[tmp_r1]&gt;tmp and tmp_r1&gt;=l1:                 nums[tmp_r1+1]=nums[tmp_r1]                tmp_r1-=1            nums[tmp_r1+1]=tmp        r2-=1</code></pre><p>这里参考了<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">leetcode 88.合并两个有序数组</a>，采用双指针从后往前合并两个有序数组（其实也就是一个数组切片的前一半和后一半），实现了空间复杂度O(1)。</p><p><img src="merge.jpg" srcset="/img/loading.gif" alt="merge"></p><p><strong>方法一：使用生成器</strong></p><pre><code class="lang-python"># 生成器产生2的幂def powerOfTwo(max):    x=1    while x&lt;=max:        yield x        x*=2# 方法一：用生成器产生1，2，4，8...def merge_sorted_iter(nums):    sortedList=[]    n=len(nums)    for i in powerOfTwo(n):         for j in range(0,n,i*2):             merge_iter(nums,j,min(j+i,n-1),min(j+2*i-1,n-1))    return nums</code></pre><p><strong>方法二：使用位运算</strong></p><pre><code class="lang-python"># 方法二：用位操作产生1，2，4，8...def msi(nums):    length = len(nums)    step = 1    # 步长为1,2,4,8，...，一直合并下去    while step &lt;= length:        offset = step &lt;&lt; 1        for index in range(0, length, offset):            merge_iter(nums, index, min(index+step, length-1), min(index+offset-1, length-1))        step = offset</code></pre><p><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">时间复杂度是<script type="math/tex">O(nlog^2n)</script>,空间复杂度为: O(1)</a>。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>数据分区：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 </p><p><img src="Sorting_quicksort_anim.gif" srcset="/img/loading.gif" alt="quick"></p><h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><img src="quick_sorted.gif" srcset="/img/loading.gif" alt="quicks"></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">import randomdef quick_sorted(nums):    if len(nums) &lt;= 1:        return nums    left, right, mid = [], [], []    pivot = random.choice(nums)    for num in nums:        if num == pivot:            mid.append(num)        elif num &lt; pivot:            left.append(num)        else:            right.append(num)    return quick_sorted(left) + mid + quick_sorted(right)</code></pre><p>需要<script type="math/tex">{\Omega (n)}</script>的额外存储空间，也就跟归并排序一样不好。额外需要的存储空间，在实际实现时，也会极度影响速度和缓存的性能 。下面是原地排序的代码， <a href="[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#Python%E5%8E%9F%E5%9C%B0%E6%8E%92%E5%BA%8F%E7%89%88%E6%9C%AC](https://zh.wikipedia.org/wiki/快速排序#Python原地排序版本">平均可以达到<script type="math/tex">O(\log n)</script>的空间复杂度</a> )。 </p><pre><code class="lang-python">def quick_sorted_inp(nums, first, last):    if first &gt;= last:        return    mid_value = nums[first]    low = first    high = last    while low &lt; high:        while low &lt; high and nums[high] &gt;= mid_value:            high -= 1        nums[low] = nums[high]        while low &lt; high and nums[low] &lt; mid_value:            low += 1        nums[high] = nums[low]    nums[low] = mid_value    quick_sorted_inp(nums, first, low-1)    quick_sorted_inp(nums, low+1, last)</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><blockquote><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ol></blockquote><p><img src="Sorting_shellsort_anim.gif" srcset="/img/loading.gif" alt="shell"></p><h3 id="流程-6"><a href="#流程-6" class="headerlink" title="流程"></a>流程</h3><ol><li>选择一个增量序列<script type="math/tex">t_1</script>，<script type="math/tex">t_2</script>，…，<script type="math/tex">t_k</script>，其中<script type="math/tex">t_i</script>&gt;<script type="math/tex">t_j</script>，<script type="math/tex">t_k</script>=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量<script type="math/tex">t_i</script>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def shell_sorted(nums):    n = len(nums)    # 初始步長，理论上只要最终步长为1任何步长序列都可以工作    gap = n // 2    while gap &gt; 0:        for i in range(gap, n):            # 每个步長進行插入排序            temp = nums[i]            j = i            # 插入排序            while j &gt;= gap and nums[j - gap] &gt; temp:                nums[j] = nums[j - gap]                j -= gap            nums[j] = temp        # 得到新的步長        gap = gap // 2    return nums</code></pre><p>实际上使用1，2，4，8…的增量序列有时会在gap=1时浪费很多时间，[Mark Allen Weiss]指出，最好的增量序列是 Sedgewick提出的 (1, 5, 19, 41, 109,…)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。<a href="https://blog.csdn.net/u013630349/article/details/48250109" target="_blank" rel="noopener">使用 Sedgewick增量 的希尔排序的完整C语言程序</a></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="流程-7"><a href="#流程-7" class="headerlink" title="流程"></a>流程</h3><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><p><img src="counting_sorted.gif" srcset="/img/loading.gif" alt="countingsort"></p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def counting_sorted(nums):    # 计数排序针对非负整数，初始化最大值为-1，也可以设为nums[0]    maxValue=-1    for num in nums:        if num&gt;maxValue:            maxValue=num    bucket = [0]*(maxValue+1)    for num in nums:        bucket[num]+=1    index=0    for i in range(len(bucket)):        while bucket[i]&gt;0:            nums[index] = i            index+=1            bucket[i]-=1    return nums</code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="流程-8"><a href="#流程-8" class="headerlink" title="流程"></a>流程</h3><ol><li>取得数组中的最大数，并取得位数；</li><li>从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><p><img src="radix_sorted.gif" srcset="/img/loading.gif" alt="radix"></p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def radix_sorted(nums):    # 基数排序针对非负整数，初始化最大值为-1,也可以设为nums[0]    maxValue=-1    for num in nums:        if num&gt;maxValue:            maxValue=num     # 求最高位数n    n=len(str(maxValue))    # 进行n次排序    for k in range(n):               s=[[] for i in range(10)]        for i in nums:            s[i//(10**k)%10].append(i)        nums=[a for b in s for a in b]    return nums</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="流程-9"><a href="#流程-9" class="headerlink" title="流程"></a>流程</h3><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol><p><img src="Bucket_sort_1.svg.png" srcset="/img/loading.gif" alt="bucket1"></p><p><img src="Bucket_sort_2.svg.png" srcset="/img/loading.gif" alt="bucket2"></p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bucket_sorted(nums):    if not nums:return nums    maxValue=nums[0]    minValue=nums[0]    for num in nums:        if num&gt;maxValue:            maxValue=num         elif num&lt;minValue:            minValue=num    # 将数据映射到桶中    bucketSize=100 # 设定桶的大小    bucketCount=(maxValue-minValue)//bucketSize+1 # 计算桶的数量    buckets=[[] for _ in range(bucketCount)]    for num in nums:        buckets[(num-minValue)//bucketSize].append(num)    # 对桶内排序，这里使用插入排序，也可以递归桶排序。    res=[]    for k in buckets:               res=res+insertion_sorted(k)    return res# 插入排序def insertion_sorted(nums):    size = len(nums)    for i in range(1,size):        cur_num=nums[i]        pre_index=i-1        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:            nums[pre_index+1]=nums[pre_index]            pre_index-=1        nums[pre_index+1]=cur_num    return nums</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桶排序、基数排序和计数排序都属于非比较类排序，其中计数排序和基数排序都用到了桶排序的思想。计数排序一共分了0，1，2…maxValue一共maxValue+1个桶，每个桶表示一个数；而基数排序则分了十个桶，从第一位开始递归桶排序。冒泡排序，选择排序，插入排序都是比较两个数然后交换。堆排序，归并排序，快速排序则是运用了分治的思想。</p><p><a href="https://github.com/lil-q/sorting-algorithm-python" target="_blank" rel="noopener"><strong>完整代码</strong></a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a> </li><li><a href="https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/数据结构与算法.md" target="_blank" rel="noopener">https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md</a> </li><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a> </li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
