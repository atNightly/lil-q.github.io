<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>查并集题解</title>
    <link href="/2020/04/20/%E6%9F%A5%E5%B9%B6%E9%9B%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/04/20/%E6%9F%A5%E5%B9%B6%E9%9B%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>查并集的实践之路</p><a id="more"></a><p>查并集的进化之路在<a href="[https://lil-q.github.io/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/](https://lil-q.github.io/2020/01/02/查并集-union-find-algorithm/">这里</a>)。</p><h1 id="leetcode-200-岛屿数量"><a href="#leetcode-200-岛屿数量" class="headerlink" title="leetcode 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode 200. 岛屿数量</a></h1><p><strong>解法一：</strong>查并集</p><pre><code class="lang-java">class Solution {    int[] parent;    public int numIslands(char[][] grid) {        if (grid == null || grid.length == 0) return 0;        int rows = grid.length;        int cols = grid[0].length;        int count = rows * cols;        parent = new int[rows * cols];        Arrays.fill(parent, -1);        for (int i = 0; i &lt; rows; i++) {            for (int j = 0; j &lt; cols; j++) {                if (grid[i][j] == &#39;0&#39;) {                    count--;                    continue;                }                grid[i][j] = 0; // 可以剪枝                int index = i * cols + j;                if (j &gt; 0 &amp;&amp; grid[i][j - 1] == &#39;1&#39;) count -= union(index, index - 1);                if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] == &#39;1&#39;) count -= union(index, index + 1);                if (i &gt; 0 &amp;&amp; grid[i - 1][j] == &#39;1&#39;) count -= union(index, index - cols);                if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] == &#39;1&#39;) count -= union(index, index + cols);            }        }         return count;    }    public int find(int i) {        if (parent[i] == -1) parent[i] = i;        while (i != parent[i]) { // 路径压缩            parent[i] = parent[parent[i]];            i = parent[i];        }        return i;    }    public int union(int i, int j) {        int root1 = find(i);        int root2 = find(j);        if (root1 != root2) {            parent[root1] = root2;            return 1;        }        return 0;    }}</code></pre><p><strong>解法二：</strong>DFS</p><pre><code class="lang-java">class Solution {    int rows;    int cols;    public int numIslands(char[][] grid) {        if (grid == null || grid.length == 0) return 0;        rows = grid.length;        cols = grid[0].length;        int count = 0;        for (int i = 0; i &lt; rows; i++) {            for (int j = 0; j &lt; cols; j++) {                if (grid[i][j] == &#39;1&#39;) {                    count++;                    dfs(i, j, grid);                }            }        }         return count;    }    public void dfs(int i, int j, char[][] grid) {        grid[i][j] = 0;        if (j &gt; 0 &amp;&amp; grid[i][j - 1] == &#39;1&#39;) dfs(i, j - 1, grid);        if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] == &#39;1&#39;) dfs(i, j + 1, grid);        if (i &gt; 0 &amp;&amp; grid[i - 1][j] == &#39;1&#39;) dfs(i - 1, j, grid);        if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] == &#39;1&#39;) dfs(i + 1, j, grid);    }}</code></pre><p><strong>解法三：</strong>BFS</p><pre><code class="lang-java">class Solution {    public int numIslands(char[][] grid) {        if (grid == null || grid.length == 0) return 0;        int nr = grid.length;        int nc = grid[0].length;        int count = 0;        Queue&lt;Integer&gt; neighbors = new LinkedList&lt;&gt;();        for (int r = 0; r &lt; nr; ++r) {            for (int c = 0; c &lt; nc; ++c) {                if (grid[r][c] == &#39;1&#39;) {                    count++;                    grid[r][c] = &#39;0&#39;;                    neighbors.add(r * nc + c);                    while (!neighbors.isEmpty()) {                        int id = neighbors.remove();                        int row = id / nc;                        int col = id % nc;                        if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == &#39;1&#39;) {                            neighbors.add((row-1) * nc + col);                            grid[row-1][col] = &#39;0&#39;;                        }                        if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == &#39;1&#39;) {                            neighbors.add((row+1) * nc + col);                            grid[row+1][col] = &#39;0&#39;;                        }                        if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == &#39;1&#39;) {                            neighbors.add(row * nc + col-1);                            grid[row][col-1] = &#39;0&#39;;                        }                        if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == &#39;1&#39;) {                            neighbors.add(row * nc + col+1);                            grid[row][col+1] = &#39;0&#39;;                        }                    }                }            }        }        return count;    }}</code></pre><h1 id="leetcode-547-朋友圈"><a href="#leetcode-547-朋友圈" class="headerlink" title="leetcode 547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">leetcode 547. 朋友圈</a></h1><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果<code>M[i][j] = 1</code>，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。</code></pre><p><strong>解法一：</strong>查并集</p><pre><code class="lang-java">class Solution {    int[] parent;    public int findCircleNum(int[][] M) {        parent = new int[M.length];        for (int i = 0; i &lt; parent.length; i++) parent[i] = i; // 初始化        for (int i = 0; i &lt; M.length; i++) {            for (int j = i + 1; j &lt; M.length; j++) {                if (M[i][j] == 1) union(i, j);            }        }        int count = 0;        for (int i = 0; i &lt; parent.length; i++) {            if (parent[i] == i) count++;        }        return count;    }    public int find(int i) {        while (parent[i] != i) { // 路径压缩            parent[i] = parent[parent[i]];            i = parent[i];        }        return i;    }    public void union(int i, int j) {        int f1 = find(i);        int f2 = find(j);        if (f1 != f2) {            parent[f1] = f2;        }    }}</code></pre><p><strong>解法二：</strong>DFS</p><pre><code class="lang-java">public class Solution {    public void dfs(int[][] M, int i) {        for (int j = 0; j &lt; M.length; j++) {            if (M[i][j] == 1 &amp;&amp; M[j][j] == 1) { // 利用M[i][i]代替visited                M[j][j] = 0;                dfs(M, j);            }        }    }    public int findCircleNum(int[][] M) {        int count = 0;        for (int i = 0; i &lt; M.length; i++) {            if (M[i][i] == 1) {                dfs(M, i);                count++;            }        }        return count;    }}</code></pre><p><strong>解法三：</strong>BFS</p><pre><code class="lang-java">class Solution {    public int findCircleNum(int[][] M) {        int count = 0;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; M.length; i++) {            if (M[i][i] == 1) {                count++;                queue.add(i);                while (queue.size() != 0) {                    int k = queue.remove();                    for (int j = 0; j &lt; M.length; j++) {                        if (M[k][j] == 1 &amp;&amp; M[j][j] == 1) {                            M[j][j] = 0;                            queue.add(j);                        }                    }                }            }        }        return count;     }}</code></pre><h1 id="leetcode-684-冗余连接"><a href="#leetcode-684-冗余连接" class="headerlink" title="leetcode 684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">leetcode 684. 冗余连接</a></h1><p><strong>示例：</strong></p><pre><code class="lang-txt">输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:  1 / \2 - 3</code></pre><p>可以证明最早出现的已经<code>union</code>的<code>pair</code>即是解。</p><pre><code class="lang-java">class Solution {    int[] parent;    public int[] findRedundantConnection(int[][] edges) {        int N = edges.length;        parent = new int[N + 1];        for (int i = 1; i &lt;= N; i++) parent[i] = i;        for (int[] edge : edges) {            if (!union(edge[0], edge[1])) return edge;        }        return new int[0];    }    public int find(int i) {        while(parent[i] != i) {            parent[i] = parent[parent[i]];            i = parent[i];        }        return i;    }    public boolean union(int i, int j) {        int f1 = find(i);        int f2 = find(j);        if (f1 != f2) {            parent[f1] = f2;            return true;        }        return false;    }}</code></pre><h1 id="leetcode-765-情侣牵手"><a href="#leetcode-765-情侣牵手" class="headerlink" title="leetcode 765. 情侣牵手"></a><a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">leetcode 765. 情侣牵手</a></h1><p>先给出贪心算法，每次合理的交换只能促成一对或者两对，这个数字是一定的，所以顺序遍历，每次都交换即可。利用数组储存位置信息可以在时间复杂度 <script type="math/tex">O(N)</script> 内解决问题。</p><pre><code class="lang-java">class Solution {    public int minSwapsCouples(int[] row) {        int[] site = new int[row.length];        for (int i = 0; i &lt; row.length; i++) site[row[i]] = i;        int count = 0;        for (int i = 0; i &lt; row.length; i += 2) {            if (row[i] == (row[i + 1] ^ 1)) continue;            count++;            int s = site[row[i] ^ 1];            row[s] = row[i + 1];            site[row[i + 1]] = s;        }        return count;    }}</code></pre><p>利用查并集解题的关键在于把相邻的两个位置看出一组（官方题解叫做<a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/qing-lu-qian-shou-by-leetcode/" target="_blank" rel="noopener">沙发</a>），每有一个连通域，交换次数就减一。</p><pre><code class="lang-java">class Solution {    int[] parent;    public int minSwapsCouples(int[] row) {        int n = row.length;        int m = n / 2;        parent = new int[m];        for (int i = 0; i &lt; m; i++) parent[i] = i;        for (int i = 0; i &lt; n; i += 2) {            union(row[i] / 2, row[i + 1] / 2);        }        int count = m;        for (int i = 0; i &lt; m; i++) {            if (parent[i] == i) count -= 1; // 每有一个连通域减一        }        return count;    }    public int find(int i) {        while (parent[i] != i) {            parent[i] = parent[parent[i]];            i = parent[i];        }        return i;    }    public void union(int i, int j) {        int f1 = find(i);        int f2 = find(j);        if (f1 != f2) {            parent[f2] = f1;        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>查并集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2020/04/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/04/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>“不如我们由头来过”</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>动态规划</strong>（Dynamic programming，DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化</strong>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h1 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h1><ol><li><strong>最优子结构性质：</strong>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li><li><strong>无后效性：</strong>子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li><li><strong>子问题重叠性质：</strong>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li></ol><h1 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h1><h2 id="leetcode-300-最长上升子序列"><a href="#leetcode-300-最长上升子序列" class="headerlink" title="leetcode 300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode 300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度，时间复杂度降低到 <script type="math/tex">O(N\log N)</script> 。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</code></pre><p><strong>状态转移：</strong>求解长度为 n 的序列，需要知道前 n - 1 个序列所构成的所有子序列，如果序列结尾小于第 n 个数，则加上第 n 个数 <code>num</code> 构成新的子序列。这显然很复杂，可以根据贪心思想优化。由于这题求的是最长上升子序列，又因为向子序列添加数字只和末尾数字有关，所以对于每一个可能的子序列长度，只需要保留所有该长度序列的末尾数字中最小的那个数字即可，我们用 <code>tails</code> 保存这个信息。状态转移被优化为找到 <code>tails</code> 中所有满足 <code>tails[i] &lt; num &lt; tails[i + 1]</code>的情况，并将 <code>tails[i + 1]</code>替换为 <code>num</code>。可以证明 <code>tails</code>是递增的，所以这个数是唯一的。</p><p><strong>二分查找：</strong>题目要求时间复杂度在 <script type="math/tex">O(N\log N)</script> ，所以状态转移时查找第一个大于 <code>num</code>的数采用二分查找。</p><pre><code class="lang-java">class Solution {    public int lengthOfLIS(int[] nums) {        int[] tails = new int[nums.length];        int res = 0; // 记录右边界        for (int num : nums) {            // 二分法找第一个大于num的值            int i = 0, j = res;            while (i &lt; j) {                int mid = (i + j) / 2 ;                if (tails[mid] &lt; num) i = mid + 1; // 摒弃小于num的区间，包括mid                else j = mid; // 保留大于num的区间，但保留mid            }            tails[i] = num;            // 当所有数都小于num时，i会停留在res，此时需要更新边界            if (i == res) res++;         }        return res;    }}</code></pre><h2 id="leetcode-354-俄罗斯套娃信封问题"><a href="#leetcode-354-俄罗斯套娃信封问题" class="headerlink" title="leetcode 354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">leetcode 354. 俄罗斯套娃信封问题</a></h2><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><p>通过对信封排序，可以把该问题简化为最长上升子序列问题。</p><pre><code class="lang-java">class Solution {    public int maxEnvelopes(int[][] envelopes) {        if (envelopes.length == 0) return 0;        int size = envelopes.length;        // 想要对信封根据w排序，当w相同时，h按照降序排列，这样可以保证相同w的信封不能装合。        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() {            public int compare(int[] env1, int[] env2) {                if (env1[0] == env2[0]) {                    return env2[1] - env1[1]; // 降序                } else {                    return env1[0] - env2[0]; // 升序                }            }        });        int[] hs = new int[size];        for (int i = 0; i &lt; size; i++) hs[i] = envelopes[i][1];        return getMax(hs);    }    // 与上一题相同    public int getMax(int[] nums) {        int[] dp = new int[nums.length];        int res = 0;        for (int num : nums) {            int i = 0, j = res;            while (i &lt; j) {                int mid = (i + j) / 2;                if (dp[mid] &lt; num) i = mid + 1;                else j = mid;            }            dp[i] = num;            if (i == res) res++;        }        return res;    }}</code></pre><h2 id="leetcode-1143-最长公共子序列"><a href="#leetcode-1143-最长公共子序列" class="headerlink" title="leetcode 1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">leetcode 1143. 最长公共子序列</a></h2><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。若这两个字符串没有公共子序列，则返回 0。 </p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</code></pre><p>这里可以将二维 dp 转化为一维 dp ，但需要记录<code>dp[i - 1][j - 1]</code>。</p><pre><code class="lang-java">class Solution {    public int longestCommonSubsequence(String text1, String text2) {        int[] dp = new int[text2.length() + 1];        for (int i = text1.length() - 1; i &gt;= 0; i--) {            int pre = 0; // pre用于记录下一次循环dp[i - 1][j - 1]，所以初始化为0            for (int j = text2.length() - 1; j &gt;= 0; j--) {                int tmp = dp[j];                if (text1.charAt(i) == text2.charAt(j)) dp[j] = pre + 1;                else dp[j] = Math.max(dp[j], dp[j + 1]);                pre = tmp;            }        }        return dp[0];    }}</code></pre><h1 id="最优决策"><a href="#最优决策" class="headerlink" title="最优决策"></a>最优决策</h1><h2 id="leetcode-887-鸡蛋掉落"><a href="#leetcode-887-鸡蛋掉落" class="headerlink" title="leetcode 887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">leetcode 887. 鸡蛋掉落</a></h2><p>题目较复杂，请参考<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">官方题解</a>。使用二维dp的基础做法：</p><pre><code class="lang-java">class Solution {    public int superEggDrop(int K, int N) {        int[][] dp = new int[K + 1][N + 1];        for (int i = 1; i &lt;= N; i++) dp[1][i] = i; // 一个鸡蛋的base case        for (int i = 1; i &lt;= K; i++) dp[i][1] = 1; // 一层楼的base case        // dp        for (int i = 2; i &lt;= K; i++) {            for (int j = 2; j &lt;= N; j++) {                int x = 1, y = j;xx                while (x + 1 &lt; y) { // 找到dp[i - 1][x - 1]和dp[i][j - x]相交点两侧的整数解                    int mid = (x + y) / 2;                    if (dp[i - 1][mid - 1] &gt; dp[i][j - mid]) y = mid; // 注意                    else x = mid; // 注意                }                dp[i][j] = 1 + Math.min(Math.max(dp[i - 1][x - 1], dp[i][j - x]),                                        Math.max(dp[i - 1][y - 1], dp[i][j - y]));              }        }        return dp[K][N];    }}</code></pre><p>利用决策单调性并将二维dp简化为线性dp：</p><pre><code class="lang-java">class Solution {    public int superEggDrop(int K, int N) {        int[] dp = new int[N + 1];        for (int i = 1; i &lt;= N; i++) dp[i] = i; // 一个鸡蛋的base case        // dp        for (int i = 2; i &lt;= K; i++) {            int[] dp2 = new int[N + 1]; // 建新的数组记录            int x = 1; // 根据决策单调性初始化一个对于下一个嵌套循环的全局变量            for (int j = 1; j &lt;= N; j++) {                while (x &lt; j &amp;&amp; Math.max(dp[x - 1], dp2[j - x])                                 &gt; Math.max(dp[x], dp2[j - x - 1])) x++;                dp2[j] = 1 + Math.max(dp[x - 1], dp2[j - x]);            }            dp = dp2;        }        return dp[N];    }}</code></pre><h2 id="leetcode-188-买卖股票的最佳时机-IV"><a href="#leetcode-188-买卖股票的最佳时机-IV" class="headerlink" title="leetcode 188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">leetcode 188. 买卖股票的最佳时机 IV</a></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算所能获取的最大利润。最多可以完成 k 笔交易。不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p>股票类问题都可以用两个二维 dp 来解决，一个记录 sold 状态，另一个记录 hold 状态。dp 第一个维度对应天数，第二个维度对应第几次买卖操作，当操作次数不足时，后面会重复最后的操作。由于当天的情况只与前一天有关，第一个维度可以压缩至常量。当买卖次数不限时，只关心最优解，前若干次操作可以不记录，第二个维度可以压缩至常量。</p><pre><code class="lang-java">class Solution {    public int maxProfit(int k, int[] prices) {        // k 大于天数的一半时，用简单的贪心算法即可，也简化了很多重复运算        if(k &gt;= prices.length / 2){            int profit = 0;            for(int i = 1; i &lt; prices.length; i++){                if(prices[i] &gt; prices[i-1]){                    profit += prices[i] - prices[i-1];                }            }            return profit;        }        // 初始化        int[] sold = new int[k + 1];        int[] hold = new int[k + 1];        for (int i = 0; i &lt;= k; i++) hold[i] = Integer.MIN_VALUE;        // dp        for (int price : prices) {            for (int i = 1; i &lt;= k; i++) {                sold[i] = Math.max(sold[i], hold[i] + price);                hold[i] = Math.max(hold[i], sold[i - 1] - price);              }        }        return sold[k];    }}</code></pre><h2 id="leetcode-312-戳气球"><a href="#leetcode-312-戳气球" class="headerlink" title="leetcode 312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">leetcode 312. 戳气球</a></h2><p>这题正向思维会很难解，我们在决策时可以不考虑哪个先戳破，而是考虑哪个最后戳破。这样就可以用分治算法简化运算。递归不难实现，迭代时需要先把较短数组的子问题解决，再解决包含这些子问题的问题。</p><pre><code class="lang-java">// 自顶向下的递归class Solution {    int[][] memo;    public int maxCoins(int[] nums) {        int n = nums.length + 2;        int[] nums2 = new int[n];        for (int i = 1; i &lt; n - 1; i++) nums2[i] = nums[i - 1];        nums2[0] = nums2[n - 1] = 1;        memo = new int[n][n];        return dp(0, n - 1, nums2);    }    public int dp(int l, int r, int[] nums) {        if (l &gt; r - 2) return 0;        if (memo[l][r] &gt; 0) return memo[l][r];         for (int i = l + 1; i &lt; r; i++) {            memo[l][r] = Math.max(memo[l][r],            nums[i] * nums[l] * nums[r] + dp(l, i, nums) + dp(i, r, nums));        }        return memo[l][r];    }}// 自底向上的迭代class Solution {    public int maxCoins(int[] nums) {        int n = nums.length + 2;        int[] nums2 = new int[n];        for (int i = 1; i &lt; n - 1; i++) nums2[i] = nums[i - 1];        nums2[0] = nums2[n - 1] = 1;        int[][] dp = new int[n][n];        for (int l = n - 2; l &gt;= 0; l--) { // 注意            for (int r = l + 2; r &lt; n; r++) { // 注意                for (int i = l + 1; i &lt; r; i++){                    dp[l][r] = Math.max(dp[l][r],                     nums2[i] * nums2[l] * nums2[r] + dp[l][i] + dp[i][r]);                }            }        }        return dp[0][n - 1];    }}</code></pre><p>类似的扫描方式还有<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">leetcode 516. 最长回文子序列</a>：</p><pre><code class="lang-java">class Solution {    public int longestPalindromeSubseq(String s) {        int n = s.length();        int[][] dp = new int[n][n];        for (int l = n - 1; l &gt;= 0; l--) {            for (int r = l; r &lt; n; r++) {                if (l == r) dp[l][r] = 1;                else if (s.charAt(l) == s.charAt(r)) dp[l][r] = dp[l + 1][r - 1] + 2;                else dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);            }        }        return dp[0][n - 1];    }}</code></pre><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/Adjustments.plist" alt=""></p><p>下面的这题可以展示另一种遍历方式——<a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">leetcode 1039. 多边形三角剖分的最低得分</a>：</p><pre><code class="lang-java">class Solution {    public int minScoreTriangulation(int[] A) {        int n = A.length;        int[][] dp = new int[n][n];        for (int len = 2; len &lt; n; len++) { // 长度逐渐变长            for (int l = 0; l &lt; n - len; l++) { // 左端由上至下                int r = l + len;                dp[l][r] = Integer.MAX_VALUE;                for (int i = l + 1; i &lt; r; i++) {                    dp[l][r] = Math.min(dp[l][r], dp[l][i] + dp[i][r] + A[l] * A[i] * A[r]);                }            }        }        return dp[0][n - 1];    }}</code></pre><h2 id="leetcode-664-奇怪的打印机"><a href="#leetcode-664-奇怪的打印机" class="headerlink" title="leetcode 664. 奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">leetcode 664. 奇怪的打印机</a></h2><p>有台奇怪的打印机有以下两个特殊要求：</p><ul><li>打印机每次只能打印同一个字符序列。</li><li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li></ul><pre><code class="lang-txt">输入: &quot;aaabbb&quot;输出: 2解释: 首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</code></pre><p>给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。</p><pre><code class="lang-java">class Solution {    int[][] memo;    public int strangePrinter(String s) {        int n = s.length();        memo = new int[n][n];        return dp(0, n - 1, s);    }    public int dp(int l, int r, String s) {        if (l &gt; r) return 0;        if (memo[l][r] == 0) {            int ans = dp(l + 1, r, s) + 1; // 首字符是单独打印的            for (int i = l + 1; i &lt;= r; i++)                // [l,i]是一起打印的，s[i]打印的次数包含于dp(l, i - 1, s)                if (s.charAt(i) == s.charAt(l))                     ans = Math.min(ans, dp(l, i - 1, s) + dp(i + 1, r, s));            memo[l][r] = ans;        }        return memo[l][r];    }}</code></pre><h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p>字符串处理基本都能用动态规划来做。</p><h2 id="leetcode-10-正则表达式匹配"><a href="#leetcode-10-正则表达式匹配" class="headerlink" title="leetcode 10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">leetcode 10. 正则表达式匹配</a></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><pre><code class="lang-txt">&#39;.&#39; 匹配任意单个字符&#39;*&#39; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。</code></pre><p>这里采用从后往前匹配的方式，对于空字符串的匹配结果可以放在二维数组<code>memo</code>的末尾，算法更加清晰。</p><pre><code class="lang-java">// 迭代class Solution {    public boolean isMatch(String s, String p) {        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];        dp[s.length()][p.length()] = true;        for (int i = s.length(); i &gt;= 0; i--) {            for (int j = p.length() - 1; j &gt;= 0; j--) {                boolean first_match = i &lt; s.length()                     &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;);                if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == &#39;*&#39;) {                    dp[i][j] = dp[i][j + 2] || first_match &amp;&amp; dp[i + 1][j];                } else {                    dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1];                }            }        }        return dp[0][0];    }}// 递归class Solution {    int[][] memo;    public boolean isMatch(String s, String p) {        memo = new int[s.length() + 1][p.length() + 1];        return dp(0, 0, s, p);    }    public boolean dp(int i, int j, String s, String p) {        if (memo[i][j] != 0) return memo[i][j] == 1;        boolean ans;        if (j == p.length()) {            ans = i == s.length();        } else {            boolean first_match = i &lt; s.length()                     &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;);            if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == &#39;*&#39;) {                ans = dp(i, j + 2, s, p) || first_match &amp;&amp; dp(i + 1, j, s, p);            } else {                ans = first_match &amp;&amp; dp(i + 1, j + 1, s, p);            }        }        memo[i][j] = ans ? 1 : -1;        return ans;    }}</code></pre><h2 id="leetcode-72-编辑距离"><a href="#leetcode-72-编辑距离" class="headerlink" title="leetcode 72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">leetcode 72. 编辑距离</a></h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例：</strong></p><pre><code class="lang-txt">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p>先用二维 dp 理清思路，之后压缩空间占用。</p><pre><code class="lang-java">class Solution {    public int minDistance(String word1, String word2) {        int len1 = word1.length(), len2 = word2.length();        // 初始化        int[][] dp = new int[len1 + 1][len2 + 1];        for (int i = len1; i &gt;= 0; i--) dp[i][len2] = len1 - i;        for (int j = len2; j &gt;= 0; j--) dp[len1][j] = len2 - j;        // dp        for (int i = len1 - 1; i &gt;= 0; i--) {            for (int j = len2 - 1; j &gt;= 0; j--){                if (word1.charAt(i) == word2.charAt(j)) {                    dp[i][j] = dp[i + 1][j + 1]; // 字符相同时只有一种可能                } else {                    dp[i][j] = Math.min(Math.min(dp[i][j + 1], dp[i + 1][j]),                                        dp[i + 1][j + 1]) + 1;                }            }        }        return dp[0][0];    }}// 一维dpclass Solution {    public int minDistance(String word1, String word2) {        int len1 = word1.length(), len2 = word2.length();        int[] dp = new int[len2 + 1];        for (int j = 0; j &lt;= len2; j++) dp[j] = j;        for (int i = 1; i &lt;= len1; i++) {            int[] dp2 = new int[len2 + 1];            dp2[0] = i;            for (int j = 1; j &lt;= len2; j++){                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {                    dp2[j] = dp[j - 1];                } else {                    dp2[j] = Math.min(Math.min(dp2[j - 1], dp[j]), dp[j - 1]) + 1;                }            }            dp = dp2;        }        return dp[len2];    }}</code></pre><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><a href="https://zh.wikipedia.org/wiki/背包问题" target="_blank" rel="noopener">背包问题</a>作为<a href="https://zh.wikipedia.org/wiki/NP完全" target="_blank" rel="noopener">NP完全</a>问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。 背包问题具有<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><h2 id="AcWing-5-多重背包问题"><a href="#AcWing-5-多重背包问题" class="headerlink" title="AcWing 5 多重背包问题"></a><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">AcWing 5 多重背包问题</a></h2><p>有 <script type="math/tex">N</script> 种物品和一个容量是 <script type="math/tex">V</script> 的背包。第 <script type="math/tex">i</script> 种物品最多有 <script type="math/tex">s_i</script> 件，每件体积是 <script type="math/tex">v_i</script>，价值是 <script type="math/tex">w_i</script>。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大，输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<script type="math/tex">N</script>，<script type="math/tex">V</script>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 <script type="math/tex">N</script> 行，每行三个整数 <script type="math/tex">u</script>、<script type="math/tex">w</script>、<script type="math/tex">s</script>，用空格隔开，分别表示第 <script type="math/tex">i</script> 种物品的体积、价值和数量。</p><pre><code class="lang-txt">输入样例4 51 2 32 4 13 4 34 5 2输出样例：10</code></pre><p>当 <script type="math/tex">s</script> 很大时，单纯使用0-1背包会消耗大量时间，可以使用二进制优化方法。</p><pre><code class="lang-java">import java.util.Scanner;import java.util.*;public class Main {    public static void main(String[] args) {        // 处理输入        Scanner jin = new Scanner(System.in);        int n = jin.nextInt();        int v = jin.nextInt();        // 二进制优化        List&lt;Integer&gt; ulist = new ArrayList();        List&lt;Integer&gt; wlist = new ArrayList();        for (int i = 0; i &lt; n; i++) {            int u = jin.nextInt();            int w = jin.nextInt();            int s = jin.nextInt();            // 二进制优化方法，比如9可以拆分为1、2、4、2，这四个数可以组成1-9的任意数            int k = 1;            while(s &gt; k) {                 ulist.add(u * k);                wlist.add(w * k);                s -= k;                k &lt;&lt;= 1;            }            if (s &gt; 0) {                ulist.add(u * s);                wlist.add(w * s);            }        }        // 动态规划        n = ulist.size();        int[] dp = new int[v + 1];        for (int i = 1; i &lt;= n; i++) {            for (int j = v; j &gt; 0; j--) { // 从后往前遍历，可以重复使用上一轮的数据                if (j &gt;= ulist.get(i - 1))                    dp[j] = Math.max(dp[j], dp[j - ulist.get(i - 1)] + wlist.get(i - 1));                      }        }        System.out.print(dp[v]);    }}</code></pre><h2 id="leetcode-494-目标和"><a href="#leetcode-494-目标和" class="headerlink" title="leetcode 494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">leetcode 494. 目标和</a></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。</code></pre><p>这是背包问题的变种，base case是全减，这时候有一种可能，之后每一个数字可以改成加号或者不改，类似0/1背包。</p><pre><code class="lang-java">class Solution {    public int findTargetSumWays(int[] nums, int S) {        int sum = 0;        for (int num : nums) sum += num;        if (S &gt; sum || S &lt; -sum || (S + sum) % 2 == 1) return 0;        int len = (S + sum) / 2; // 减少一半的空间占用        int[] dp = new int[len + 1];        dp[0] = 1;        for (int i = 0; i &lt; nums.length; i++) {            for (int j = len; j &gt;= nums[i]; j--) {                dp[j] += dp[j - nums[i]];             }        }        return dp[len];    }}</code></pre><h2 id="leetcode-474-一和零"><a href="#leetcode-474-一和零" class="headerlink" title="leetcode 474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">leetcode 474. 一和零</a></h2><p>二维背包，可以想象成一些游戏内的背包，有固定的长和宽。</p><pre><code class="lang-java">class Solution {    public int findMaxForm(String[] strs, int m, int n) {        int[][] dp = new int[m + 1][n + 1]; // 相应的dp数组也为二维        for (String str : strs) {            int zeros = 0, ones = 0;            for (int i = 0; i &lt; str.length(); i++) {                if (str.charAt(i) == &#39;0&#39;) zeros += 1;                else ones += 1;            }            for (int i = m; i &gt;= zeros; i--) {                for (int j = n; j &gt;= ones; j--) {                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);                }            }        }        return dp[m][n];    }}</code></pre><h1 id="树型问题"><a href="#树型问题" class="headerlink" title="树型问题"></a>树型问题</h1><h2 id="leetcode-124-二叉树中的最大路径和"><a href="#leetcode-124-二叉树中的最大路径和" class="headerlink" title="leetcode 124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">leetcode 124. 二叉树中的最大路径和</a></h2><p>给定一个非空二叉树，返回其最大路径和。路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p><strong>示例:</strong></p><pre><code>输入: [1,2,3]   1  / \ 2   3 输出: 6</code></pre><p>利用全局变量记录最大值。</p><pre><code class="lang-java">class Solution {    int max_sum = Integer.MIN_VALUE;    public int maxPathSum(TreeNode root) {        maxGain(root);        return max_sum;    }    public int maxGain(TreeNode root) {        if (root == null) return 0;        int left = Math.max(maxGain(root.left), 0);        int right = Math.max(maxGain(root.right), 0);        max_sum = Math.max(max_sum, root.val + left + right); // 注意        return root.val + Math.max(left, right);    }}</code></pre><h2 id="leetcode-337-打家劫舍-III"><a href="#leetcode-337-打家劫舍-III" class="headerlink" title="leetcode 337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">leetcode 337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例:</strong></p><pre><code>输入: [3,2,3,null,3,null,1] 3/ \2   3 \   \   3   1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</code></pre><p>原地修改可以减少递归次数，<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/java-ji-yi-hua-dphe-yuan-di-xiu-gai-by-lil-q/" target="_blank" rel="noopener">对比</a>：</p><pre><code class="lang-java">class Solution {    public int rob(TreeNode root) {        if(root==null) return 0;        int f = root.val, s = 0; // f: 选取root；s: 不选取root        s += rob(root.left) + rob(root.right); // 只递归子节点，孙子节点由递归内部完成        if(root.left!=null) {            f += root.left.left!=null ? root.left.left.val : 0;            f += root.left.right!=null ? root.left.right.val : 0;        }        if(root.right!=null) {            f += root.right.left!=null ? root.right.left.val : 0;            f += root.right.right!=null ? root.right.right.val : 0;        }        root.val = Math.max(f, s);        return root.val;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2020/04/08/%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/04/08/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种<strong>线性表</strong><a id="more"></a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<strong>指针</strong>(Pointer)。由于不必须按顺序存储，链表在<strong>插入</strong>的时候可以达到<strong>O(1)</strong>的复杂度，比另一种线性表顺序表快得多，但是<strong>查找</strong>一个节点或者访问特定编号的节点则需要<strong>O(n)</strong>的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。</p><p><img src="612px-Singly-linked-list.svg.jpg" alt=""></p><pre><code class="lang-java">// Definition for singly-linked list.public class ListNode {    int val;    ListNode next;    ListNode(int x) { val = x; }}</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表的每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）。</p><p><img src="915px-Doubly-linked-list.svg.jpg" alt=""></p><pre><code class="lang-java">// Definition for Doubly-linked list.public class ListNode {    int val;    ListNode prev;    ListNode next;    ListNode(int x) { val = x; }}</code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>在一个 <strong>循环链表</strong>中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。</p><p>指向整个列表的指针可以被称作<strong>访问指针</strong>。</p><p><img src="525px-Circularly-linked-list.svg.jpg" alt=""></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="leetcode-61-旋转链表"><a href="#leetcode-61-旋转链表" class="headerlink" title="leetcode 61. 旋转链表"></a><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">leetcode 61. 旋转链表</a></h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p>遍历取余。</p><pre><code class="lang-java">class Solution {    public ListNode rotateRight(ListNode head, int k) {        if (head == null) return head;        ListNode dummy = new ListNode(0), tail = dummy;        dummy.next = head;        int size = 0;        while (tail.next != null) {            tail = tail.next;            size += 1;        }        k = k % size;        if (k == 0) return head;        ListNode t = dummy; // new tail        for (int i = 0; i &lt; size - k; i++) {            t = t.next;        }        ListNode h = t.next; // new head        tail.next = head;        t.next = null;        return h;    }}</code></pre><h3 id="leetcode-92-反转链表-II"><a href="#leetcode-92-反转链表-II" class="headerlink" title="leetcode 92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">leetcode 92. 反转链表 II</a></h3><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转（1 ≤ m ≤ n ≤ 链表长度）。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p><strong>解法一：</strong>迭代。</p><pre><code class="lang-java">class Solution {    public ListNode reverseBetween(ListNode head, int m, int n) {        ListNode dummy = new ListNode(0), pre = dummy;        dummy.next = head;        for (int i = 1; i &lt; m; i++) pre = pre.next; // 找到m节点前的节点        ListNode p = pre, c = p.next;        for (int i = 0; i &lt;= n - m; i++) {             ListNode tmp = c.next;            c.next = p;            p = c;            c = tmp;        }        pre.next.next = c;        pre.next = p;        return dummy.next;    }}</code></pre><p><strong>解法二：</strong>递归。</p><pre><code class="lang-java">class Solution {    public ListNode reverseBetween(ListNode head, int m, int n) {        if (m == 1) {            if (n == 1) return head;            ListNode last = reverseBetween(head.next, m, n - 1);            ListNode tmp = head.next.next;            head.next.next = head;            head.next = tmp;            return last;        } else {            head.next = reverseBetween(head.next, m - 1, n - 1);            return head;        }    }}</code></pre><h3 id="leetcode-25-K-个一组翻转链表"><a href="#leetcode-25-K-个一组翻转链表" class="headerlink" title="leetcode 25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">leetcode 25. K 个一组翻转链表</a></h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。<em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>示例：</strong></p><pre><code class="lang-txt">给你这个链表：`1-&gt;2-&gt;3-&gt;4-&gt;5`当 *k* = 2 时，应当返回: `2-&gt;1-&gt;4-&gt;3-&gt;5`当 *k* = 3 时，应当返回: `3-&gt;2-&gt;1-&gt;4-&gt;5`</code></pre><p><strong>解法一：</strong>利用快慢指针和迭代。</p><pre><code class="lang-java">class Solution {    public ListNode reverseKGroup(ListNode head, int k) {        ListNode dummy = new ListNode(0), slow = dummy, fast = dummy; // fast以dummy起始        dummy.next = head;        while (true) {            for (int i = 1; i &lt;= k; i++) {                fast = fast.next;                if (fast == null) return dummy.next; // if语句后判            }            ListNode next_head = fast.next;            ListNode tail = slow.next;                 fast.next = null;            slow.next = reverseOne(slow.next);            tail.next = next_head;                   fast = tail;            slow = tail;            }    }    public ListNode reverseOne(ListNode head) {        ListNode pre = null, cur = head;        while (cur != null) {            ListNode tmp = cur.next;            cur.next = pre;            pre = cur;            cur = tmp;        }        return pre;    }}</code></pre><p><strong>解法二：</strong>递归。</p><pre><code class="lang-java">class Solution {    public ListNode reverseKGroup(ListNode head, int k) {        ListNode tail = head, pre = null, cur = head;        for (int i = 1; i &lt;= k; i++) {            if (cur == null) return head;            cur = cur.next;        }        cur = head;        for (int i = 1; i &lt;= k; i++) {            ListNode tmp = cur.next;            cur.next = pre;            pre = cur;            cur = tmp;        }        tail.next = reverseKGroup(cur, k);        return pre;    }}</code></pre><p><strong>解法三：</strong>利用栈。</p><pre><code class="lang-java">class Solution {    public ListNode reverseKGroup(ListNode head, int k) {        Deque&lt;ListNode&gt; stack = new LinkedList&lt;&gt;();        ListNode dummy = new ListNode(0), pre = dummy, cur = head; // cur起始为head        while (true) {            for (int i = 1; i &lt;=k; i++) {                if (cur == null) return dummy.next; // if语句先判                stack.push(cur);                cur = cur.next;            }            while (!stack.isEmpty()) {                pre.next = stack.pop();                pre = pre.next;            }            pre.next = cur;        }    }}</code></pre><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="leetcode-82-删除排序链表中的重复元素-II"><a href="#leetcode-82-删除排序链表中的重复元素-II" class="headerlink" title="leetcode 82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode 82. 删除排序链表中的重复元素 II</a></h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5</code></pre><p>需要注意条件的判断：</p><pre><code class="lang-java">class Solution {    public ListNode deleteDuplicates(ListNode head) {        ListNode dummy = new ListNode(0), slow = dummy, fast = head;        dummy.next = head;        while (fast != null &amp;&amp; fast.next != null) {            if (fast.val == fast.next.val) {                while (fast.next != null &amp;&amp; fast.val == fast.next.val) fast = fast.next;                slow.next = fast.next;            } else {                slow = slow.next;            }            fast = fast.next;        }        return dummy.next;    }}</code></pre><h3 id="leetcode-19-删除链表的倒数第N个节点"><a href="#leetcode-19-删除链表的倒数第N个节点" class="headerlink" title="leetcode 19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode 19. 删除链表的倒数第N个节点</a></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><pre><code class="lang-txt">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p>快慢指针充当了建议队列<code>Queue</code>：</p><pre><code class="lang-java">class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        if (head == null) return null;        Queue&lt;ListNode&gt; queue = new LinkedList&lt;&gt;();        ListNode dummy = new ListNode(0), slow = dummy, fast = head;        dummy.next = head;        for (int i = 0; i &lt; n; i++) fast = fast.next;        while (fast != null) {            slow = slow.next;            fast = fast.next;        }        slow.next = slow.next.next;        return dummy.next;    }}</code></pre><h3 id="leetcode-142-环形链表-II"><a href="#leetcode-142-环形链表-II" class="headerlink" title="leetcode 142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">leetcode 142. 环形链表 II</a></h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p><strong>示例：</strong></p><pre><code class="lang-txt">输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>假设直链表长度为 <em>L</em> ，环链表长度为 <em>C</em> 。利用快慢指针，两指针第一次相遇时慢指针经过 <em>C</em> ，快指针经过 <em>2C</em> 。将快指针移回<code>head</code>，步长改为 1，移动 <em>L</em> 后与移动了 <em>L + C</em> 的慢指针在环形链表入口节点相遇。</p><pre><code class="lang-java">public class Solution {    public ListNode detectCycle(ListNode head) {        ListNode slow = head, fast = head;        while (true) { // 找到第一次相遇点            if (fast == null || fast.next == null) return null;            slow = slow.next;            fast = fast.next.next;            if (slow == fast) break;        }        fast = head;        while (fast != slow) {            slow = slow.next;            fast = fast.next;        }        return fast;    }}</code></pre><p>类似的双指针还有<a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/java-shuang-zhi-zhen-by-lil-q/" target="_blank" rel="noopener">leetcode 234. 回文链表</a>，<a href="https://leetcode-cn.com/problems/partition-list/solution/java-bu-chuang-jian-xin-de-jie-dian-by-lil-q/" target="_blank" rel="noopener">86. 分隔链表</a>。</p><h2 id="多链表处理"><a href="#多链表处理" class="headerlink" title="多链表处理"></a>多链表处理</h2><h3 id="leetcode-2-两数相加"><a href="#leetcode-2-两数相加" class="headerlink" title="leetcode 2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">leetcode 2. 两数相加</a></h3><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><p><strong>示例：</strong></p><pre><code class="lang-txt">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><p>分开处理两个链表节点会简化程序：</p><pre><code class="lang-java">class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        int flag = 0;        ListNode dummy = new ListNode();        ListNode cur = dummy;        while (l1 != null || l2 != null) {            int num1 = l1 == null ? 0 : l1.val;            int num2 = l2 == null ? 0 : l2.val;            cur.next = new ListNode((num1 + num2 + flag) % 10);            flag = (num1 + num2 + flag) / 10;            cur = cur.next;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        }        if (flag == 1) cur.next = new ListNode(1);        return dummy.next;    }}</code></pre><h3 id="leetcode-23-合并K个排序链表"><a href="#leetcode-23-合并K个排序链表" class="headerlink" title="leetcode 23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">leetcode 23. 合并K个排序链表</a></h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>解法一：</strong>利用最小堆原理的优先队列，时间复杂度： <script type="math/tex">O(N\log k)</script> ；空间复杂度：<script type="math/tex">O(k)</script>，用于建立优先队列。</p><pre><code class="lang-java">class Solution {    public ListNode mergeKLists(ListNode[] lists) {        ListNode dummy = new ListNode(0), cur = dummy;        PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);        for (ListNode node : lists) {            if (node != null) pq.add(node);        }        while (!pq.isEmpty()) {            ListNode tmp = pq.remove();            cur.next = tmp;            if (tmp.next != null) pq.add(tmp.next);            cur = cur.next;        }        return dummy.next;    }}</code></pre><p><strong>解法二：</strong>分治，时间复杂度： <script type="math/tex">O(N\log k)</script> ；空间复杂度：<script type="math/tex">O(1)</script>。</p><pre><code class="lang-java">// 自底向上的迭代求解class Solution {    public ListNode mergeKLists(ListNode[] lists) {        if (lists.length == 0) return null;        int size = lists.length;        int k = 1;        while (k &lt; size) {            for (int i = 0; i &lt; size - k; i += 2 * k) {                lists[i] = mergeTwoLists(lists[i], lists[i + k]);            }            k &lt;&lt;= 1; // 利用位运算乘2        }        return lists[0];    }    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode(0), pre = dummy;        while (l1 != null &amp;&amp; l2 != null) {            if (l1.val &lt; l2.val) {                pre.next = l1;                l1 = l1.next;            } else {                pre.next = l2;                l2 = l2.next;            }            pre = pre.next;                   }        pre.next = l1 != null ? l1 : l2;        return dummy.next;    }}// 自顶向下的递归求解class Solution {    public ListNode mergeKLists(ListNode[] lists) {        if (lists.length == 0) return null;        return merge(0, lists.length - 1, lists);    }    public ListNode merge(int l, int r, ListNode[] lists) {        if (l == r) return lists[l];        ListNode l1 = merge(l, (l + r) / 2, lists);        ListNode l2 = merge((l + r) / 2 + 1, r, lists);        return mergeTwoLists(l1, l2);    }    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if (l1 == null) return l2;        if (l2 == null) return l1;        if (l1.val &lt; l2.val) {            l1.next = mergeTwoLists(l1.next, l2);            return l1;        }else{            l2.next = mergeTwoLists(l1, l2.next);            return l2;        }    }}</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="leetcode-148-排序链表"><a href="#leetcode-148-排序链表" class="headerlink" title="leetcode 148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">leetcode 148. 排序链表</a></h3><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><strong>示例 1:</strong></p><pre><code class="lang-txt">输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p>采用归并排序的思想，对排序后的子链表做类似于合并k个排序链表的操作：</p><pre><code class="lang-java">class Solution {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null) return head;        ListNode dummy = new ListNode(0), slow = dummy, fast = head;        dummy.next = head;        while (fast != null &amp;&amp; fast.next != null) {            slow = slow.next;            fast = fast.next.next;        }        ListNode l2 = sortList(slow.next);        slow.next = null;        ListNode l1 = sortList(head);        return merge(l1, l2);    }    public ListNode merge(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode(0), pre = dummy;        while (l1 != null &amp;&amp; l2 != null) {            if (l1.val &lt; l2.val) {                pre.next = l1;                l1 = l1.next;            } else {                pre.next = l2;                l2 = l2.next;            }            pre = pre.next;        }        pre.next = l1 != null ? l1 : l2;        return dummy.next;    }}</code></pre><p>当然，递归的做法并不能满足空间复杂度<script type="math/tex">O(1)</script>的要求，可以利用自底向上的思想和位运算实现迭代算法，类似的题还有<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/java-di-gui-by-lil-q/" target="_blank" rel="noopener">leetcode 109. 有序链表转换二叉搜索树</a>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-I/O</title>
    <link href="/2020/04/04/java%E5%9F%BA%E7%A1%80%E5%85%AD/"/>
    <url>/2020/04/04/java%E5%9F%BA%E7%A1%80%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总—— I/O</p><a id="more"></a><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><ul><li>创建<code>File f = new File(&quot;C:\\Windiws\\...&quot;)</code>对象本身不涉及IO操作，并不会导致任何磁盘操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p><code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>：</p><pre><code class="lang-java">public abstract int read() throws IOException;</code></pre><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>FileInputStream</code>是<code>InputStream</code>的一个子类，能从文件流中读取数据。使用<code>try(resource)</code>可以保证<code>InputStream</code>正确关闭（因为<code>InputStream</code>和<code>OutputStream</code>都实现了<code>java.lang.AutoCloseable</code>接口）。</p><pre><code class="lang-java">public void readFile() throws IOException {    try (InputStream input = new FileInputStream(&quot;src/readme.txt&quot;)) {        int n;        while ((n = input.read()) != -1) {            System.out.println(n);        }    } // 编译器在此自动为我们写入finally并调用close()}</code></pre><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区<code>buffer</code>，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果在读入到缓存区时遇到<code>-1</code>则会跳出循环，下一次调用<code>read()</code>时就会直接读到-1而退出。</p><p>利用缓冲区一次读取多个字节的代码如下：</p><pre><code class="lang-java">public void readFile() throws IOException {    try (InputStream input = new FileInputStream(&quot;src/readme.txt&quot;)) {        // 定义1000个字节大小的缓冲区:        byte[] buffer = new byte[1000];        int n;        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区            System.out.println(&quot;read &quot; + n + &quot; bytes.&quot;);        }    }}</code></pre><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。因为程序要等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><pre><code class="lang-java">public abstract void write(int b) throws IOException;</code></pre><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。同样，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来一次性写入若干字节：</p><pre><code class="lang-java">public void writeFile() throws IOException {    try (OutputStream output = new FileOutputStream(&quot;out/readme.txt&quot;)) {        output.write(&quot;Hello&quot;.getBytes(&quot;UTF-8&quot;)); // Hello    } // 编译器在此自动为我们写入finally并调用close()}</code></pre><h3 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h3><p><code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。例如聊天软件则需要把缓冲区的内容立刻发送出去。</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre><code class="lang-java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class CopyFile {    public static void main(String[] args) throws IOException {        if (args.length != 2) {            System.err.println(&quot;Usage:\n  java CopyFile.java &lt;source&gt; &lt;target&gt;&quot;);            System.exit(1);        }        copy(args[0], args[1]);    }    static void copy(String source, String target) throws IOException {        try(InputStream input = new FileInputStream(source);                OutputStream output = new FileOutputStream(target)) {            byte[] buffer = new byte[1000];            while (input.read(buffer) != -1) output.write(buffer);        }    }}</code></pre><h2 id="classpath资源"><a href="#classpath资源" class="headerlink" title="classpath资源"></a>classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；<code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；根据classpath读取资源时，如果资源文件不存在，它将返回<code>null</code>，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><pre><code class="lang-java">try (InputStream input = getClass().getResourceAsStream(&quot;/default.properties&quot;)) {    if (input != null) {        // TODO:    }}</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>对象序列化</strong>是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为<strong>反序列化</strong>。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><pre><code class="lang-java">public interface Serializable {}</code></pre><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><pre><code class="lang-java">import java.io.*;import java.util.Arrays;public class Main {    public static void main(String[] args) throws IOException {        // 模拟一个输出文件        ByteArrayOutputStream buffer = new ByteArrayOutputStream();        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {            // 写入int:            output.writeInt(12345);            // 写入String:            output.writeUTF(&quot;Hello&quot;);            // 写入Object:            output.writeObject(Double.valueOf(123.456));        }        System.out.println(Arrays.toString(buffer.toByteArray()));    }}</code></pre><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><pre><code class="lang-java">try (ObjectInputStream input = new ObjectInputStream(...)) {    int n = input.readInt();    String s = input.readUTF();    Double d = (Double) input.readObject();}</code></pre><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><pre><code class="lang-java">public class Person implements Serializable {    private static final long serialVersionUID = 2709425275741743919L;}</code></pre><p>反序列化时，由JVM直接构造出Java对象，<strong>不调用构造方法</strong>，构造方法内部的代码，在反序列化时根本不可能执行。这是存在一定安全隐患的。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="reader"><a href="#reader" class="headerlink" title="reader"></a>reader</h3><p>以上讲到的都是字符流，<code>Reader</code>是Java的IO库提供的另一个输入流接口，是一个字符流，即以<code>char</code>为单位读取，<code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><pre><code class="lang-java">public int read() throws IOException;</code></pre><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~<code>65535</code>。如果已读到末尾，返回<code>-1</code>。</p><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><h3 id="writer"><a href="#writer" class="headerlink" title="writer"></a>writer</h3><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>单个字符的匹配规则如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>A</code></td><td style="text-align:left">指定字符</td><td style="text-align:left"><code>A</code></td></tr><tr><td style="text-align:left"><code>\u548c</code></td><td style="text-align:left">指定Unicode字符</td><td style="text-align:left"><code>和</code></td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">任意字符</td><td style="text-align:left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td></tr><tr><td style="text-align:left"><code>\d</code></td><td style="text-align:left">数字0~9</td><td style="text-align:left"><code>0</code>~<code>9</code></td></tr><tr><td style="text-align:left"><code>\w</code></td><td style="text-align:left">大小写字母，数字和下划线</td><td style="text-align:left"><code>a</code>~<code>z</code>，<code>A</code>~<code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">空格、Tab键</td><td style="text-align:left">空格，Tab</td></tr><tr><td style="text-align:left"><code>\D</code></td><td style="text-align:left">非数字</td><td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr><tr><td style="text-align:left"><code>\W</code></td><td style="text-align:left">非\w</td><td style="text-align:left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td></tr><tr><td style="text-align:left"><code>\S</code></td><td style="text-align:left">非\s</td><td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr></tbody></table></div><p><strong>多个字符的匹配规则如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>A*</code></td><td style="text-align:left">任意个数字符</td><td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td style="text-align:left"><code>A+</code></td><td style="text-align:left">至少1个字符</td><td style="text-align:left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td style="text-align:left"><code>A?</code></td><td style="text-align:left">0个或1个字符</td><td style="text-align:left">空，<code>A</code></td></tr><tr><td style="text-align:left"><code>A{3}</code></td><td style="text-align:left">指定个数字符</td><td style="text-align:left"><code>AAA</code></td></tr><tr><td style="text-align:left"><code>A{2,3}</code></td><td style="text-align:left">指定范围个数字符</td><td style="text-align:left"><code>AA</code>，<code>AAA</code></td></tr><tr><td style="text-align:left"><code>A{2,}</code></td><td style="text-align:left">至少n个字符</td><td style="text-align:left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td></tr><tr><td style="text-align:left"><code>A{0,3}</code></td><td style="text-align:left">最多n个字符</td><td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td></tr></tbody></table></div><p>给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p><p><strong>复杂匹配规则主要有：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">开头</td><td style="text-align:left">字符串开头</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">结尾</td><td style="text-align:left">字符串结束</td></tr><tr><td style="text-align:left">[ABC]</td><td style="text-align:left">[…]内任意字符</td><td style="text-align:left">A，B，C</td></tr><tr><td style="text-align:left">[A-F0-9xy]</td><td style="text-align:left">指定范围的字符</td><td style="text-align:left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td></tr><tr><td style="text-align:left"><sup><a href="#fn_A-F" id="reffn_A-F">A-F</a></sup></td><td style="text-align:left">指定范围外的任意字符</td><td style="text-align:left">非<code>A</code>~<code>F</code></td></tr><tr><td style="text-align:left">ABlCDlEF</td><td style="text-align:left">AB或CD或EF</td><td style="text-align:left"><code>AB</code>，<code>CD</code>，<code>EF</code></td></tr></tbody></table></div><h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p><code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Pattern pattern = Pattern.compile(&quot;(\\d{3,4})\\-(\\d{7,8})&quot;);        pattern.matcher(&quot;010-12345678&quot;).matches(); // true        pattern.matcher(&quot;021-123456&quot;).matches(); // true        pattern.matcher(&quot;022#1234567&quot;).matches(); // false        // 获得Matcher对象:        Matcher matcher = pattern.matcher(&quot;010-12345678&quot;);        if (matcher.matches()) {            String whole = matcher.group(0); // &quot;010-12345678&quot;, 0表示匹配的整个字符串            String area = matcher.group(1); // &quot;010&quot;, 1表示匹配的第1个子串            String tel = matcher.group(2); // &quot;12345678&quot;, 2表示匹配的第2个子串            System.out.println(area);            System.out.println(tel);        }    }}</code></pre><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><pre><code class="lang-java">public String render(Map&lt;String, Object&gt; data) {        Matcher m = pattern.matcher(template);        StringBuilder sb = new StringBuilder();        while (m.find()) { // 搜索到含有匹配项的子串则返回            m.appendReplacement(sb, data.get(m.group(1)).toString()); // 替换并添加到sb末尾        }        m.appendTail(sb); // 添加最后的子串        return sb.toString();    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-Map</title>
    <link href="/2020/04/02/java%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
    <url>/2020/04/02/java%E5%9F%BA%E7%A1%80%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总——Map及其源码分析</p><a id="more"></a><p>源码基于java 13。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/javamap.png" alt=""></p><ul><li>TreeMap：基于<strong>红黑树</strong>实现。</li><li>HashMap：基于<strong>哈希表</strong>实现。</li><li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><p>要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p><pre><code class="lang-java">for (String key : map.keySet()) {...}</code></pre><p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p><pre><code class="lang-java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {...}</code></pre><h2 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h2><p>正确使用<code>Map</code>必须保证：</p><ol><li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li><li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul></li></ol><p>自己写<code>hashCode()</code>时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><pre><code class="lang-java">@Overridepublic int hashCode() {    int result = 17;    result = 31 * result + x;    result = 31 * result + y;    result = 31 * result + z;    return result;}</code></pre><p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p><pre><code class="lang-java">int hashCode() {    return Objects.hash(firstName, lastName, age);}</code></pre><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：<code>equals()</code>用到的用于比较的每一个字段，都<strong>必须</strong>在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，<strong>绝不可</strong>放在<code>hashCode()</code>中计算。</p><p>Objects.hash()内部实现实则为Arrays.hashCode()方法</p><pre><code class="lang-java">public static int hash(Object... values) {    return Arrays.hashCode(values);}</code></pre><p>Arrays.hashCode()源码</p><pre><code class="lang-java">public static int hashCode(Object a[]) {    if (a == null)        return 0;    int result = 1;    for (Object element : a)        result = 31 * result + (element == null ? 0 : element.hashCode());    return result;}</code></pre><p>注意Objects.hash(Object…)，它的参数为不定参数，需要为Object对象。这会有以下一些影响：</p><ol><li>对基本类型做hashCode需要转换为包装类型，如long转换为Long</li><li>会创建一个Object[]数组</li></ol><p>如果hashCode()方法被频繁调用的话，会有一定的性能影响。</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p><code>hashCode()</code>内部使用了数组，在初始化时默认的数组大小只有16，任何<code>key</code>无论<code>hashCode()</code>多大都可以用类似方式处理：</p><pre><code class="lang-java">int index = key.hashCode() &amp; 0xf;</code></pre><p>当这个<code>hashMap</code>添加超过16个<code>key-value</code>时，<code>hashMap</code>会自动扩容，没扩容一次容量就会翻倍。因为内存每次扩容会导致重新分配已有的<code>key-value</code>，所以频繁扩容对<code>HashMap</code>的性能影响很大。如果确定要使用n个<code>key-value</code>的<code>HashMap</code>，最好在创建时就指定容量：</p><pre><code class="lang-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(n);</code></pre><h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><code>SortedMap</code>在遍历时严格按照Key的顺序遍历，最常用的实现类是<code>TreeMap</code>。作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>：</p><pre><code class="lang-java">Map&lt;Person, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() {    public int compare(Person p1, Person p2) {        return p1.name.compareTo(p2.name);    }});</code></pre><p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a &lt; b</code>，则返回负数，通常是<code>-1</code>，如果<code>a == b</code>，则返回<code>0</code>，如果<code>a &gt; b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/hashmapjiegoutu.png" alt="hashmap"></p><pre><code class="lang-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable {...}</code></pre><p>默认的容量是16：</p><pre><code class="lang-java">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></pre><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><code>HashMap</code>内部包含了一个 <code>Node</code> 类型的数组 <code>table</code>。</p><pre><code class="lang-java">transient Node&lt;K,V&gt;[] table;</code></pre><p><code>Node</code> 实现了<code>Map.Entry</code>接口，包含了四个字段，存储着键值对<code>Entry</code>(<code>key</code>, <code>value</code>)、<code>hash</code>和<code>next</code>。数组<code>table</code>中的每个位置被当成一个桶，一个桶存放一个链表。<code>HashMap</code> 使用<strong>拉链法</strong>来解决冲突，同一个链表中存放<strong>哈希值和散列桶取模运算结果相同</strong>的 Node`。</p><pre><code class="lang-java">/**N* Basic hash bin node, used for most entries.  (See below for* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)*/static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }    public final K getKey()        { return key; }    public final V getValue()      { return value; }    public final String toString() { return key + &quot;=&quot; + value; }    public final int hashCode() {        return Objects.hashCode(key) ^ Objects.hashCode(value);    }    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    public final boolean equals(Object o) {        if (o == this)            return true;        if (o instanceof Map.Entry) {            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        }        return false;    }}</code></pre><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>public</code>的<code>put()</code>方法调用了<code>putVal()</code>方法：</p><pre><code class="lang-java">public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><pre><code class="lang-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 当table不存在或长度为0时，新建一个table    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 当桶下标对应的node不存在时，新建该Node加入table    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    // 当桶下标对应的Node已经存在时    else {        Node&lt;K,V&gt; e; K k;        // key相同时        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        // Node为TreeNode时        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        // key不相同，采用尾插法插入Node        else {            //遍历链表            for (int binCount = 0; ; ++binCount) {                // 到链表末尾但没有相同key，则添加新Node                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    // 链表过长，将链表转为树结构                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                // 找到相同key                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            // onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><pre><code class="lang-java">public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><pre><code class="lang-java">final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历所有的键时，首先要获取键集合<code>KeySet</code>对象，然后再通过 <code>KeySet</code> 的迭代器<code>KeyIterator</code>进行遍历。<code>KeyIterator</code> 类继承自 <code>HashIterator</code> 类，核心逻辑也封装在 <code>HashIterator</code> 类中。<code>HashIterator</code> 的逻辑并不复杂，在初始化时，<code>HashIterator</code> 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。</p><h2 id="桶下标"><a href="#桶下标" class="headerlink" title="桶下标"></a>桶下标</h2><p>首先，传入<code>putVal()</code>的<code>hash(key)</code>处理如下，对于<code>key</code>为<code>null</code>的键值对，返回的<code>hash</code>为 0；其余则是将所得<code>hashCode</code>右移16位后于原<code>hashCode</code>作异或处理：</p><pre><code class="lang-java">static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>在后续的处理中会根据<code>HashMap</code>的容量大小取余，得到桶下标：</p><pre><code class="lang-java">n = table.length;i = (n - 1) &amp; hash;</code></pre><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>JDK1.8开始，HashMap由链表的头插法改变成了<strong>尾插法</strong>，因此不再会造成死循环，改成尾插法也是为了能够更好的维护jdk1.8中HashMap的红黑树结构。</p><h2 id="黑红树"><a href="#黑红树" class="headerlink" title="黑红树"></a>黑红树</h2><p>当链表变长时，查找和添加的速度会变慢，JDK1.8后加入了链表转换为黑红树的机制，当链表长度超过<code>TREEIFY_THRESHOLD</code>（默认为8）时，会转化成黑红树。</p><pre><code class="lang-java">static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</code></pre><p>在键类没有实现 <code>comparable</code> 接口的情况下，<code>HashMap</code> 会做以下三步处理：</p><ol><li>比较键与键之间 <code>hash</code> 的大小，如果 <code>hash</code> 相同，则</li><li>检测键类是否实现了 <code>Comparable</code> 接口，是则调用 <code>compareTo</code> 方法进行比较，否则</li><li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 <code>tieBreakOrder</code>。</li></ol><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>设 <code>HashMap</code> 的 <code>table</code> 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 <code>table</code> 要尽可能大。<code>HashMap</code> 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><pre><code class="lang-java">// 键值对的数量transient int size;// 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。final float loadFactor;// size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。int threshold;// 默认的装载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 <code>newTable</code> 中，包括链表和黑红树的拆分，因此这一步是很费时的。</p><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，<code>HashMap</code> 使用 <code>hash % capacity</code> 来确定桶下标。<code>capacity</code> 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p><p>假设原数组长度 <code>capacity</code> 为 16，扩容之后 <code>new capacity</code> 为 32：</p><pre><code class="lang-java">capacity     : 00010000new capacity : 00100000</code></pre><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li></ul><h2 id="与-Hashtable-的比较"><a href="#与-Hashtable-的比较" class="headerlink" title="与 Hashtable 的比较"></a>与 Hashtable 的比较</h2><ul><li><code>Hashtable</code> 使用 <code>synchronized</code> 来进行同步。</li><li><code>HashMap</code> 可以插入键为 <code>null</code> 的 <code>Entry</code>。</li><li><code>HashMap</code> 的迭代器是 fail-fast 迭代器。</li><li><code>HashMap</code> 不能保证随着时间的推移 <code>Map</code> 中的元素次序是不变的。</li></ul><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>待补充</p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><pre><code class="lang-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt; {...}</code></pre><p>继承自 <code>HashMap</code>，因此具有和 <code>HashMap</code> 一样的快速查找特性。</p><pre><code class="lang-java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {        super(hash, key, value, next);    }}</code></pre><p><code>Entry</code>类继承自<code>HashMap.Node</code>，可见内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><pre><code class="lang-java">// The head (eldest) of the doubly linked list.transient LinkedHashMap.Entry&lt;K,V&gt; head;// The tail (youngest) of the doubly linked list.transient LinkedHashMap.Entry&lt;K,V&gt; tail;</code></pre><p><code>accessOrder</code> 决定了顺序，默认为 <code>false</code>，此时维护的是插入顺序。显式设置为 true，代表以访问顺序进行迭代。</p><pre><code class="lang-java">final boolean accessOrder;Copy to clipboardErrorCopied</code></pre><p><code>LinkedHashMap</code> 最重要的是以下用于维护顺序的函数，它们会在 <code>put()</code>、<code>get()</code> 等方法中调用。<code>LinkedHashMap</code>并没有覆写<code>put()</code>，而是覆写了<code>afterNodeAccess(Node&lt;K,V&gt; p)</code>。</p><pre><code class="lang-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }void afterNodeInsertion(boolean evict) { }</code></pre><h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h2><p>当一个节点被访问时，如果 <code>accessOrder</code> 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><pre><code class="lang-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last = tail) != e) {        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;        else            last = b;        if (last == null)            head = p;        else {            p.before = last;            last.after = p;        }        tail = p;        ++modCount;    }}</code></pre><h2 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h2><p>在 <code>put()</code> 等操作之后执行，当 <code>removeEldestEntry()</code> 方法返回 <code>true</code> 时会移除最晚的节点，也就是链表首部节点 <code>first</code>。<code>evict</code> 只有在构建 <code>Map</code> 的时候才为 <code>false</code>，在这里为 <code>true</code>。</p><pre><code class="lang-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {        K key = first.key;        removeNode(hash(key), key, null, false, true);    }}Copy to clipboardErrorCopied</code></pre><p><code>removeEldestEntry()</code> 默认为 <code>false</code>，如果需要让它为 <code>true</code>，需要继承 <code>LinkedHashMap</code> 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><pre><code class="lang-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}</code></pre><h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>以下是使用 <code>LinkedHashMap</code> 实现的一个 LRU 缓存：</p><pre><code class="lang-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { // 继承自LinkedHashMap    // 最大缓存空间MAX_ENTRIES，默认值为3    private static final int MAX_ENTRIES = 3;    // 覆写    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() &gt; MAX_ENTRIES;    }    // 初始化，将 accessOrder 设置为 true    LRUCache() {        super(MAX_ENTRIES, 0.75f, true);    }}</code></pre><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>待补充</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration</code>：已被<code>Iterator</code>取代。</li></ul><p>Java的集合类定义在<code>java.util</code>包中，支持泛型。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java 容器" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265118019954528" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265118019954528</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-Collection</title>
    <link href="/2020/03/30/java%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
    <url>/2020/03/30/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总——Collection及其源码分析</p><a id="more"></a><p>源码基于java 13。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/javacollection.png" alt=""></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><code>List</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>void add(E e)</code></li><li>在指定索引添加一个元素：<code>void add(int index, E e)</code></li><li>删除指定索引的元素：<code>int remove(int index)</code></li><li>删除某个元素：<code>int remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li></ul><p><code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复，<code>List</code>还允许添加<code>null</code>。调用<code>List.of()</code>，它返回的是一个<strong>只读</strong><code>List</code>：</p><pre><code class="lang-java">List&lt;Integer&gt; list = List.of(1, 2, 5);</code></pre><p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p><h2 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List遍历</h2><p><code>List</code>的遍历采用了迭代器的设计模式：</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/iterator.png" alt=""></p><p><code>Iterable</code>接口声明如下：</p><pre><code class="lang-java">public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; iterator();}</code></pre><p><code>Iterator</code>接口声明如下：</p><pre><code class="lang-java">public interface Iterator&lt;E&gt; {    // 判断是否还有下一个对象，如果有，则返回true，否则false    boolean hasNext();     // 返回集合的下个值，此方法只能在hasNext方法返回true时调用    E next();     // 删除集合的当前值，此方法也只能在hasNext方法返回true时调用    void remove();}</code></pre><p><code>ListIterator</code>接口声明如下：</p><pre><code class="lang-java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {    // 支持双向移动    boolean hasNext();    E next();    boolean hasPrevious();    E previous();    // 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引    int nextIndex();    int previousIndex();    void remove();    // 可以使用set()方法替换它访问过的最后一个元素    void set(E e);    // 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素    void add(E e); }</code></pre><p>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p><pre><code class="lang-java">import java.util.Iterator;import java.util.List;public class Main {    public static void main(String[] args) {        List&lt;String&gt; list = List.of(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;);        for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) {            String s = it.next();            System.out.println(s);        }    }}</code></pre><pre><code class="lang-java">import java.util.List;public class Main {    public static void main(String[] args) {        List&lt;String&gt; list = List.of(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;);        for (String s : list) {            System.out.println(s);        }    }}</code></pre><h2 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h2><h3 id="List-gt-Array"><a href="#List-gt-Array" class="headerlink" title="List -&gt; Array"></a>List -&gt; Array</h3><p>给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p><pre><code class="lang-java">import java.util.List;public class Main {    public static void main(String[] args) {        List&lt;Integer&gt; list = List.of(12, 34, 56);        Integer[] array = list.toArray(new Integer[3]);        for (Integer n : array) {            System.out.println(n);        }    }}</code></pre><p><code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组。</p><pre><code class="lang-java">Number[] array = list.toArray(new Number[3]);</code></pre><p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。实际上，最常用的是传入一个“恰好”大小的数组：</p><pre><code class="lang-java">Integer[] array = list.toArray(new Integer[list.size()]);</code></pre><h3 id="Array-gt-List"><a href="#Array-gt-List" class="headerlink" title="Array -&gt; List"></a>Array -&gt; List</h3><pre><code class="lang-java">Integer[] array = { 1, 2, 3 };List&lt;Integer&gt; list = List.of(array);</code></pre><p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p><h2 id="contains-和indexOf"><a href="#contains-和indexOf" class="headerlink" title="contains()和indexOf()"></a>contains()和indexOf()</h2><p><code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。<code>List</code>提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p><p><code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等，所以放入的实例必须要正确override。</p><p>如果<code>this.name</code>为<code>null</code>，那么<code>equals()</code>方法会报错，因此，需要继续改写如下：</p><pre><code class="lang-java">public boolean equals(Object o) {    if (o instanceof Person) {        Person p = (Person) o;        boolean nameEquals = false;        if (this.name == null &amp;&amp; p.name == null) {            nameEquals = true;        }        if (this.name != null) {            nameEquals = this.name.equals(p.name);        }        return nameEquals &amp;&amp; this.age == p.age;    }    return false;}</code></pre><p>如果<code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code>Objects.equals()</code>静态方法：</p><pre><code class="lang-java">public boolean equals(Object o) {    if (o instanceof Person) {        Person p = (Person) o;        return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age;    }    return false;}</code></pre><h2 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a>List实现类</h2><ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和 ArrayList 类似，但它是线程安全的。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><p>比较<code>ArrayList</code>和<code>LinkedList</code>：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">ArrayList</th><th style="text-align:left">LinkedList</th></tr></thead><tbody><tr><td style="text-align:left">获取指定元素</td><td style="text-align:left">速度很快</td><td style="text-align:left">需要从头开始查找元素</td></tr><tr><td style="text-align:left">添加元素到末尾</td><td style="text-align:left">速度很快</td><td style="text-align:left">速度很快</td></tr><tr><td style="text-align:left">在指定位置添加/删除</td><td style="text-align:left">需要移动元素</td><td style="text-align:left">不需要移动元素</td></tr><tr><td style="text-align:left">内存占用</td><td style="text-align:left">少</td><td style="text-align:left">较大</td></tr></tbody></table></div><p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><pre><code class="lang-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    private static final long serialVersionUID = 8683452581122892189L;    // Default initial capacity    private static final int DEFAULT_CAPACITY = 10;    ...</code></pre><p>RandomAccess 接口标识着该类支持快速随机访问，java.io.Serializable是支持序列化接口。数组的默认大小为 10。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>添加元素时如果容量不够时，需要使用 grow() 方法进行扩容，新容量的大小默认为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。当需求的容量大于它时，则会选用两个<code>list</code>长度之和作为新容量，扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><pre><code class="lang-java">public boolean addAll(Collection&lt;? extends E&gt; c) {    Object[] a = c.toArray();    modCount++;    int numNew = a.length;    if (numNew == 0)        return false;    Object[] elementData;    final int s;    // 加入的数组长度大于剩余空数组长度    if (numNew &gt; (elementData = this.elementData).length - (s = size))        elementData = grow(s + numNew);    System.arraycopy(a, 0, elementData, s, numNew);    size = s + numNew;    return true;}private Object[] grow(int minCapacity) {    int oldCapacity = elementData.length;    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        int newCapacity = ArraysSupport.newLength(oldCapacity,                minCapacity - oldCapacity, /* minimum growth */                oldCapacity &gt;&gt; 1           /* preferred growth */);        return elementData = Arrays.copyOf(elementData, newCapacity);    } else {        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];    }}private Object[] grow() {    return grow(size + 1);}</code></pre><p>ArraySupport.class下的<code>newLength()</code>：</p><pre><code class="lang-java">public static int newLength(int oldLength, int minGrowth, int prefGrowth) {    // assert oldLength &gt;= 0    // assert minGrowth &gt; 0    int newLength = Math.max(minGrowth, prefGrowth) + oldLength;    if (newLength - MAX_ARRAY_LENGTH &lt;= 0) {        return newLength;    }    return hugeLength(oldLength, minGrowth); // 处理溢出情况}</code></pre><p>Arrays.class下的<code>copyOf()</code>：</p><pre><code class="lang-java">@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {    return (T[]) copyOf(original, newLength, original.getClass());}@HotSpotIntrinsicCandidate    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {        @SuppressWarnings(&quot;unchecked&quot;)        T[] copy = ((Object)newType == (Object)Object[].class)            ? (T[]) new Object[newLength]            : (T[]) Array.newInstance(newType.getComponentType(), newLength);        System.arraycopy(original, 0, copy, 0,                         Math.min(original.length, newLength));        return copy;    }</code></pre><p>System.class下的<code>arraycopy()</code>：</p><pre><code class="lang-java">public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>remove()</code>调用了<code>fastRemove()</code>，其中调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p><pre><code class="lang-java">public E remove(int index) {    Objects.checkIndex(index, size);    final Object[] es = elementData;    @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index];    fastRemove(es, index);    return oldValue;}private void fastRemove(Object[] es, int i) {    modCount++;    final int newSize;    if ((newSize = size - 1) &gt; i)        System.arraycopy(es, i + 1, es, i, newSize - i);    es[size = newSize] = null;}</code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>保存元素的数组 <code>elementData</code> 使用 <code>transient</code> 修饰，该关键字声明数组默认不会被序列化。也就是说 <code>elementData</code> 的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><pre><code class="lang-java">transient Object[] elementData; // non-private to simplify nested class access</code></pre><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><pre><code class="lang-java">private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException {    // Read in size, and any hidden stuff    s.defaultReadObject();    // Read in capacity    s.readInt(); // ignored    if (size &gt; 0) {        // like clone(), allocate array based upon size not capacity        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);        Object[] elements = new Object[size];        // Read in all elements in the proper order.        for (int i = 0; i &lt; size; i++) {            elements[i] = s.readObject();        }        elementData = elements;    } else if (size == 0) {        elementData = EMPTY_ELEMENTDATA;    } else {        throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size);    }}</code></pre><pre><code class="lang-java">private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException {    // Write out element count, and any hidden stuff    int expectedModCount = modCount;    s.defaultWriteObject();    // Write out size as capacity for behavioral compatibility with clone()    s.writeInt(size);    // Write out all elements in the proper order.    for (int i=0; i&lt;size; i++) {        s.writeObject(elementData[i]);    }    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}</code></pre><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p><pre><code class="lang-java">ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list);</code></pre><h4 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h4><p> AbstractList.class中使用 <code>modCount</code> 来记录 <code>ArrayList</code> 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><pre><code class="lang-java">protected transient int modCount = 0;</code></pre><p>迭代器在调用<code>next()</code>、<code>remove()</code>方法时都是调用<code>checkForComodification()</code>方法，它检测<code>modCount == expectedModCount</code> ？ 若不等则抛出<code>ConcurrentModificationException</code>异常，从而产生fail-fast机制。</p><p>有两种解决方案：</p><ul><li>在遍历过程中所有涉及到改变<code>modCount</code>值得地方全部加上<code>synchronized</code>或者直接使用<code>Collections.synchronizedList</code>（不推荐）；</li><li>使用<code>CopyOnWriteArrayList</code>来替换<code>ArrayList</code>。</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，否则多线程写的时候会Copy出N个副本，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><pre><code class="lang-java">public boolean add(E e) {    final ReentrantLock lock = this.lock;    // 获得锁    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        // 复制新数组        Object[] newElements = Arrays.copyOf(elements, len + 1);        // 插入新值        newElements[len] = e;        // 原来的引用指向新的数组        setArray(newElements);        return true;    } finally {        // 释放锁        lock.unlock();    }}final void setArray(Object[] a) {    array = a;}Copy to clipboardErrorCopied@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) {    return (E) a[index];}Copy to clipboardErrorCopied</code></pre><p>使用CopyOnWriteMap需要注意两件事情：</p><ol><li><strong>减少扩容开销。</strong>根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li><strong>使用批量添加。</strong>因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用代码里的addBlackList方法。</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合<strong>读多写少</strong>的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li><strong>内存占用：</strong>在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li><strong>数据不一致：</strong>读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList <strong>不适合内存敏感以及对实时性要求很高</strong>的场景。</p><h4 id="CopyOnWriteArrayList与Vector"><a href="#CopyOnWriteArrayList与Vector" class="headerlink" title="CopyOnWriteArrayList与Vector"></a>CopyOnWriteArrayList与Vector</h4><p>Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><p>有以下实现类：</p><ul><li>TreeSet：基于<strong>红黑树</strong>实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li></ul><p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p><ul><li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li><li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表，队列接口<code>Queue</code>定义了以下几个方法：</p><ul><li><code>int size()</code>：获取队列长度；</li><li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li><li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li><li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li></ul><p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">throw Exception</th><th style="text-align:left">返回false或null</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e)</td><td style="text-align:left">boolean offer(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove()</td><td style="text-align:left">E poll()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element()</td><td style="text-align:left">E peek()</td></tr></tbody></table></div><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><pre><code class="lang-java">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; {...}</code></pre><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），比较<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Queue</th><th>Deque</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e) / offer(E e)</td><td>addLast(E e) / offerLast(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove() / E poll()</td><td>E removeFirst() / E pollFirst()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element() / E peek()</td><td>E getFirst() / E peekFirst()</td></tr><tr><td style="text-align:left">添加元素到队首</td><td style="text-align:left">无</td><td>addFirst(E e) / offerFirst(E e)</td></tr><tr><td style="text-align:left">取队尾元素并删除</td><td style="text-align:left">无</td><td>E removeLast() / E pollLast()</td></tr><tr><td style="text-align:left">取队尾元素但不删除</td><td style="text-align:left">无</td><td>E getLast() / E peekLast()</td></tr></tbody></table></div><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。</p><h3 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h3><p>JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p><h2 id="Queue实现类"><a href="#Queue实现类" class="headerlink" title="Queue实现类"></a>Queue实现类</h2><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于<strong>堆结构</strong>实现，可以用它来实现优先队列。</li></ul><h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><pre><code class="lang-java">public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{    transient int size = 0;    // Pointer to first node.    transient Node&lt;E&gt; first;    // Pointer to last node.    transient Node&lt;E&gt; last;    ...</code></pre><p>LinkedList()中的节点定义如下：</p><pre><code class="lang-java">private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue中堆结构默认是<strong>最小堆</strong>，如需实现最大堆，覆写<code>compare()</code>即可。父子节点的编号之间有如下关系：</p><ul><li>leftNo = parentNo * 2 + 1</li><li>rightNo = parentNo * 2 + 2</li><li>parentNo = (nodeNo - 1) / 2</li></ul><p>常见的topK问题使用最小堆来解决，相反的求最小的若干数则用最大堆。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java 容器" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265112034799552" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265112034799552</a></li><li><a href="https://stackoverflow.com/questions/29574436/what-does-java-util-arraysarraylist-mean" target="_blank" rel="noopener">Array.asList() and List.of()</a></li><li><a href="https://majing.io/posts/10000001141158" target="_blank" rel="noopener">https://majing.io/posts/10000001141158</a></li><li><a href="https://baijiahao.baidu.com/s?id=1638201147057831295&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">fail-fast</a></li><li><a href="https://www.cnblogs.com/vinozly/p/5171227.html" target="_blank" rel="noopener">Serializable</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-反射和泛型</title>
    <link href="/2020/03/27/java%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <url>/2020/03/27/java%E5%9F%BA%E7%A1%80%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总——反射和泛型</p><a id="more"></a><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为<strong>反射（Reflection）</strong>。</p><p>Java 反射主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法。</li></ul><p><strong>重点：是运行时而不是编译时。</strong></p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>获取一个<code>class</code>的<code>Class</code>实例有三个方法：</p><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><pre><code class="lang-java">Class&lt;?&gt; cls = String.class;</code></pre><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><pre><code class="lang-java">String s = &quot;Hello&quot;;Class&lt;?&gt; cls = s.getClass();</code></pre><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><pre><code class="lang-java">Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</code></pre><p>注意<code>Class</code>实例<code>==</code>比较和<code>instanceof</code>的差别：</p><pre><code class="lang-java">Integer n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class</code></pre><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p><pre><code class="lang-java">// 获取String的Class实例:Class&lt;?&gt; cls = String.class;// 创建一个String实例:String s = (String) cls.newInstance();</code></pre><p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p><h2 id="访问字段-Field"><a href="#访问字段-Field" class="headerlink" title="访问字段(Field)"></a>访问字段(Field)</h2><p>对任意的一个<code>Object</code>实例，只要获取了它的<code>Class</code>，就可以获取它的一切信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个public的field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有public的field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有field（不包括父类）</li></ul><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p><pre><code class="lang-java">public final class String {    private final byte[] value;}</code></pre><p>我们用反射获取该字段的信息，代码如下：</p><pre><code class="lang-java">Field f = String.class.getDeclaredField(&quot;value&quot;);f.getName(); // &quot;value&quot;f.getType(); // class [B 表示byte[]类型int m = f.getModifiers();Modifier.isFinal(m); // trueModifier.isPublic(m); // falseModifier.isProtected(m); // falseModifier.isPrivate(m); // trueModifier.isStatic(m); // false</code></pre><p>以上获得了<code>Field</code>实例，获取值得方法：</p><pre><code class="lang-java">import java.lang.reflect.Field;public class Main {    // 当获取的字段不存在时会抛出错误，所以需要捕获    public static void main(String[] args) throws Exception {        Object p = new Person(&quot;Xiao Ming&quot;);        Class&lt;?&gt; c = p.getClass();        Field f = c.getDeclaredField(&quot;name&quot;);        f.setAccessible(true); // 设置后才能访问private字段        Object value = f.get(p);        System.out.println(value); // &quot;Xiao Ming&quot;        f.set(p, &quot;Xiao Hong&quot;); // 设置字段值        System.out.println(p.getName()); // &quot;Xiao Hong&quot;    }}class Person {    private String name;    public Person(String name) {        this.name = name;    }}</code></pre><p>调用<code>Field.setAccessible(true)</code>似乎会破坏类的封装，反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h2 id="调用方法-Method"><a href="#调用方法-Method" class="headerlink" title="调用方法(Method)"></a>调用方法(Method)</h2><p>通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>用反射调用方法：</p><pre><code class="lang-java">String r = (String) m.invoke(s, 6);</code></pre><p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><p>调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>:</p><pre><code class="lang-java">String r = (String) m.invoke(null, 6);</code></pre><p>与访问字段相同，对于非public方法通过<code>Method.setAccessible(true)</code>允许其调用。</p><p>使用反射调用方法时，仍然遵循<strong>多态原则</strong>：即总是调用实际类型的覆写方法（如果存在）。</p><h2 id="调用构造方法-Constructor"><a href="#调用构造方法-Constructor" class="headerlink" title="调用构造方法(Constructor)"></a>调用构造方法(Constructor)</h2><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情（甚至不去执行这个方法就可以）。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理类：由程序员创建或者由第三方工具生成，再进行编译；在程序运行之前，代理类的.class文件已经存在了。</p><ul><li>静态代理类通常只代理一个类；</li><li>静态代理事先知道要代理的是什么。</li></ul><h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理类：在程序运行时，通过反射机制动态生成。</p><ul><li>动态代理类通常代理接口下的所有类；</li><li>动态代理事先不知道要代理的是什么，只有在运行的时候才能确定；</li><li>动态代理的调用处理程序必须事先InvocationHandler接口，及使用Proxy类中的newProxyInstance方法动态的创建代理类；</li><li>Java动态代理只能代理接口，要代理类需要使用第三方的CLIGB等类库。</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在集合中存储对象并在使用前进行类型转换非常不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><p>可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</p><h2 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h2><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可：</p><pre><code class="lang-java">public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(T first, T last) {        this.first = first;        this.last = last;    }    public T getFirst() { ... }    public T getLast() { ... }    // 静态泛型方法应该使用其他类型区分:    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) {        return new Pair&lt;K&gt;(first, last);    }}</code></pre><h2 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h2><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型``：</p><pre><code class="lang-java">public class Pair&lt;T, K&gt; {    private T first;    private K last;    public Pair(T first, K last) {        this.first = first;        this.last = last;    }    public T getFirst() { ... }    public K getLast() { ... }}</code></pre><p>使用的时候，需要指出两种类型：</p><pre><code class="lang-java">Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(&quot;test&quot;, 123);</code></pre><p>Java标准库的<code>Map</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h2 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type Erasure"></a>Type Erasure</h2><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如<code>List&lt;String&gt;</code>在运行时仅用一个<code>List</code>来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li><li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><pre><code class="lang-java">Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);String first = p.getFirst();String last = p.getLast();</code></pre><p>而虚拟机执行的代码并没有泛型：</p><pre><code class="lang-java">Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);String first = (String) p.getFirst();String last = (String) p.getLast();</code></pre><p>java泛型的<strong>局限</strong>：</p><p><strong>局限一：<code>&lt;T&gt;</code>不能是基本类型</strong>，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型。</p><pre><code class="lang-java">Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!</code></pre><p><strong>局限二：无法取得带泛型的<code>Class</code></strong>，如下代码最后获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);        Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);        Class c1 = p1.getClass();        Class c2 = p2.getClass();        System.out.println(c1==c2); // true        System.out.println(c1==Pair.class); // true    }}</code></pre><p><strong>局限三：无法判断带泛型的<code>Class</code>：</strong></p><pre><code class="lang-Java">Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);// Compile error:if (p instanceof Pair&lt;String&gt;.class) {}</code></pre><p><strong>局限四：不能实例化<code>T</code>类型：</strong></p><pre><code class="lang-java">public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair() {        // Compile error:        first = new T();        last = new T();    }}</code></pre><p>上述代码无法通过编译，因为构造方法的两行语句：</p><pre><code class="lang-java">first = new T();last = new T();</code></pre><p>擦拭后实际上变成了：</p><pre><code class="lang-java">first = new Object();last = new Object();</code></pre><p>这样一来，创建<code>new Pair()</code>和创建<code>new Pair()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p><p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class</code>参数：</p><pre><code class="lang-java">public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(Class&lt;T&gt; clazz) {        first = clazz.newInstance();        last = clazz.newInstance();    }}</code></pre><p>上述代码借助<code>Class</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class</code>。例如：</p><pre><code class="lang-java">Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</code></pre><p>因为传入了<code>Class</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><h3 id="避免泛型覆写"><a href="#避免泛型覆写" class="headerlink" title="避免泛型覆写"></a>避免泛型覆写</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><pre><code class="lang-java">public class Pair&lt;T&gt; {    public boolean equals(T t) {        return this == t;    }}</code></pre><p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p><pre><code class="lang-java">public class Pair&lt;T&gt; {    public boolean same(T t) {        return this == t;    }}</code></pre><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>保存到子类的class文件中。</p><h2 id="限定通配符"><a href="#限定通配符" class="headerlink" title="限定通配符"></a>限定通配符</h2><p>extends通配符是<code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的上界，<code>&lt;? super T&gt;</code>通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p><h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><p>由于<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。对于下面一个静态方法，传入<code>Pair&lt;Integer&gt;</code>会报错：<code>incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</code>。</p><pre><code class="lang-java">public class PairHelper {    static int add(Pair&lt;Number&gt; p) {        Number first = p.getFirst();        Number last = p.getLast();        return first.intValue() + last.intValue();    }}</code></pre><p>解决办法是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。由于并不能确定传入值的类型，在静态方法中还是不能使用<code>Number</code>子类，否则会报错。Type Erasure会把<code>? extends Number</code>处理成<code>Number</code>。这里父类<code>Number</code>可以使用是因为向上转型是安全的。</p><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);        int n = add(p);        System.out.println(n);    }    static int add(Pair&lt;? extends Number&gt; p) {        // int x = p.getFirst(); // Type mismatch: cannot convert from capture#1-of ? extends Number to int        Number first = p.getFirst();        Number last = p.getLast();        // p.setFirst(new Integer(first.intValue() + 100));         /* incompatible types: Integer cannot be converted to CAP#1         * where CAP#1 is a fresh type-variable:         * CAP#1 extends Number from capture of ? extends Number */        return first.intValue() + last.intValue();    }}class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(T first, T last) {        this.first = first;        this.last = last;    }    public T getFirst() {        return first;    }    public T getLast() {        return last;    }    // 传入值出错    public void setFirst(T first) {        this.first = first;    }    public void setLast(T last) {        this.last = last;    }}</code></pre><p>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>类型给<code>setFirst(? extends Number)</code>。即使<code>Number</code>也是不行的，因为向下转型是不安全的。正因为如此，extends通配符有以下作用：</p><ul><li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li><li>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</li></ul><p>因此，方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code>set(null)</code>除外）。</p><p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p><pre><code class="lang-java">public class Pair&lt;T extends Number&gt; { ... }</code></pre><p><code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>，而非<code>Number</code>类型<code>String</code>、<code>Object</code>将无法通过编译。</p><h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h3 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h3><p>作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>PECS原则（Producer Extends Consumer Super）可以帮助记忆何时使用<code>extends</code>，何时使用<code>super</code>。</p><p>如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。以<code>Collections</code>的<code>copy()</code>方法为例：</p><pre><code class="lang-java">public class Collections {    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {        for (int i=0; i&lt;src.size(); i++) {            T t = src.get(i); // src是producer            dest.add(t); // dest是consumer        }    }}</code></pre><p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p><h2 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h2><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p><ul><li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li><li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p><pre><code class="lang-java">static boolean isNull(Pair&lt;?&gt; p) {    return p.getFirst() == null || p.getLast() == null;}</code></pre><p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p><pre><code class="lang-java">static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) {    return p.getFirst() == null || p.getLast() == null;}</code></pre><p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类。</p><h1 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h1><p><code>Class</code> 在实例化的时候，T 要替换成具体类。<code>Class</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p><pre><code class="lang-java">// 可以public Class&lt;?&gt; clazz;// 不可以，因为 T 需要指定类型public Class&lt;T&gt; clazzT;</code></pre><p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super String&gt;</code>：</p><pre><code class="lang-java">Class&lt;? super String&gt; sup = String.class.getSuperclass();</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析 Java 反射（1）- 基础</a></li><li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">https://www.zhihu.com/question/20794107</a></li><li><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></li><li><a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-面向对象和异常处理</title>
    <link href="/2020/03/23/java%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>/2020/03/23/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总——面向对象和异常处理</p><a id="more"></a><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">本类</th><th style="text-align:center">同一个包下（子类和无关类）</th><th style="text-align:center">不同包下（子类）</th><th style="text-align:center">不同包下（无关类）</th></tr></thead><tbody><tr><td>private</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>default</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>protected</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td>public</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table></div><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>子类<strong>不会继承</strong>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><ul><li><strong>向上转型（upcasting）：</strong>一个子类类型安全地变为父类类型的赋值。向上转型只能够调用子类重写的方法。</li><li><strong>向下转型（downcasting）：</strong>一个父类类型强制转型为子类类型。找回向上转型时丢失的子类扩展方法。</li></ul><p><code>instanceof</code>判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><pre><code class="lang-java">Person p = new Student();if (p instanceof Student) {    // 只有判断成功才会向下转型:    Student s = (Student) p; // 一定会成功}</code></pre><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。</p><h2 id="Override和Overload"><a href="#Override和Overload" class="headerlink" title="Override和Overload"></a>Override和Overload</h2><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li></ul><pre><code class="lang-java">class SuperClass {    protected List&lt;Integer&gt; func() throws Throwable {        return new ArrayList&lt;&gt;();    }}class SubClass extends SuperClass {    @Override    public ArrayList&lt;Integer&gt; func() throws Exception {        return new ArrayList&lt;&gt;();    }}</code></pre><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><pre><code class="lang-java">/*    A    |    B    |    C    |    D */class A {    public void show(A obj) {        System.out.println(&quot;A.show(A)&quot;);    }    public void show(C obj) {        System.out.println(&quot;A.show(C)&quot;);    }}class B extends A {    @Override    public void show(A obj) {        System.out.println(&quot;B.show(A)&quot;);    }}class C extends B {}class D extends C {}</code></pre><pre><code class="lang-java">public static void main(String[] args) {    A a = new A();    B b = new B();    C c = new C();    D d = new D();    // 在 A 中存在 show(A obj)，直接调用    a.show(a); // A.show(A)    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A    a.show(b); // A.show(A)    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用    b.show(c); // A.show(C)    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C    b.show(d); // A.show(C)    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样    A ba = new B();    ba.show(c); // A.show(C)    ba.show(d); // A.show(C)}</code></pre><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p><ol><li>重载（Overlode）**</li></ol><p>Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><p><code>equals()</code>具有以下性质：</p><ul><li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li><li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li><li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><pre><code class="lang-java">public class EqualExample {    private int x;    private int y;    private int z;    public EqualExample(int x, int y, int z) {        this.x = x;        this.y = y;        this.z = z;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        EqualExample that = (EqualExample) o;        if (x != that.x) return false;        if (y != that.y) return false;        return z == that.z;    }}</code></pre><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p><pre><code class="lang-java">EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size());   // 2</code></pre><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><pre><code class="lang-java">@Overridepublic int hashCode() {    int result = 17;    result = 31 * result + x;    result = 31 * result + y;    result = 31 * result + z;    return result;}</code></pre><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>重写 clone() 需要实现 Cloneable 接口。应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><pre><code class="lang-java">public class CloneExample implements Cloneable {    private int a;    private int b;    @Override    public Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><p>拷贝分为深拷贝和浅拷贝，两种方式生成的对象的地址是不同的，这有别于赋值。</p><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><pre><code class="lang-java">public class ShallowCloneExample implements Cloneable {    private int[] arr;    public ShallowCloneExample() {        arr = new int[10];        for (int i = 0; i &lt; arr.length; i++) {            arr[i] = i;        }    }    public void set(int index, int value) {        arr[index] = value;    }    public int get(int index) {        return arr[index];    }    @Override    protected ShallowCloneExample clone() throws CloneNotSupportedException {        return (ShallowCloneExample) super.clone();    }}</code></pre><pre><code class="lang-java">ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try {    e2 = e1.clone();} catch (CloneNotSupportedException e) {    e.printStackTrace();}e1.set(2, 222);System.out.println(e2.get(2)); // 222</code></pre><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><pre><code class="lang-java">public class DeepCloneExample implements Cloneable {    private int[] arr;    public DeepCloneExample() {        arr = new int[10];        for (int i = 0; i &lt; arr.length; i++) {            arr[i] = i;        }    }    public void set(int index, int value) {        arr[index] = value;    }    public int get(int index) {        return arr[index];    }    @Override    protected DeepCloneExample clone() throws CloneNotSupportedException {        DeepCloneExample result = (DeepCloneExample) super.clone();        result.arr = new int[arr.length];        for (int i = 0; i &lt; arr.length; i++) {            result.arr[i] = arr[i];        }        return result;    }}</code></pre><pre><code class="lang-java">DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try {    e2 = e1.clone();} catch (CloneNotSupportedException e) {    e.printStackTrace();}e1.set(2, 222);System.out.println(e2.get(2)); // 2</code></pre><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><pre><code class="lang-java">public class CloneConstructorExample {    private int[] arr;    public CloneConstructorExample() {        arr = new int[10];        for (int i = 0; i &lt; arr.length; i++) {            arr[i] = i;        }    }    public CloneConstructorExample(CloneConstructorExample original) {        arr = new int[original.arr.length];        for (int i = 0; i &lt; original.arr.length; i++) {            arr[i] = original.arr[i];        }    }    public void set(int index, int value) {        arr[index] = value;    }    public int get(int index) {        return arr[index];    }}</code></pre><pre><code class="lang-java">CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2</code></pre><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p><ol><li>都是上层的抽象层。</li><li>都不能被实例化</li><li>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类和抽象方法都使用 <code>abstract</code> 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为<strong>抽象类</strong>。</p><p>抽象类和普通类最大的区别是，抽象类<strong>不能被实例化，只能被继承</strong>。</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于设计了模板。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p><ul><li>接口的<strong>成员（字段 + 方法）</strong>默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者 <code>protected</code>。</li><li>接口的<strong>字段</strong>默认都是 <code>static</code> 和 <code>final</code> 的。</li></ul><h3 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a>接口和抽象类的区别：</h3><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>从Java 9开始，JDK又引入了模块（Module）。把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Java把异常当作对象来处理，并定义一个基类<code>java.lang.Throwable</code>作为所有异常的超类。Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><p><img src="PPjwP.png" alt=""></p><p>从图中可以看出所有异常类型都是内置类<code>Throwable</code>的子类，因而<code>Throwable</code>在异常类的层次结构的顶层。接下来<code>Throwable</code>分成了两个不同的分支，一个分支是<code>Error</code>，它表示不希望被程序捕获或者是程序无法处理的错误。另一个分支是<code>Exception</code>，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。其中异常类<code>Exception</code>又分为运行时异常(<code>RuntimeException</code>)和非运行时异常。Java异常又可以分为不受检查异常（<code>Unchecked Exception</code>）和检查异常（<code>Checked Exception</code>）。</p><h2 id="error和exception的区别"><a href="#error和exception的区别" class="headerlink" title="error和exception的区别"></a>error和exception的区别</h2><ul><li><code>Error</code>通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；</li><li><code>Exception</code>通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li></ul><h2 id="检查异常和不受检查异常"><a href="#检查异常和不受检查异常" class="headerlink" title="检查异常和不受检查异常"></a>检查异常和不受检查异常</h2><ul><li><strong>检查异常：</strong>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于这种异常，当程序中可能出现这类异常，要么使用<code>try-catch</code>语句进行捕获，要么用<code>throws</code>子句抛出，否则编译无法通过。</li><li><strong>不受检查异常：</strong>包括<code>RuntimeException</code>及其子类和<code>Error</code>。</li></ul><p>对于<code>运行时异常</code>、<code>错误</code>和<code>检查异常</code>，Java技术所要求的异常处理方式有所不同。</p><p>由于运行时异常及其子类的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p><p>对于方法运行中可能出现的<code>Error</code>，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数<code>Error</code>异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p><p>对于所有的检查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常。</p><h2 id="Java中异常处理机制"><a href="#Java中异常处理机制" class="headerlink" title="Java中异常处理机制"></a>Java中异常处理机制</h2><p>Java的异常处理本质上是抛出异常和捕获异常。</p><p><strong>抛出异常：</strong>异常情形出现时，程序已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，所能做的就是从当前环境中跳出，并把问题提交给<strong>上一级环境</strong>，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。首先，是像创建普通的java对象一样将使用<code>new</code>在堆上创建一个<strong>异常对象</strong>；然后，当前的执行路径（已经无法继续下去了）被终止，并且从当前环境中弹出<strong>对异常对象的引用</strong>。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。</p><p><strong>捕获异常：</strong>在方法抛出异常之后，运行时系统将转为寻找合适的<strong>异常处理器</strong>（exception handler）。潜在的异常处理器是异常发生时<strong>依次存留在调用栈中的方法的集合</strong>。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><h2 id="异常处理基本语法"><a href="#异常处理基本语法" class="headerlink" title="异常处理基本语法"></a>异常处理基本语法</h2><ul><li>try：用来指定一块预防所有异常的程序（监控区域）；</li><li>catch：紧跟在try后面，用来捕获异常；</li><li>throw：用来明确的抛出一个异常；</li><li>throws：用来标明一个成员函数可能抛出的各种异常；</li><li>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</li></ul><p>注意<code>finally</code>有几个特点：</p><ol><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><p>如果没有发生异常，就正常执行<code>try { ... }</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try { ... }</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。可见，<code>finally</code>是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有<code>catch</code>，只使用<code>try ... finally</code>结构。例如：</p><pre><code class="lang-java">void process(String file) throws IOException {    try {        ...    } finally {        System.out.println(&quot;END&quot;);    }}</code></pre><p>因为方法声明了可能抛出的异常，所以可以不写<code>catch</code>。</p><h2 id="异常处理要领"><a href="#异常处理要领" class="headerlink" title="异常处理要领"></a>异常处理要领</h2><ol><li>尽量避免出现runtimeException 。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对runtimeException也进行try catch处理。</li><li>进行try catch处理的时候要在catch代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息，返回到web端，不仅要给用户良好的用户体验，也要能帮助程序员良好的定位异常出现的位置及原因。例如，以前做的一个项目，程序遇到异常页面会显示一个图片告诉用户哪些操作导致程序出现了什么异常，同时图片上有一个按钮用来点击展示异常的详细信息给程序员看的。</li></ol><h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><ol><li>final用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承</li><li>finally是异常处理中的一个关键字，表示finally{}里面的代码一定要执行</li><li>finalize是Object类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 基础.md#五object-通用方法" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95</a></li><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232</a></li><li><a href="https://www.zhihu.com/question/20149818" target="_blank" rel="noopener">接口和抽象类</a></li><li><a href="https://blog.csdn.net/caohaicheng/article/details/38025329" target="_blank" rel="noopener">https://blog.csdn.net/caohaicheng/article/details/38025329</a></li><li><a href="https://www.tianmaying.com/tutorial/Java-Exceptionhttps://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener">异常处理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/2020/03/20/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/20/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>java学习及面试题汇总——数据类型、运算、字符串和函数</p><a id="more"></a><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li>byte/8  [-128 ~ 127]</li><li>char/16 </li><li>short/16  [-32768 ~ 32767]</li><li>int/32  [-2147483648 ~ 2147483647]</li><li>float/32</li><li>long/64  [-9223372036854775808 ~ 9223372036854775807]</li><li>double/64</li><li>boolean/~</li></ul><p>Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把<code>boolean</code>表示为4字节整数，为了节省内存而表示为更小的类型可能会在之后处理时带来不必要的麻烦。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><pre><code class="lang-java">Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)int y = x;         // 拆箱 调用了 X.intValue()</code></pre><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><pre><code class="lang-java">Integer m = 123;Integer n = 123;System.out.println(m == n); // true</code></pre><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Java语言中数组必须先初始化，然后才可以使用。</p><ul><li><p><strong>静态初始化：</strong><code>arrayName = new type[]{element1,element2,element3...};</code></p><p>简化写法：<code>type[] arrayName = {element1,element2,element3...};</code></p></li><li><p><strong>动态初始化：</strong><code>arrayName = new type[length];</code></p></li></ul><p>数组完成初始化后，内存空间中针对该数组的各个元素就有个一个默认值：</p><ul><li>基本数据类型的整数类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>）默认值是<code>0</code>；</li><li>基本数据类型的浮点类型（<code>float</code>、<code>double</code>）默认值是<code>0.0</code>；</li><li>基本数据类型的字符类型（<code>char</code>）默认值是<code>&#39;\u0000&#39;</code>；</li><li>基本数据类型的布尔类型（<code>boolean</code>）默认值是<code>false</code>；</li><li>类型的引用类型（类、数组、接口、<code>String</code>）默认值是<code>null</code>。</li></ul><p><strong>注意：</strong>不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。一旦数组完成初始化，数组在内存中所占的空间将被固定下来，所以数组的长度将不可改变。</p><h3 id="打印数组内容"><a href="#打印数组内容" class="headerlink" title="打印数组内容"></a>打印数组内容</h3><p>Java标准库提供了类方法<code>Arrays.toString()</code>，可以快速打印数组内容。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>调用JDK提供的<code>Arrays.sort()</code>可以原地升序排序。如需降序：</p><pre><code class="lang-java">Arrays.sort(a, Collections.reverseOrder());</code></pre><h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><p>在Java的计算表达式中，运算优先级从高到低依次是：</p><ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">1. 面试题15. 二进制中1的个数</a></p><pre><code class="lang-java">// 解一：public class Solution {    public int hammingWeight(int n) {        int res = 0;        while(n != 0) {            res += n &amp; 1; // 只计算一位            n &gt;&gt;&gt;= 1; // &gt;&gt;&gt; 符号位一起移动，&gt;&gt; 符号位不移动        }        return res;    }}// 解二：巧用n&amp;(n−1)public class Solution {    public int hammingWeight(int n) {        int res = 0;        while(n != 0) {            res++;            n &amp;= n - 1;        }        return res;    }}</code></pre><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">2. 快速幂</a></p><pre><code class="lang-java">class Solution {    public double myPow(double x, int n) {        if (n == 0) return 1;        double p = 1;        long m = n; // int最小值转为正数会溢出，需要转为long        if (m &lt; 0) {            x = 1 / x;            m = -m;        }        while (m &gt; 0) {            if ((m &amp; 1) == 1) p *= x;            x *= x;            m &gt;&gt;&gt;= 1;        }        return p;    }}</code></pre><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><code>short</code>和<code>int</code>计算，结果总是<code>int</code>，原因是<code>short</code>首先自动被转型为<code>int</code>：</p><pre><code class="lang-java">short s = 1234;int i = 123456;int x = s + i; // s自动转型为int</code></pre><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p><pre><code class="lang-java">short s1 = 1;// s1 = s1 + 1;</code></pre><p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p><pre><code class="lang-java">s1 += 1;s1++;</code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><pre><code class="lang-java">s1 = (short) (s1 + 1);</code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code>，例如，将<code>int</code>强制转型为<code>short</code>：</p><pre><code class="lang-java">int i = 12345;short s = (short) i; // 12345</code></pre><p>要注意，超出范围的强制转型会得到错误的结果，原因是转型时，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节。</p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>为了防止溢出，有些题目会设置答案求余数的要求，如<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a>要求答案需要取模 1e9+7（1000000007），这个数小于<code>int</code>最大值的一半，利用循环取余: <script type="math/tex">(x + y) \odot p = (x \odot p + y \odot p) \odot p</script>。</p><pre><code class="lang-java">class Solution {    public int fib(int n) {        int a = 0, b = 1, sum;        for(int i = 0; i &lt; n; i++){            sum = (a + b) % 1000000007;            a = b;            b = sum;        }        return a;    }}</code></pre><h2 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h2><p>浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。</p><p>下面是定义浮点数的例子：</p><pre><code class="lang-java">float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324</code></pre><p><strong>对于<code>float</code>类型，需要加上<code>f</code>后缀。</strong>浮点数可表示的范围非常大，<code>float</code>类型可最大表示3.4x1038，而<code>double</code>类型可最大表示1.79x10308。</p><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><pre><code class="lang-java">// float f = 1.1;</code></pre><p><code>1.1</code> 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><h3 id="浮点数的不准确性"><a href="#浮点数的不准确性" class="headerlink" title="浮点数的不准确性"></a>浮点数的不准确性</h3><p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p><p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常<strong>无法精确表示</strong>。</p><p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。（乘以若干个2后能成为整数的才能准确表示）</p><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><h3 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h3><p>布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p><p>因为<code>false &amp;&amp; x</code>的结果总是<code>false</code>，无论<code>x</code>是<code>true</code>还是<code>false</code>，因此，与运算在确定第一个值为<code>false</code>后，不再继续计算，而是直接返回<code>false</code>。</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>Java还提供一个三元运算符<code>b ? x : y</code>，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><pre><code class="lang-java">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final byte[] value;    /** The identifier of the encoding used to encode the bytes in {@code value}. */    private final byte coder;}</code></pre><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><pre><code class="lang-java">byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换</code></pre><p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><pre><code class="lang-java">byte[] b = ...String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换</code></pre><p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p><h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h2 id="StringBuffer-and-StringBuilder"><a href="#StringBuffer-and-StringBuilder" class="headerlink" title="StringBuffer and StringBuilder"></a>StringBuffer and StringBuilder</h2><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        var sb = new StringBuilder(1024);        sb.append(&quot;Mr &quot;)          .append(&quot;Bob&quot;)          .append(&quot;!&quot;)          .insert(0, &quot;Hello, &quot;);        System.out.println(sb.toString());    }}</code></pre><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。现在完全没有必要使用<code>StringBuffer</code>。</p><h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><pre><code class="lang-java">import java.util.StringJoiner;public class Main {    public static void main(String[] args) {        String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;};        var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);// 分隔符。头，尾        for (String name : names) {            sj.add(name);        }        System.out.println(sj.toString());    }}</code></pre><h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><pre><code class="lang-java">String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2);           // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4);           // true</code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><pre><code class="lang-java">String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6);  // true</code></pre><h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code class="lang-java">import java.util.Arrays;public class Main {    public static void main(String[] args) {        String s1 = &quot;hello&quot;;        String s2 = &quot;HELLO&quot;.toLowerCase();        // 判断相同        System.out.println(s1 == s2); // false        System.out.println(s1.equals(s2)); // true        // 判断为空        System.out.println(&quot;&quot;.isEmpty()); // true        System.out.println(&quot;  &quot;.isEmpty()); // false        // 判断为空白        System.out.println(&quot;  \n&quot;.isBlank()); // true        System.out.println(&quot; Hello &quot;.isBlank()); // false        // 移除空白        //   移除字符串首尾空白字符。空白字符包括空格，\t，\r，\n，        //   trim()并没有改变字符串的内容，而是返回了一个新字符串。        System.out.println(&quot;  \tHello\r\n &quot;.trim()); // &quot;Hello&quot;         //   类似中文的空格字符\u3000也会被移除        System.out.println(&quot;\u3000Hello\u3000&quot;.strip()); // &quot;Hello&quot;        System.out.println(&quot;\u3000Hello\u3000&quot;.stripLeading()); // &quot;Hello &quot;        System.out.println(&quot;\u3000Hello\u3000&quot;.stripTrailing()); // &quot; Hello&quot;         // 子串        //   注意到contains()方法的参数是CharSequence而不是String，因为CharSequence是String的父类。        System.out.println(&quot;Hello&quot;.contains(&quot;ll&quot;)); // true         System.out.println(&quot;Hello&quot;.indexOf(&quot;l&quot;)); // 2        System.out.println(&quot;Hello&quot;.lastIndexOf(&quot;l&quot;)); // 3        System.out.println(&quot;Hello&quot;.startsWith(&quot;He&quot;)); // true        System.out.println(&quot;Hello&quot;.endsWith(&quot;lo&quot;)); // true        System.out.println(&quot;Hello&quot;.substring(2)); // &quot;llo&quot;        System.out.println(&quot;Hello&quot;.substring(2, 4)); // &quot;ll&quot;        // 替换子串        System.out.println(&quot;Hello&quot;.replace(&quot;el&quot;, &quot;a&quot;)); // &quot;Halo&quot;        // 分割字符串        System.out.println(Arrays.toString(&quot;A,B,C,D&quot;.split(&quot;,&quot;))); // [A, B, C, D]        // 拼接字符串        String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};        System.out.println(String.join(&quot;, &quot;, arr)); // &quot;A, B, C&quot;        // 类型转换        System.out.println(String.valueOf(123)); // &quot;123&quot;        System.out.println(String.valueOf(new Object())); // &quot;java.lang.Object@5caf905d&quot;        System.out.println(Integer.parseInt(&quot;123&quot;)); // 123        System.out.println(Integer.parseInt(&quot;ff&quot;, 16)); // 按十六进制转换，255        //   如果修改了char[]数组，String并不会改变        //   new String(char[])并不会直接引用传入的char[]数组，而是会复制一份        char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]        String s = new String(cs); // char[] -&gt; String        // 翻转        System.out.println(new StringBuilder(s).reverse().toString()); // olleH        // 判断是否为数字        char ch = s.charAt(1); // e        System.out.println(Character.isDigit(ch)); // false    }}</code></pre><h1 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h1><h2 id="包装类型-1"><a href="#包装类型-1" class="headerlink" title="包装类型"></a>包装类型</h2><p>Java核心库为每种基本类型都提供了对应的包装类型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">基本类型</th><th style="text-align:left">对应的引用类型</th></tr></thead><tbody><tr><td style="text-align:left">boolean</td><td style="text-align:left">java.lang.Boolean</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">java.lang.Byte</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">java.lang.Short</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">java.lang.Integer</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">java.lang.Long</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">java.lang.Float</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">java.lang.Double</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">java.lang.Character</td></tr></tbody></table></div><h3 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h3><p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p><pre><code class="lang-java">int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p><pre><code class="lang-java">Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>（比如对null自动拆箱）。</p><h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例（为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例），因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为<strong>静态工厂方法</strong>。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code class="lang-java">enum Weekday {    SUN, MON, TUE, WED, THU, FRI, SAT;}</code></pre><h3 id="enum定义枚举的好处"><a href="#enum定义枚举的好处" class="headerlink" title="enum定义枚举的好处"></a>enum定义枚举的好处</h3><ul><li><code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</li><li>不可能引用到非枚举的值，因为无法通过编译。</li><li>不同类型的枚举不能互相比较或者赋值，因为类型不符。</li></ul><h3 id="enum和class的区别"><a href="#enum和class的区别" class="headerlink" title="enum和class的区别"></a>enum和class的区别</h3><ul><li><code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较；</li><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><h3 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h3><p>返回常量名，例如：</p><pre><code class="lang-java">String s = Weekday.SUN.name(); // &quot;SUN&quot;</code></pre><h3 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h3><p>返回定义的常量的顺序，从0开始计数，例如：</p><pre><code class="lang-java">int n = Weekday.MON.ordinal(); // 1</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。</p><p>下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。例如 <code>testPop_emptyStack</code>。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Java的参数传递完全等同于赋值运算符的操作。<a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">[3]</a></p><ul><li>对于基本类型，赋值运算符会直接改变变量的值，原来的值被覆盖掉。</li><li>对于引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型，可以把可变参数改写为<code>String[]</code>类型，但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。另外可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>对象在class文件加载完毕，以及为各成员在方法区开辟好内存空间之后，就开始所谓“初始化”的步骤</p><ol><li><strong>基类静态代码块，基类静态成员字段</strong>（并列优先级，按代码中出现先后顺序执行）（只有第次加载类时执行</li><li><strong>派生类静态代码块，派生类静态成员字段</strong>（并列优先级，按代码中出现先后顺序执行）（只有第次加载类时执行）</li><li><strong>基类普通代码块，基类普通成员字段</strong>（并列优先级，按代码中出现先后顺序执行）</li><li><strong>基类构造函数</strong></li><li><strong>派生类普通代码块，派生类普通成员字段</strong>（并列优先级，按代码中出现先后顺序执行）</li><li><strong>派生类构造函数</strong></li></ol><p><strong>静态代码块：</strong></p><ol><li>它是<strong>随着类的加载而执行，只执行一次，并优先于主函数</strong>。具体说，<strong>静态代码块是由类调用</strong>的。类调用时，先执行静态代码块，然后才执行主函数的。</li><li><strong>静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的</strong>。</li><li>静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。</li></ol><p><strong>构造代码块：</strong></p><ol><li>构造代码块的作用是给对象进行初始化。</li><li><strong>对象一建立就运行构造代码块了，而且优先于构造函数执行</strong>。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且<strong>构造代码块与构造函数的执行顺序是前者先于后者执行</strong>。</li><li>构造代码块与构造函数的区别是：<strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化</strong>，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</li></ol><p><strong>构造函数：</strong></p><ol><li><strong>对象一建立，就会调用与之相应的构造函数</strong>，也就是说，不建立对象，构造函数时不会运行的。</li><li>构造函数的作用是用于给对象进行初始化。</li><li>一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</li></ol><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code class="lang-java">import java.util.Scanner; // 导入类public class Main {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in); // 创建Scanner对象        System.out.print(&quot;Input your name: &quot;); // 打印提示        String name = scanner.nextLine(); // 读取一行输入并获取字符串        System.out.print(&quot;Input your age: &quot;); // 打印提示        int age = scanner.nextInt(); // 读取一行输入并获取整数        System.out.printf(&quot;Hi, %s, you are %d\n&quot;, name, age); // 格式化输出    }}</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>println</code>是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用<code>print()</code>。格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式</p><p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p><div class="table-container"><table><thead><tr><th style="text-align:left">占位符</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%d</td><td style="text-align:left">格式化输出整数</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">格式化输出十六进制整数</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">格式化输出浮点数</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">格式化输出科学计数法表示的浮点数</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">格式化字符串</td></tr></tbody></table></div><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><ul><li><p>多个<code>if ... else</code>串联要特别注意判断顺序；</p></li><li><p>要注意<code>if</code>的边界条件；</p></li><li><p>要注意浮点数判断相等不能直接用<code>==</code>运算符；</p><p>应该用<code>if (Math.abs(x - 0.1) &lt; 0.00001) {...}</code></p></li><li><p>引用类型判断内容相等要使用<code>equals()</code>，注意避免<code>NullPointerException</code>。</p><p>应该用<code>if (s1 != null &amp;&amp; s1.equals(&quot;hello&quot;)) {...}</code></p></li></ul><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><ul><li><code>switch</code>的计算结果必须是<strong>整型、字符串或枚举类型</strong>；</li><li><code>case</code>语句具有<strong>穿透性</strong>，注意千万不要漏写<code>break</code>；</li><li>总是写上<code>default</code>，建议打开<code>missing default</code>警告；</li><li>从Java 14开始，<code>switch</code>语句正式升级为表达式，不再需要<code>break</code>，并且允许使用<code>yield</code>返回值。</li></ul><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        String fruit = &quot;orange&quot;;        int opt = switch (fruit) {            case &quot;apple&quot; -&gt; 1;            case &quot;pear&quot;, &quot;mango&quot; -&gt; 2;            default -&gt; {                int code = fruit.hashCode();                yield code; // switch语句返回值            }        };        System.out.println(&quot;opt = &quot; + opt);    }}</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><pre><code class="lang-java">final int x = 1;// x = 2;  // cannot assign value to final variable &#39;x&#39;final A y = new A();y.a = 1;</code></pre><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><pre><code class="lang-java">public class A {    private int x;         // 实例变量    private static int y;  // 静态变量    public static void main(String[] args) {        // int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context        A a = new A();        int x = a.x;        int y = A.y;    }}</code></pre><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><pre><code class="lang-java">public abstract class A {    public static void func1(){    }    // public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;}</code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p><pre><code class="lang-java">public class A {    private static int x;    private int y;    public static void func1(){        int a = x;        // int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context        // int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context    }}</code></pre><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><pre><code class="lang-java">public class A {    static {        System.out.println(&quot;123&quot;);    }    public static void main(String[] args) {        A a1 = new A();        A a2 = new A();    }}123</code></pre><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p><pre><code class="lang-java">public class OuterClass {    class InnerClass {    }    static class StaticInnerClass {    }    public static void main(String[] args) {        // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context        OuterClass outerClass = new OuterClass();        InnerClass innerClass = outerClass.new InnerClass();        StaticInnerClass staticInnerClass = new StaticInnerClass();    }}</code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><pre><code class="lang-java">import static com.xxx.ClassName.*</code></pre><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>Stream API的特点是：</p><ul><li>Stream API提供了一套新的流式处理的抽象序列；</li><li>Stream API支持函数式编程和链式操作；</li><li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li></ul><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>从Java 8开始，我们可以用Lambda表达式替换单方法接口<code>FunctionalInterface</code>，如果只有一行<code>return xxx</code>的代码，完全可以用更简单的写法：</p><pre><code class="lang-java">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</code></pre><p>返回值的类型也是由编译器自动推断的，这里推断出的返回值是<code>int</code>，因此，只要返回<code>int</code>，编译器就不会报错。</p><p><strong><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></strong></p><pre><code class="lang-java">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) {    if (k &gt; nums.length || k &lt;= 0)        return new ArrayList&lt;&gt;();    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);    for (int num : nums) {        maxHeap.add(num);        if (maxHeap.size() &gt; k)            maxHeap.poll();    }    return new ArrayList&lt;&gt;(maxHeap);}</code></pre><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>如果某个方法<strong>签名</strong>和<strong>返回类型</strong>恰好一致，就可以直接传入方法引用。对于实例方法有一个隐含的<code>this</code>参数，比如<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>。</p><h3 id="stream创建"><a href="#stream创建" class="headerlink" title="stream创建"></a>stream创建</h3><p>创建<code>Stream</code>的方法有 ：</p><p><strong>1. 通过指定元素、指定数组、指定<code>Collection</code>创建<code>Stream</code>:</strong></p><pre><code class="lang-java">Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);Stream&lt;String&gt; stream1 = Arrays.stream(new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; });Stream&lt;String&gt; stream2 = List.of(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).stream();</code></pre><p><strong>2. 通过<code>Supplier</code>创建<code>Stream</code>，可以是无限序列：</strong></p><pre><code class="lang-java">import java.util.function.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        Stream&lt;Integer&gt; natual = Stream.generate(new NatualSupplier());        // 注意：无限序列必须先变成有限序列再打印:        natual.limit(20).forEach(System.out::println);    }}class NatualSupplier implements Supplier&lt;Integer&gt; {    int n = 0;    public Integer get() {        n++;        return n;    }}</code></pre><p><strong>3. 通过其他类的相关方法创建：</strong></p><p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p><p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p><pre><code class="lang-java">try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;/path/to/file.txt&quot;))) {    ...}</code></pre><p>此方法对于按行遍历文本文件十分有用。</p><p>另外，正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p><pre><code class="lang-java">Pattern p = Pattern.compile(&quot;\\s+&quot;);Stream&lt;String&gt; s = p.splitAsStream(&quot;The quick brown fox jumps over the lazy dog&quot;);s.forEach(System.out::println);</code></pre><p>基本类型的<code>Stream</code>有<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>。</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map()</code>方法接收的对象是<code>Function</code>接口对象，它定义了一个<code>apply()</code>方法，负责把一个<code>T</code>类型转换成<code>R</code>类型：</p><pre><code class="lang-java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>使用<code>filter()</code>方法可以对一个<code>Stream</code>的每个元素进行测试，通过测试的元素被过滤后生成一个新的<code>Stream</code>。</p><pre><code class="lang-java">.filter(p -&gt; p.score &gt;= 60); // 找出及格的人</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>map()</code>和<code>filter()</code>都是<code>Stream</code>的转换方法，而<code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果：</p><pre><code class="lang-java">.reduce(0, (acc, n) -&gt; acc + n); // 累加.reduce(0, (acc, n) -&gt; acc * n); // 累乘</code></pre><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p>把<code>Stream</code>的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p><pre><code class="lang-java">List&lt;String&gt; list = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;);String[] array = list.stream().toArray(String[]::new);</code></pre><p>注意到传入的“构造方法”是<code>String[]::new</code>，它的签名实际上是<code>IntFunction</code>定义的<code>String[] apply(int)</code>，即传入<code>int</code>参数，获得<code>String[]</code>数组的返回值。</p><h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap()"></a>toMap()</h3><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;APPL:Apple&quot;, &quot;MSFT:Microsoft&quot;);        Map&lt;String, String&gt; map = stream                .collect(Collectors.toMap(                        // 把元素s映射为key:                        s -&gt; s.substring(0, s.indexOf(&#39;:&#39;)),                        // 把元素s映射为value:                        s -&gt; s.substring(s.indexOf(&#39;:&#39;) + 1)));        System.out.println(map);    }}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744</a></li><li><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">值传递还是引用传递</a></li><li><a href="https://www.zhihu.com/question/49196023" target="_blank" rel="noopener">初始化顺序</a></li><li><a href="https://www.cnblogs.com/Qian123/p/5713440.html" target="_blank" rel="noopener">https://www.cnblogs.com/Qian123/p/5713440.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春花</title>
    <link href="/2020/03/17/%E6%98%A5%E8%8A%B1/"/>
    <url>/2020/03/17/%E6%98%A5%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<p>“期待春花开，能将夙愿偿，满庭花簇簇，添得许多香”</p><a id="more"></a><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7861.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7878.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7885.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7924.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7925.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7929.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7932.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7935.png" alt=""></p><p align="right">三月十七日同妈妈于公园</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯(Backtracking)</title>
    <link href="/2020/03/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>“想回到过去，试着让故事继续”</p><a id="more"></a><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p><strong>回溯</strong>（backtracking）是<strong>暴力搜索法</strong>中的一种。</p><p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。</p><blockquote><p>约束满足问题：在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解。</p></blockquote><p>回溯法采用<strong>试错</strong>的思想，它尝试<strong>分步</strong>的去解决一个问题。在分步<strong>执行</strong>的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将<strong>撤销</strong>上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案，找到答案即算法运行至<strong>终止条件</strong>。</p><p>回溯法通常用最简单的<strong>递归</strong>方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p>在最坏的情况下，回溯法会导致一次<strong>复杂度</strong>为<strong>指数时间</strong>的计算。</p><h1 id="典型的回溯"><a href="#典型的回溯" class="headerlink" title="典型的回溯"></a>典型的回溯</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">leetcode 46. 全排列</a>：给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p>用比较通用的回溯算法可以这样解答：</p><pre><code class="lang-python">class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        size = len(nums)        res = []        # 记录已经选择过的数        visited = set()        def backtrack(numList, visited):                       # 当所有数字都选完了，终止            if len(visited) == size:                res.append(numList[:]) # 注意深拷贝和浅拷贝的问题                return            # 遍历所有可能的选择            for i in range(size):                # 如果这个数已在前面出现过了，跳过                if i in visited: continue                                 visited.add(i)                numList.append(nums[i])                 # 递归                backtrack(numList,visited)                          # 撤销对临时数组和visited的操作                numList.pop()                visited.remove(i)        backtrack([], visited)        return res</code></pre><p>全排列问题能很好的体现回溯的特点：</p><ul><li><strong>试错：</strong>判断当前数是否在前面出现过</li><li><strong>分步：</strong>遍历所有数</li><li><strong>执行</strong>：添加一位数字，并记录该数字为以访问</li><li><strong>撤销：</strong>推出递归后需要撤销之前的改动以安全地进入下一个循环</li><li><strong>终止条件：</strong>所有数都已遍历，或者临时数组长度等于原数组</li></ul><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>在经典的教科书中，<strong><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">八皇后问题</a></strong>展示了回溯法的用例。</p><p><strong>八皇后问题</strong>是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。</p><p><img src="2020-03-08 142051.png" alt=""></p><p>上图就是其中的一个解，八个皇后在8x8棋盘上共有4,426,165,368（<script type="math/tex">\binom{64}{8}</script>）种摆放方法，但只有92个<strong>互不相同</strong>的解。如果将旋转和对称的解归为一种的话，则一共有12个独立解。<a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">wiki有完整解</a></p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">leetcode 51. N皇后</a>是八皇后问题的推广：如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code class="lang-txt">输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p>对于较为复杂的问题，我们可以用函数来封装若干步骤，比如<strong>试错</strong>、<strong>执行</strong>和<strong>撤销</strong>。</p><pre><code class="lang-python">class Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        # 储存已有皇后的列        visited_c = [False] * n        # 储存已有皇后的/对角线        visited_u = [False] * (2 * n - 1)        # 储存已有皇后的\对角线        visited_d = [False] * (2 * n - 1)        # 储存所有皇后的列信息        queens = []        res = []        # 试错        def isValid(i, j):            return not (visited_c[j] or visited_u[i + j] or visited_d[i - j])        # 执行        def place_queen(i, j):            queens.append(j)            visited_c[j] = True             visited_u[i + j] = True            visited_d[i - j] = True        # 撤销        def remove_queen(i, j):            queens.pop()            visited_c[j] = False            visited_u[i + j] = False            visited_d[i - j] = False        # 输出结果        def checkerboard():            tmp = []            for j in queens:                tmp.append(&#39;.&#39; * j + &#39;Q&#39; + &#39;.&#39; * (n - j - 1))            res.append(tmp)        def back_track(i=0):            # 终止条件            if i == n:                checkerboard()                return            for j in range(n):                if not isValid(i, j):                    continue                place_queen(i, j)                back_track(i + 1)                remove_queen(i, j)        back_track()        return res</code></pre><p>全排列和N皇后其实是相似的，两者的不同点在于，全排列是处理一维数组，N皇后是处理二维数组。这一点具体体现在两者在处理<strong>分布</strong>时的不同，全排列递归的深度是N次，每次分布都是遍历数组中所有数；N皇后递归的深度只有两次，这是由每行每列只能有一个皇后，所以第一个循环是遍历行，对每一行执行第二个循环——遍历列。</p><p>N皇后在处理<strong>试错</strong>时的条件相对苛刻一些，但是对角线这个条件其实可以简化：</p><blockquote><p>对于所有的主对角线有 <code>行号 + 列号 = 常数</code>，对于所有的次对角线有 <code>行号 - 列号 = 常数</code>.</p></blockquote><p>代码中我们用<code>visited_u</code>记录主对角线，用<code>visited_d</code>记录次对角线。</p><h1 id="回溯算法的一些细节"><a href="#回溯算法的一些细节" class="headerlink" title="回溯算法的一些细节"></a>回溯算法的一些细节</h1><h2 id="leetcode-10-正则表达式匹配"><a href="#leetcode-10-正则表达式匹配" class="headerlink" title="leetcode 10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">leetcode 10. 正则表达式匹配</a></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><blockquote><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。</p></blockquote><p>说明:</p><blockquote><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></blockquote><pre><code class="lang-python">class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        size_s = len(s)        size_p = len(p)        def backtrack(i, j):            # 终止条件            if j &gt;= size_p:                 if i &gt;= size_s:                     return True                else:                    return False            # 判断第一位是否配对            first_match = i &lt; size_s and (s[i] == p[j] or p[j] == &#39;.&#39;)            # 第二位存在且第二位是&#39;*&#39;            if j + 1 &lt; size_p and p[j + 1] == &#39;*&#39;:                if first_match:                     return backtrack(i + 1, j) or backtrack(i, j + 2) # 注意这里才是分步                else:                     return backtrack(i, j + 2)              # 第二位不是&#39;*&#39;或不存在             else:                 return first_match and backtrack(i + 1, j + 1)        return backtrack(0, 0)</code></pre><p>正则表达式前两题不同之处在于，<strong>终止条件</strong>不是单一的处理，而是需要判断<code>True</code>or<code>False</code>。<strong>分步</strong>不再是循坏，而是分为两个情况讨论——‘*’前面的字母不出现和出现若干次。</p><blockquote><p>注意：一般这类判断是否可行的题都是判断成功<code>return True</code>，判断失败就继续运行，但是这里可以写<code>return False</code>。原因在于错误的分支被<code>or</code> 语句截断了。</p></blockquote><p>没有<strong>执行</strong>和<strong>撤销</strong>的过程，因为参数直接传入递归函数，对当前函数内不产生影响。下面一个例子也是这种情况。</p><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">leetcode 22. 括号生成</a>：给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><pre><code class="lang-python">class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        res = []        def backtrack(l, r, s):            if not r:                res.append(s)                return            if l &gt; 0:                backtrack(l - 1, r, s + &#39;(&#39;)            if l &lt; r:                backtrack(l, r - 1, s + &#39;)&#39;)        backtrack(n, n, &#39;&#39;)        return res</code></pre><h2 id="leetcode-40-组合总和-II"><a href="#leetcode-40-组合总和-II" class="headerlink" title="leetcode 40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">leetcode 40. 组合总和 II</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>candidates 中的每个数字在每个组合中只能使用一次。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例：</strong></p><pre><code class="lang-txt">输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[  [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6]]</code></pre><p>当对选值有特殊要求时，<strong>分步</strong>就变得复杂一些了。</p><pre><code class="lang-python">class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        res = []        candidates.sort()        size = len(candidates)        def backtrack(start, num_sum, nums):            if num_sum &gt; target:                return            if num_sum == target:                res.append(nums)            # start保证了前面的元素不会再选取            for i in range(start, size):                # 这一步是关键，确保了若干个相同元素都在前面                if i &gt; start and candidates[i] == candidates[i - 1]:                     continue                backtrack(i + 1, num_sum + candidates[i], nums + [candidates[i]])        backtrack(0, 0, [])        return res</code></pre><p>原理如下图：</p><p><img src="backtrack-2.png" alt=""></p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><p>简单回溯法的时间复杂度通常是指数级别的。比如正则表达式使用回溯法求解的时间复杂度为<script type="math/tex">O\left ( (T+P)2^{T+\frac{P}{2}} \right )</script>，<code>T</code> 和 <code>P</code> 分别表示匹配串和模式串的长度，<code>2</code>则是因为当出现<code>*</code>时，我们分两步试错。</p><p>N皇后问题的时间复杂度为<script type="math/tex">O\left ( N！ \right )</script>，假设N足够大，第一个皇后有<code>N</code>种可能，第二个有<code>N-2</code>或<code>N-3</code>种可能，第三个有<code>N-4</code>、<code>N-5</code>或<code>N-6</code>种可能……总的来说时间复杂度是<script type="math/tex">O\left ( N！ \right )</script>。</p><p>实际上，回溯法的很多递归都是重复的，引用备忘录可以在递归到重复的情况时，直接读取备忘录中的值，而不再执行一次深度可能很深的递归。下面是备忘录的一个例子：</p><h2 id="leetcode-44-通配符匹配"><a href="#leetcode-44-通配符匹配" class="headerlink" title="leetcode 44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">leetcode 44. 通配符匹配</a></h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><blockquote><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p></blockquote><p><strong>说明:</strong></p><blockquote><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p></blockquote><p><strong>示例 1:</strong></p><pre><code class="lang-txt">输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><p>简单地通过一个<code>dict</code>来做备忘录：</p><pre><code class="lang-python">class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        size_s = len(s)        size_p = len(p)        memo = {} # 备忘录        def backtrack(i, j):            if (i,j) in memo:                return memo[(i, j)]            else:                tmp = False                if j == size_p:                    if i == size_s: # 注意：这里如果不成立直接返回tmp的初始值False                        tmp =  True                               elif p[j] == &#39;*&#39;:                    if i &lt; size_s:                        tmp = backtrack(i, j + 1) or backtrack(i + 1, j)                    else:                        tmp = backtrack(i, j + 1)                else:                     if i &lt; size_s and (s[i] == p[j] or p[j] == &#39;?&#39;):                        tmp = backtrack(i + 1, j + 1)                memo[(i, j)] = tmp                return memo[(i, j)]        return backtrack(0, 0)</code></pre><p>除了自己创建备忘录，还可以使用python中的装饰器<a href="https://docs.python.org/zh-cn/3/library/functools.html#functools.lru_cache" target="_blank" rel="noopener">@functools.lru_cache()</a>将函数值存在缓存中。</p><pre><code class="lang-python">import functoolsclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        size_s = len(s)        size_p = len(p)        @functools.lru_cache(maxsize=None, typed=False) # 递归函数前面加修饰器        def backtrack(i, j):            if j == size_p:                if i == size_s:                    return True                else :                     return False                     if p[j] == &#39;*&#39;:                if i &lt; size_s:                    return backtrack(i, j + 1) or backtrack(i + 1, j)                else:                    return backtrack(i, j + 1)            else:                 if i &lt; size_s and (s[i] == p[j] or p[j] == &#39;?&#39;):                    return backtrack(i + 1, j + 1)                else: return False        return backtrack(0, 0)</code></pre><p>加上备忘录的回溯和动态规划似乎很相似：</p><pre><code class="lang-python">class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        size_s = len(s)        size_p = len(p)        dp = [[False for _ in range(size_p + 1)] for _ in range(size_s + 1)]        # dp[-1][-1]表示s，p都为空时是配对的        dp[-1][-1] = True        # -1表示空字符，s为空字符是可以和p配对的，比如p=&#39;.*&#39;，所以需要计算i=-1的情况        for i in range(-1, size_s):              # p为空，s不为空就一定不配对，所以不考虑p=-1的情况                     for j in range(size_p):                # p[j]不是&#39;*&#39;且s[i]=p[j],注意利用i&gt;=0排除空字符                if i &gt;= 0 and (s[i] == p[j] or p[j] == &#39;.&#39;):                                     dp[i][j] = dp[i - 1][j - 1]                # p[j]是&#39;*&#39;                if p[j] == &#39;*&#39;:                    # &#39;*&#39;前面的能匹配，就有两种可能，匹配0次或若干次                    if i &gt;= 0 and (p[j - 1] == s[i] or p[j - 1] == &#39;.&#39;):                        dp[i][j] = dp[i - 1][j] or dp[i][j - 2]                    else:                        dp[i][j] = dp[i][j - 2]        return dp[size_s - 1][size_p - 1]</code></pre><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p><strong>剪枝</strong>，顾名思义，就是删去一些不重要或无用的节点，来减小计算或搜索的复杂度。使用备忘录其实也可以看成剪枝，因为重复的计算是无意义的。对于特定的问题，可以之间从算法的角度剪枝，如下面的例子：</p><h2 id="leetcode-60-第k个排列"><a href="#leetcode-60-第k个排列" class="headerlink" title="leetcode 60. 第k个排列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">leetcode 60. 第k个排列</a></h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 n 和 k，返回第 k 个排列。</p><p><strong>说明：</strong></p><ul><li>给定 <em>n</em> 的范围是 [1, 9]。</li><li>给定 <em>k</em> 的范围是[1,  <em>n</em>!]。</li></ul><p><strong>示例:</strong></p><pre><code class="lang-txt">输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><p>这题使用回溯法时间复杂度很高，挖掘其数学规律可以减少很多运算，比如我们在确定第一个数为<code>1</code>时，剩下的数共有<code>(n-1)!</code>种可能的排列，如果<code>k &gt; (n-1)!</code>，那么第一个数一定大于<code>1</code>。以此类推我们可以确定每个位置的数。</p><pre><code class="lang-python">class Solution:    def getPermutation(self, n: int, k: int) -&gt; str:        # 求阶乘        def fact(n):            out = 1            while n:                out *= n                n -= 1            return out        def backtrack(remainder, m, visited, permute):            if m &lt; 0:                return permute            for i in range(1, n + 1):                if i in visited:                    continue                if remainder - fact(m) &gt; 0:                     remainder -= fact(m)                    continue                visited.add(i)                return backtrack(remainder, m-1, visited, permute + str(i))        return backtrack(k, n - 1, set(), &#39;&#39;)</code></pre><p>这道题通过剪枝甚至已经不需要回溯到之前的状态，通过递归直接就得到答案了。那也许意味着，有更直接的解法。实际上，这正是<a href="https://baike.baidu.com/item/康托展开" target="_blank" rel="noopener">康托展开</a>的原理。</p><pre><code class="lang-python">class Solution(object):    def getPermutation(self, n, k):        res = &#39;&#39;        nums = [str(i+1) for i in range(n)]        factor = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880] # 手动输入n!，也可以写函数现场算        k -= 1 # 注意        for i in range(n-1, -1, -1):            n, k = divmod(k, factor[i])            res += nums.pop(n)        return res</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98</a></li><li><a href="https://zh.wikipedia.org/wiki/回溯法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>回溯</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo暗色背景下valine的优化</title>
    <link href="/2020/03/07/Hexo%E6%9A%97%E8%89%B2%E8%83%8C%E6%99%AF%E4%B8%8Bvaline%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/07/Hexo%E6%9A%97%E8%89%B2%E8%83%8C%E6%99%AF%E4%B8%8Bvaline%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>暗色背景下，通过修改CSS改变valine留言的外观，字体颜色，边框等</p><a id="more"></a><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>在布置完<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid主题</a>后我发现暗色背景下的valine字体还是黑色的，很难辨识，再请教原作者后了解到可以使用自定义CSS的方式修改网页的布局。在Chrome浏览器中打开自己的网页，右键点击想修改的元素，选择检查就可以看到CSS了。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/Inked2020-03-07%20195959_LI.jpg" alt=""></p><p>上图中的配置项可以修改背景，边框，字体等，其中有一些划去的项表示有冲突且优先级不高的设置，所以没有执行。我们修改CSS的原理类似，添加新的设置并且设置更高的优先级来改变原本的样式。</p><h1 id="自定义CSS"><a href="#自定义CSS" class="headerlink" title="自定义CSS"></a>自定义CSS</h1><p>以fluid主题为例（其他很多主题也有类似自定义CSS的功能），具体步骤如下：</p><ol><li><p>在<code>\hexo\themes\fluid\source\css</code>下创建<code>custom.css</code>文件，并在主题的配置文件<code>_config.yml</code>中添加如下路径。</p><pre><code class="lang-yaml"># 指定自定义 css 文件路径，路径是相对 source 目录custom_css: /css/custom.css</code></pre></li><li><p>在浏览器中找到需要修改的部分代码，修改后添加到<code>custom.css</code>，并在语句后面添加<code>!important</code>提高优先级以确保覆盖原有设置。例如修改valine输入的字体的颜色和高度就可以这样设置：</p><pre><code class="lang-css">.v * {    line-height: 1 !important;    color: #eee !important;}</code></pre></li><li><p>保存文件，<code>hexo clean</code> and <code>hexo d -g</code>。</p></li></ol><h1 id="本博客的例子"><a href="#本博客的例子" class="headerlink" title="本博客的例子"></a>本博客的例子</h1><p>由于我对CSS不熟悉，自己的valine只做了一些简单的修改：</p><pre><code class="lang-css">/*valine 评论系统样式*/.v * {    line-height: 1 !important;    color: #eee !important;}.v .vwrap .vheader .vinput {    border-bottom: 1px solid #000000 !important;}.v .vbtn {    border: 1px solid #333333 !important;    background: #000000 !important;}.v .vlist .vcard .vhead .vsys {    background: #000000 !important;}.v .vwrap{  border: 2px solid black !important;}.v .vlist .vcard .vquote {    border-left: 1px solid #000000 !important;}.v .vlist .vcard .vh {    border-bottom: 1px solid #333 !important;}/*设置评论头像旋转*/.v .vlist .vcard .vimg:hover {    -webkit-transform: rotate(360deg);    -moz-transform: rotate(360deg);    -ms-transform: rotate(360deg);    -transform: rotate(360deg);}/**/</code></pre><p>玩的开心！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy数据分析</title>
    <link href="/2020/02/29/NumPy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2020/02/29/NumPy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>NumPy数据分析与机器学习</p><a id="more"></a><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><h2 id="导入数字和文本的数据集"><a href="#导入数字和文本的数据集" class="headerlink" title="导入数字和文本的数据集"></a>导入数字和文本的数据集</h2><p>导入鸢尾属植物数据集，保持文本不变。</p><pre><code class="lang-python"># Solutionurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)# Print the first 3 rowsiris[:3]# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;]], dtype=object)</code></pre><p><strong>补充：</strong>在python3.x中字符串编码是<code>unicode</code>。对数据中<code>bytes</code>类型的字符串会用前缀<code>b</code>。</p><p>提取特定列：</p><pre><code class="lang-python"># **给定：**url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)print(iris_1d.shape)# Solution:species = np.array([row[4] for row in iris_1d])species[:5]# &gt; (150,)# &gt; array([b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;,# &gt;        b&#39;Iris-setosa&#39;],# &gt;       dtype=&#39;|S18&#39;)</code></pre><h2 id="将1维元组数组转换为2维numpy数组"><a href="#将1维元组数组转换为2维numpy数组" class="headerlink" title="将1维元组数组转换为2维numpy数组"></a>将1维元组数组转换为2维numpy数组</h2><p>通过省略鸢尾属植物数据集种类的文本字段，将一维鸢尾属植物数据集转换为二维数组iris_2d。</p><pre><code class="lang-python"># **给定：**url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)# Solution:# Method 1: Convert each row to a list and get the first 4 itemsiris_2d = np.array([row.tolist()[:4] for row in iris_1d])iris_2d[:4]# Alt Method 2: Import only the first 4 columns from source urliris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[:4]# &gt; array([[ 5.1,  3.5,  1.4,  0.2],# &gt;        [ 4.9,  3. ,  1.4,  0.2],# &gt;        [ 4.7,  3.2,  1.3,  0.2],# &gt;        [ 4.6,  3.1,  1.5,  0.2]])</code></pre><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="均值、中位数及标准差"><a href="#均值、中位数及标准差" class="headerlink" title="均值、中位数及标准差"></a>均值、中位数及标准差</h2><pre><code class="lang-python">mu, med, sd = np.mean(sepallength), np.median(sepallength), np.std(sepallength)</code></pre><h2 id="垂直叠加两个数组"><a href="#垂直叠加两个数组" class="headerlink" title="垂直叠加两个数组"></a>垂直叠加两个数组</h2><p><strong>给定：</strong></p><pre><code class="lang-python">a = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python"># &gt; array([[0, 1, 2, 3, 4],# &gt;        [5, 6, 7, 8, 9],# &gt;        [1, 1, 1, 1, 1],# &gt;        [1, 1, 1, 1, 1]])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">a = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)# Answers# Method 1:np.concatenate([a, b], axis=0)# Method 2 (v may means vertical):np.vstack([a, b])# Method 3 (r may means row):np.r_[a, b]# &gt; array([[0, 1, 2, 3, 4],# &gt;        [5, 6, 7, 8, 9],# &gt;        [1, 1, 1, 1, 1],# &gt;        [1, 1, 1, 1, 1]])</code></pre><p>类似的我们可以用以下方法水平叠加两个数组：</p><pre><code class="lang-python"># 使用第二轴concatenatenp.concatenate([a, b], axis=1)# horizontal stacknp.hstack([a, b])# col:np.c_[a, b]# &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],# &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</code></pre><h2 id="复制叠加数组"><a href="#复制叠加数组" class="headerlink" title="复制叠加数组"></a>复制叠加数组</h2><pre><code class="lang-python">np.repeat(a, 3)# &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3])np.tile(a, 3)# &gt; array([1, 2, 3, 1, 2, 3, 1, 2, 3])</code></pre><h2 id="获取两个数组的公共项"><a href="#获取两个数组的公共项" class="headerlink" title="获取两个数组的公共项"></a>获取两个数组的公共项</h2><p><strong>给定：</strong></p><pre><code class="lang-python">a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python">array([2, 4])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])np.intersect1d(a,b)# &gt; array([2, 4])</code></pre><p><strong>补充：</strong></p><ol><li>并集, <code>np.union1d(s ,t)</code>，返回排序的、去重的两个list的合集</li><li>交集, <code>np.intersect1d(s, t, assume_unique=True)</code>返回排序的、去重的两个list的交集，<code>assume_unique</code>保证传入的两个list是去重的，这可以加快运算速度。</li><li>差集, <code>np.setdiff1d(s, t, assume_unique=True)</code>, 返回排序的，去重的差集，assume_unique参数同上。</li></ol><h2 id="使用自定义函数处理数据"><a href="#使用自定义函数处理数据" class="headerlink" title="使用自定义函数处理数据"></a>使用自定义函数处理数据</h2><p><strong>给定：</strong></p><pre><code class="lang-python">def maxx(x, y):    &quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;    if x &gt;= y:        return x    else:        return ymaxx(1, 5)# &gt; 5</code></pre><p><strong>期望的输出：</strong></p><pre><code class="lang-python">a = np.array([5, 7, 9, 8, 6, 4, 5])b = np.array([6, 3, 4, 8, 9, 7, 1])pair_max(a, b)# &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python">def maxx(x, y):    &quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;    if x &gt;= y:        return x    else:        return ypair_max = np.vectorize(maxx, otypes=[float])a = np.array([5, 7, 9, 8, 6, 4, 5])b = np.array([6, 3, 4, 8, 9, 7, 1])pair_max(a, b)# &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</code></pre><h2 id="交换二维数组中的两列"><a href="#交换二维数组中的两列" class="headerlink" title="交换二维数组中的两列"></a>交换二维数组中的两列</h2><p><strong>给定：</strong></p><pre><code class="lang-python">arr = np.arange(9).reshape(3,3)arr</code></pre><p><strong>答案：</strong></p><pre><code class="lang-python"># Inputarr = np.arange(9).reshape(3,3)arr# Solutionarr[:, [1,0,2]]# &gt; array([[1, 0, 2],# &gt;        [4, 3, 5],# &gt;        [7, 6, 8]])</code></pre><p>本质上就是花式索引（Fancy indexing）类似的，交换两行的方法如下：</p><pre><code class="lang-python"># Solutionarr[[1,0,2], :]# &gt; array([[3, 4, 5],# &gt;        [0, 1, 2],# &gt;        [6, 7, 8]])</code></pre><h2 id="创建随机的二维数组"><a href="#创建随机的二维数组" class="headerlink" title="创建随机的二维数组"></a>创建随机的二维数组</h2><pre><code class="lang-python"># Solution Method 1:rand_arr = np.random.randint(low=5, high=10, size=(5,3)) + np.random.random((5,3))# Solution Method 2:rand_arr = np.random.uniform(5,10, size=(5,3))# &gt; [[ 8.50061025  9.10531502  6.85867783]# &gt;  [ 9.76262069  9.87717411  7.13466701]# &gt;  [ 7.48966403  8.33409158  6.16808631]# &gt;  [ 7.75010551  9.94535696  5.27373226]# &gt;  [ 8.0850361   5.56165518  7.31244004]]</code></pre><p>方法一是生成<code>[5,9]</code>的随机整数加上<code>[0,1]</code>的浮点数。</p><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><pre><code class="lang-python"># Inputa = np.array([1,2,3,4,5])b = np.array([4,5,6,7,8])# Solutiondist = np.linalg.norm(a-b)dist# &gt; 6.7082039324993694</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="只打印小数点后三位"><a href="#只打印小数点后三位" class="headerlink" title="只打印小数点后三位"></a>只打印小数点后三位</h3><pre><code class="lang-python">np.set_printoptions(precision=3)</code></pre><p>设置一次只有都会保持该状态。使用该函数时，下同。</p><h3 id="e式科学记数法"><a href="#e式科学记数法" class="headerlink" title="e式科学记数法"></a>e式科学记数法</h3><pre><code class="lang-python">np.set_printoptions(suppress=False)</code></pre><h3 id="限制数组输出中打印的项目数"><a href="#限制数组输出中打印的项目数" class="headerlink" title="限制数组输出中打印的项目数"></a>限制数组输出中打印的项目数</h3><pre><code class="lang-python">np.set_printoptions(threshold=6)</code></pre><p>如果需要输出全部，使用</p><pre><code class="lang-python">np.set_printoptions(threshold=np.nan)</code></pre><h1 id="机器学习相关"><a href="#机器学习相关" class="headerlink" title="机器学习相关"></a>机器学习相关</h1><h2 id="Min-Max-Normalization"><a href="#Min-Max-Normalization" class="headerlink" title="Min-Max Normalization"></a>Min-Max Normalization</h2><pre><code class="lang-python">arr = np.array([1, 2, 3, 4, 5])arr_max, arr_min = arr.max(), arr.min()# Solution Method 1:(arr - arr_min) / (arr_max - arr_min)# Solution Method 2:(arr - arr_min) / arr.ptp()# &gt; [0.   0.25 0.5  0.75 1.  ]</code></pre><h2 id="计算Softmax得分"><a href="#计算Softmax得分" class="headerlink" title="计算Softmax得分"></a>计算Softmax得分</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)sepallength = np.array([float(row[0]) for row in iris])# Solutiondef softmax(x):    &quot;&quot;&quot;Compute softmax values for each sets of scores in x.    https://stackoverflow.com/questions/34968722/how-to-implement-the-softmax-function-in-python&quot;&quot;&quot;    e_x = np.exp(x - np.max(x))    return e_x / e_x.sum(axis=0)print(softmax(sepallength))# &gt; [ 0.002  0.002  0.001  0.001  0.002  0.003  0.001  0.002  0.001  0.002# &gt;   0.003  0.002  0.002  0.001  0.004  0.004  0.003  0.002  0.004  0.002# &gt;   0.003  0.002  0.001  0.002  0.002  0.002  0.002  0.002  0.002  0.001# &gt;   0.002  0.003  0.002  0.003  0.002  0.002  0.003  0.002  0.001  0.002# &gt;   0.002  0.001  0.001  0.002  0.002  0.002  0.002  0.001  0.003  0.002# &gt;   0.015  0.008  0.013  0.003  0.009  0.004  0.007  0.002  0.01   0.002# &gt;   0.002  0.005  0.005  0.006  0.004  0.011  0.004  0.004  0.007  0.004# &gt;   0.005  0.006  0.007  0.006  0.008  0.01   0.012  0.011  0.005  0.004# &gt;   0.003  0.003  0.004  0.005  0.003  0.005  0.011  0.007  0.004  0.003# &gt;   0.003  0.006  0.004  0.002  0.004  0.004  0.004  0.007  0.002  0.004# &gt;   0.007  0.004  0.016  0.007  0.009  0.027  0.002  0.02   0.011  0.018# &gt;   0.009  0.008  0.012  0.004  0.004  0.008  0.009  0.03   0.03   0.005# &gt;   0.013  0.004  0.03   0.007  0.011  0.018  0.007  0.006  0.008  0.018# &gt;   0.022  0.037  0.008  0.007  0.006  0.03   0.007  0.008  0.005  0.013# &gt;   0.011  0.013  0.004  0.012  0.011  0.011  0.007  0.009  0.007  0.005]</code></pre><p>Softmax可以见<a href="http://cs231n.github.io/linear-classify/#softmax" target="_blank" rel="noopener">这篇</a>。</p><h2 id="数组的百分位数"><a href="#数组的百分位数" class="headerlink" title="数组的百分位数"></a>数组的百分位数</h2><p>找到鸢尾属植物数据集的第5和第95百分位数</p><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;sepallength = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0])# Solutionnp.percentile(sepallength, q=[5, 95])# &gt; array([ 4.6  ,  7.255])</code></pre><h2 id="找到数组中缺失值的位置"><a href="#找到数组中缺失值的位置" class="headerlink" title="找到数组中缺失值的位置"></a>找到数组中缺失值的位置</h2><p>在iris_2d的sepallength中查找缺失值的数量和位置（第1列）</p><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan# Solutionprint(&quot;Number of missing values: \n&quot;, np.isnan(iris_2d[:, 0]).sum())print(&quot;Position of missing values: \n&quot;, np.where(np.isnan(iris_2d[:, 0])))# &gt; Number of missing values: # &gt;  5# &gt; Position of missing values: # &gt;  (array([ 39,  88,  99, 130, 147]),)</code></pre><p><code>np.isnan()</code>会返回一个布尔型的数组。</p><h2 id="从数组中删除包含缺失值的行"><a href="#从数组中删除包含缺失值的行" class="headerlink" title="从数组中删除包含缺失值的行"></a>从数组中删除包含缺失值的行</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan # 手动插入一些nan# Solution# No direct numpy function for this.# Method 1:any_nan_in_row = np.array([~np.any(np.isnan(row)) for row in iris_2d]) # ~表示按位取反iris_2d[any_nan_in_row][:5]# Method 2: (By Rong)iris_2d[np.sum(np.isnan(iris_2d), axis = 1) == 0][:5]# &gt; array([[ 4.9,  3. ,  1.4,  0.2],# &gt;        [ 4.7,  3.2,  1.3,  0.2],# &gt;        [ 4.6,  3.1,  1.5,  0.2],# &gt;        [ 5. ,  3.6,  1.4,  0.2],# &gt;        [ 5.4,  3.9,  1.7,  0.4]])</code></pre><p><code>numpy.any</code>(<em>a</em>, <em>axis=None**</em>,<strong> <em>out=None</em></strong>,<em>* </em>keepdims=<no value>*)有真值时返回1，没有时返回0。<br>注意<code>np.nan == np.nan</code>返回的是<code>False</code>，需要使用<code>np.isnan()</code>。</p><h2 id="数组两列之间的相关性"><a href="#数组两列之间的相关性" class="headerlink" title="数组两列之间的相关性"></a>数组两列之间的相关性</h2><pre><code class="lang-python"># Inputurl = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])# Solution 1np.corrcoef(iris[:, 0], iris[:, 2])[0, 1]# Solution 2from scipy.stats.stats import pearsonr  corr, p_value = pearsonr(iris[:, 0], iris[:, 2])print(corr)# Correlation coef indicates the degree of linear relationship between two numeric variables.# It can range between -1 to +1.# The p-value roughly indicates the probability of an uncorrelated system producing # datasets that have a correlation at least as extreme as the one computed.# The lower the p-value (&lt;0.01), stronger is the significance of the relationship.# It is not an indicator of the strength.# &gt; 0.871754157305</code></pre><p>协方差和相关系数请见<a href="https://blog.csdn.net/iloveyousunna/article/details/77948219" target="_blank" rel="noopener">这篇</a>。</p><h2 id="数组的现有列中创建新列"><a href="#数组的现有列中创建新列" class="headerlink" title="数组的现有列中创建新列"></a>数组的现有列中创建新列</h2><p>在iris_2d中为卷创建一个新列，其中volume是<code>（pi x petallength x sepal_length ^ 2）/ 3</code></p><pre><code class="lang-python"># Compute volumesepallength = iris_2d[:, 0].astype(&#39;float&#39;)petallength = iris_2d[:, 2].astype(&#39;float&#39;)volume = (np.pi * petallength * (sepallength**2))/3# Introduce new dimension to match iris_2d&#39;svolume = volume[:, np.newaxis]# Add the new columnout = np.hstack([iris_2d, volume])# Viewout[:4]# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 38.13265162927291],# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 35.200498485922445],# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 30.0723720777127],# &gt;        [b&#39;4.6&#39;, b&#39;3.1&#39;, b&#39;1.5&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 33.238050274980004]], dtype=object)</code></pre><h2 id="概率抽样"><a href="#概率抽样" class="headerlink" title="概率抽样"></a>概率抽样</h2><p>随机抽鸢尾属植物的种类，使得刚毛的数量是云芝和维吉尼亚的两倍</p><pre><code class="lang-python"># Get the species columnspecies = iris[:, 4]# Approach 1: Generate Probablisticallynp.random.seed(100)a = np.array([&#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;])species_out = np.random.choice(a, 150, p=[0.5, 0.25, 0.25])# Approach 2: Probablistic Sampling (preferred)np.random.seed(100)probs = np.r_[np.linspace(0, 0.500, num=50), np.linspace(0.501, .750, num=50), np.linspace(.751, 1.0, num=50)]index = np.searchsorted(probs, np.random.random(150))species_out = species[index]print(np.unique(species_out, return_counts=True))# &gt; (array([b&#39;Iris-setosa&#39;, b&#39;Iris-versicolor&#39;, b&#39;Iris-virginica&#39;], dtype=object), array([77, 37, 36]))</code></pre><p>方法2是首选方法，因为它创建了一个索引变量，该变量可用于取样2维表格数据。</p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>根据sepallength列对数据集进行排序。</p><pre><code class="lang-python"># Sort by column position 0: SepalLengthprint(iris[iris[:,0].argsort()][:5])</code></pre><p>利用<code>unique()</code>获取第K大的值：</p><pre><code class="lang-python"># Get the species and petal length columnspetal_len_setosa = iris[iris[:, 4] == b&#39;Iris-setosa&#39;, [2]].astype(&#39;float&#39;)# Get the second last valuenp.unique(np.sort(petal_len_setosa))[-2]</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/advanced/numpy_exercises_for_data_analysis.html#numpy数据分析问答" target="_blank" rel="noopener">https://www.numpy.org.cn/article/advanced/numpy_exercises_for_data_analysis.html#numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%97%AE%E7%AD%94</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>NumPy</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy基础</title>
    <link href="/2020/02/27/NumPy/"/>
    <url>/2020/02/27/NumPy/</url>
    
    <content type="html"><![CDATA[<p>python常用库——NumPy</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词—— <code>Numerical</code>和<code>Python</code>。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><h1 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h1><p>NumPy围绕<code>ndarrays</code>展开的。它可以完成如下操作：</p><pre><code class="lang-python">a = np.array([1, 2, 3])   # Create a rank 1 arrayprint(type(a))            # Prints &quot;&lt;class &#39;numpy.ndarray&#39;&gt;&quot;print(a.shape)            # Prints &quot;(3,)&quot;print(a[0], a[1], a[2])   # Prints &quot;1 2 3&quot;a[0] = 5                  # Change an element of the arrayprint(a)                  # Prints &quot;[5, 2, 3]&quot;b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 arrayprint(b.shape)                     # Prints &quot;(2, 3)&quot;print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</code></pre><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>可以通过<code>ndarray</code>类的属性获取数组属性：</p><pre><code class="lang-python"># Array propertiesa = np.array([[11, 12, 13, 14, 15],              [16, 17, 18, 19, 20],              [21, 22, 23, 24, 25],              [26, 27, 28 ,29, 30],              [31, 32, 33, 34, 35]])print(type(a)) # &gt;&gt;&gt;&lt;class &#39;numpy.ndarray&#39;&gt;# 数据类型print(a.dtype) # &gt;&gt;&gt;int64# 总数据量print(a.size) # &gt;&gt;&gt;25# 数组形状print(a.shape) # &gt;&gt;&gt;(5, 5)# 每项占用的字节数，这里int64占用8字节print(a.itemsize) # &gt;&gt;&gt;8# 数组维度print(a.ndim) # &gt;&gt;&gt;2# 所有数据消耗的字节数，小于等于数组占据的总字节数print(a.nbytes) # &gt;&gt;&gt;200</code></pre><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p><code>ndarray</code>支持以下运算操作，</p><pre><code class="lang-python">import numpy as np# Basic Operatorsa = np.arange(25)a = a.reshape((5, 5))print(a)b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45,              4, 92, 5, 55, 63, 43, 35, 6, 53, 24,              56, 3, 56, 44, 78])b = b.reshape((5,5))print(a + b)print(a - b)print(a * b)print(a / b)print(a ** 2)print(a &lt; b)print(a &gt; b)print(a.dot(b))</code></pre><p>除了<code>dot()</code>之外，这些操作符都是对数组进行逐元素运算。比如<code>(a, b, c) + (d, e, f)</code>的结果就是<code>(a+d, b+e, c+f)</code>。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。注意，当使用逻辑运算符比如 “&lt;” 和 “&gt;” 的时候，返回的将是一个布尔型数组。<code>dot()</code> 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。</p><p>NumPy还提供了一些别的用于处理数组的好用的运算符。</p><pre><code class="lang-python"># dot, sum, min, max, cumsuma = np.arange(10)print(a.sum()) # &gt;&gt;&gt;45print(a.min()) # &gt;&gt;&gt;0print(a.max()) # &gt;&gt;&gt;9print(a.cumsum()) # &gt;&gt;&gt;[ 0  1  3  6 10 15 21 28 36 45]</code></pre><p><code>sum()</code>、<code>min()</code>和<code>max()</code>函数的作用非常明显。将所有元素相加，找出最小和最大元素。<code>cumsum()</code>函数保存从第二个数开始每个数和之前所有数之和。</p><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p><img src="numpy_2D_slicing_diagram-1.jpg" alt=""></p><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引是获取数组中多个特定元素的有效方法：</p><pre><code class="lang-python"># Fancy indexinga = np.arange(0, 100)a = a.reshape(10, 10)indices = [1, 5, -1]b = a[1, indices]print(b) # &gt;&gt;&gt;[11 15 19]</code></pre><h3 id="布尔屏蔽"><a href="#布尔屏蔽" class="headerlink" title="布尔屏蔽"></a>布尔屏蔽</h3><p>布尔屏蔽是根据指定的条件检索数组中的元素：</p><pre><code class="lang-python"># Boolean maskingimport numpy as npimport matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)mask = b &gt;= 0plt.plot(a[mask], b[mask], &#39;bo&#39;)mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], &#39;go&#39;)plt.show()</code></pre><p>之所以叫布尔屏蔽，应该是这里的<code>mask</code>是由布尔值组成的。结果如下图：</p><p><img src="Figure_1.png" alt=""></p><h3 id="缺省索引"><a href="#缺省索引" class="headerlink" title="缺省索引"></a>缺省索引</h3><p>不完全索引是从多维数组的第一个维度获取索引或切片的一种方便方法。</p><pre><code class="lang-python"># Incomplete Indexinga = np.arange(0, 100, 10)b = a[:5]c = a[a &lt; 50]print(b) # &gt;&gt;&gt;[ 0 10 20 30 40]print(c) # &gt;&gt;&gt;[ 0 10 20 30 40]</code></pre><h3 id="Where-函数"><a href="#Where-函数" class="headerlink" title="Where 函数"></a>Where 函数</h3><p><code>where()</code>函数分为两种情况，三个参数和单个参数。</p><ol><li>三个参数<code>where(cond, x, y)</code>：满足条件cond输出x，不满足输出y。</li><li>一个参数<code>where(array)</code>：输出<code>array</code>中真值（非零值）的坐标。</li></ol><pre><code class="lang-python"># Wherea = np.arange(0, 100, 10)a=a.reshape(2, 5)print(a)&#39;&#39;&#39;&gt;&gt;&gt;[[ 0 10 20 30 40] [50 60 70 80 90]]&#39;&#39;&#39;print(a % 20 == 0)&#39;&#39;&#39;&gt;&gt;&gt;[[ True False  True False  True] [False  True False  True False]]&#39;&#39;&#39;b = np.where(a % 20 == 0) c = np.where(a % 20 == 0)[0]print(b) # &gt;&gt;&gt;(array([0, 0, 0, 1, 1], dtype=int64), array([0, 2, 4, 1, 3], dtype=int64))print(c) # &gt;&gt;&gt;[0 0 0 1 1]</code></pre><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>当维度不同的两个数组做运算时，自动将维度小的扩展成和另一个数组相同形状的处理就是广播。以下内容详情见参考[2]。</p><p>将两个数组一起广播遵循以下规则：</p><ol><li>如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。</li><li>如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。</li><li>如果数组在所有维度上兼容，则可以一起广播。</li><li>广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li><li>在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样</li></ol><pre><code class="lang-python">import numpy as np# Compute outer product of vectorsv = np.array([1,2,3])  # v has shape (3,)w = np.array([4,5])    # w has shape (2,)# To compute an outer product, we first reshape v to be a column# vector of shape (3, 1); we can then broadcast it against w to yield# an output of shape (3, 2), which is the outer product of v and w:# [[ 4  5]#  [ 8 10]#  [12 15]]print(np.reshape(v, (3, 1)) * w)# Add a vector to each row of a matrixx = np.array([[1,2,3], [4,5,6]])# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),# giving the following matrix:# [[2 4 6]#  [5 7 9]]print(x + v)# Add a vector to each column of a matrix# x has shape (2, 3) and w has shape (2,).# If we transpose x then it has shape (3, 2) and can be broadcast# against w to yield a result of shape (3, 2); transposing this result# yields the final result of shape (2, 3) which is the matrix x with# the vector w added to each column. Gives the following matrix:# [[ 5  6  7]#  [ 9 10 11]]print((x.T + w).T)# Another solution is to reshape w to be a column vector of shape (2, 1);# we can then broadcast it directly against x to produce the same# output.print(x + np.reshape(w, (2, 1)))# Multiply a matrix by a constant:# x has shape (2, 3). Numpy treats scalars as arrays of shape ();# these can be broadcast together to shape (2, 3), producing the# following array:# [[ 2  4  6]#  [ 8 10 12]]print(x * 2)</code></pre><p>注意：对一个<code>array</code>转置可以使用<code>array.T</code>，或者使用<code>np.reshape()</code>。对于矩阵可使用<code>np.transpose()</code>。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="arange-和linspace"><a href="#arange-和linspace" class="headerlink" title="arange()和linspace()"></a>arange()和linspace()</h2><p><code>arange()</code>类似于内置函数<code>range()</code>，通过指定开始值、终值和步长创建表示等差数列的一维数组，<strong>得到的结果数组不包含终值</strong>。</p><p><code>linspace()</code>通过指定开始值、终值和元素个数创建表示等差数列的一维数组。</p><pre><code class="lang-python">numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)</code></pre><ul><li>在<code>start</code>和<code>stop</code>之间返回均匀间隔的<code>num</code>个数据</li><li><code>endpoint</code>控制是否包含<code>stop</code>点</li><li><code>retstep</code>控制是否返回间隔</li><li><code>axis</code>仅当<code>start</code>和<code>stop</code>为<code>array</code>时才有效，传入一维<code>array</code>时可取0或-1，<code>axis = -1</code> 相当于转置</li></ul><pre><code class="lang-python">a = np.linspace(1, 5, num=5, endpoint=True, retstep=True)print(a) # &gt;&gt;&gt;(array([1., 2., 3., 4., 5.]), 1.0)b = np.linspace([1,3,5], [1,5,7], num=5, endpoint=True, retstep=True, axis=0)print(b) &#39;&#39;&#39;&gt;&gt;&gt;(array([[1. , 1. , 1. , 1. , 1. ],       [3. , 3.5, 4. , 4.5, 5. ],       [5. , 5.5, 6. , 6.5, 7. ]]), array([0. , 0.5, 0.5]))&#39;&#39;&#39; c = np.linspace([1,3,5], [1,5,7], num=5, endpoint=True, retstep=True, axis=-1)print(c)&#39;&#39;&#39;&gt;&gt;&gt;(array([[1. , 3. , 5. ],       [1. , 3.5, 5.5],       [1. , 4. , 6. ],       [1. , 4.5, 6.5],       [1. , 5. , 7. ]]), array([0. , 0.5, 0.5]))&#39;&#39;&#39;</code></pre><p>当然也可以这样用：</p><pre><code class="lang-python">d = np.linspace([[1,3],[5,7]], [[1,5],[7,9]], num=5, endpoint=True, retstep=True, axis=2)</code></pre><p>多维数组的<code>axis</code>有些难理解，可以参考<a href="https://blog.csdn.net/m0_37673307/article/details/82118030" target="_blank" rel="noopener">这篇</a>，当传入n维数组时，<code>axis=n-1</code>与<code>axis=-1</code>等效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/basics/an_introduction_to_scientific_python_numpy.html#创建一个数组" target="_blank" rel="noopener">https://www.numpy.org.cn/article/basics/an_introduction_to_scientific_python_numpy.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84</a></li><li><a href="http://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">http://cs231n.github.io/python-numpy-tutorial/</a></li><li><a href="https://www.zhihu.com/question/62844162" target="_blank" rel="noopener">https://www.zhihu.com/question/62844162</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记五</title>
    <link href="/2020/02/22/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <url>/2020/02/22/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>图像梯度和边缘检测</p><a id="more"></a><h1 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h1><p>在谈及梯度之前需要先找到函数，图片是二维的离散函数，二维意味着需要找到求梯度的方向，离散意味着对于图片的梯度不是导数而是差分。下式就是按照水平从左到右方向每隔一个像素点求差分：</p><script type="math/tex; mode=display">\Delta f\left ( i,j \right )=f\left ( i+1,j \right )-f\left ( i,j \right )</script><h2 id="Prewitt-operator"><a href="#Prewitt-operator" class="headerlink" title="Prewitt operator"></a>Prewitt operator</h2><p>将上式用卷积的方式处理是就可以是有下面这个卷积核（Prewitt 边缘检测算子）：</p><script type="math/tex; mode=display">Prewitt = \frac{1}{9}\left[ \begin{matrix} -1 & 0 & 1 \newline -1 & 0 & 1 \newline -1 & 0 & 1 \end{matrix} \right]</script><p>使用Prewitt 算子处理后，值比较高的像素点意味着梯度较大，就是更解决边缘；值比较低的像素点意味着梯度较小，就是更解决平滑表面。</p><h2 id="Sobel-operator"><a href="#Sobel-operator" class="headerlink" title="Sobel operator"></a>Sobel operator</h2><p>考虑到对正在处理行的数据需要更多的重视，对Prewitt 边缘检测算子改进就形成了Sobel 边缘检测算子：</p><script type="math/tex; mode=display">Sobel_{x} = \frac{1}{9}\left[ \begin{matrix} -1 & 0 & 1 \newline -2 & 0 & 2 \newline -1 & 0 & 1 \end{matrix} \right]</script><p>如果是从上到下求差分那么算子就转换成：</p><script type="math/tex; mode=display">Sobel_{y} = \frac{1}{9}\left[ \begin{matrix} -1 & -2 & -1 \newline 0 & 0 & 0 \newline 1 & 2 & 1 \end{matrix} \right]</script><p>分别计算偏 x 方向的 <script type="math/tex">G_{x}</script>，偏 y 方向的 <script type="math/tex">G_{y}</script>，求绝对值，压缩到 [0, 255]区间，即 <script type="math/tex">G\left ( x,y \right )=G_{x}+G_{y}</script> 就是 sobel 边缘检测后的图像。</p><h2 id="Scharr-operator"><a href="#Scharr-operator" class="headerlink" title="Scharr operator"></a>Scharr operator</h2><p>Sobel算子在转动上没有完美的对称。因此Scharr想要改进这个特性。它曾提出了更大的5x5核心，不过后来最常被使用的是:</p><script type="math/tex; mode=display">Scharr_{x} = \frac{1}{9}\left[ \begin{matrix} 3 & 0 & -3 \newline 10 & 0 & -10 \newline 3 & 0 & -3 \end{matrix} \right]</script><p>或者：</p><script type="math/tex; mode=display">Scharr_{y} = \frac{1}{9}\left[ \begin{matrix} 3 & 10 & 3 \newline 0 & 0 & 0 \newline -3 & -10 & -3 \end{matrix} \right]</script><h2 id="Laplacian"><a href="#Laplacian" class="headerlink" title="Laplacian"></a>Laplacian</h2><p>上面两种算子都是针对图像这种二维离散函数求一阶差分得到的，而Laplace 算子则是求二阶差分。二阶差分定义如下：</p><script type="math/tex; mode=display">\Delta^{2} \left [f  \right ]\left ( i, j \right )=f\left ( i+1, j \right )-2f\left ( i, j \right )+f\left ( i-1, j \right )</script><p>包含x轴、y轴两个方向的卷积核为：</p><script type="math/tex; mode=display">Laplacian_{2} = \frac{1}{9}\left[ \begin{matrix} 0 & 1 & 0 \newline 1 & -4 & 1 \newline 0 & 1 & 0 \end{matrix} \right]</script><p>包含四个方向的卷积核为：</p><script type="math/tex; mode=display">Laplacian_{4} = \frac{1}{9}\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & -8 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><p>使用Laplace 算子处理后，由于所求为二阶差分，值接近0的像素点更有可能是边缘，但是对于灰度值相近的区域，经过卷积后的值也很接近0。</p><h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h2 id="Sobel"><a href="#Sobel" class="headerlink" title="Sobel"></a>Sobel</h2><pre><code class="lang-python">dst = cv.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/差分" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">https://www.jianshu.com/p/2334bee37de5</a></li><li><a href="https://blog.csdn.net/zhougynui/article/details/78837198" target="_blank" rel="noopener">https://blog.csdn.net/zhougynui/article/details/78837198</a></li><li><a href="https://zh.wikipedia.org/wiki/索貝爾算子" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B4%A2%E8%B2%9D%E7%88%BE%E7%AE%97%E5%AD%90</a></li><li><a href="http://codec.wang/opencv-python-edge-detection/" target="_blank" rel="noopener">http://codec.wang/opencv-python-edge-detection/</a></li><li><a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaa13106761eedf14798f37aa2d60404c9" target="_blank" rel="noopener">https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaa13106761eedf14798f37aa2d60404c9</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记四</title>
    <link href="/2020/02/20/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <url>/2020/02/20/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>NumPy的使用以及图片亮度和对比度分析</p><a id="more"></a><h1 id="OpenCV与NumPy"><a href="#OpenCV与NumPy" class="headerlink" title="OpenCV与NumPy"></a>OpenCV与NumPy</h1><p>OpenCV读取一张图片，返回的实际上是一个<code>numpy.ndarray</code>类。所以一些对<code>numpy.ndarray</code>的操作可以直接对<code>cv2.imread()</code>返回的对象使用。</p><pre><code class="lang-python">import cv2import numpy as npimg = cv2.imread(&#39;connelly.jpg&#39;)print(type(img)) # &lt;class &#39;numpy.ndarray&#39;&gt;rows, cols = img.shape[:2]print(rows, cols) # 210 270</code></pre><h2 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h2><p>根据像素值的行和列坐标可以访问特定像素点。对于BGR图像，它返回一个蓝色、绿色、红色值数组。灰度图像，只返回相应的亮度。</p><pre><code class="lang-python">px = img[100, 120]img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)px_gray = img_gray[100, 120]print(px) # [130 131 181]print(px_gray) # 146</code></pre><p>可以用同样的方式修改像素值。</p><pre><code class="lang-python">img[100, 120] = [255,255,255]</code></pre><p>NumPy是一个用于快速数组计算的优化库。因此，使用原生python的数组简单地访问每个像素值，并修改它将非常缓慢，不推荐这种方法。</p><p>上述方法通常用于选择数组区域，例如前5行和最后3列。对于单个像素访问，但用NumPy数组的方法、<code>array.tem()</code>和<code>array.itemset()</code>会更适合。因为它总是返回一个标量。因此，如果想访问所有的B，G，R值，你需要为所有通道分别调用<code>array.tem()</code>。</p><pre><code class="lang-python"># 获取红色通道值print(img.item(100, 120, 2)) # 181# 修改红色通道值img.itemset((100, 120, 2), 255)</code></pre><h2 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h2><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p><p><code>img.shape</code>可以访问图像的形状。 它返回一组行，列和通道的元组（如果图像是彩色的），如果图像是灰度，则返回的元组仅包含行数和列数。因此，检查加载的图像是灰度还是彩色图像是一种很好的方法。：</p><pre><code class="lang-python">print(img.shape) # (210, 270, 3)</code></pre><p><code>img.size</code>访问的像素总数：</p><pre><code class="lang-python">print(img.size) # 170100</code></pre><p>图像数据类型由<code>img.dtype</code>获得：</p><pre><code class="lang-python">print(img.dtype) # uint8</code></pre><p> <code>img.dtype</code>在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。</p><h2 id="提取ROI"><a href="#提取ROI" class="headerlink" title="提取ROI"></a>提取ROI</h2><p>ROI (Region of Interest)即感兴趣的区域，</p><pre><code class="lang-python">roi = img[100:200, 200:300]</code></pre><ul><li>直接指定范围即可，上面表示行数为<code>100-200</code>，列数为<code>200-300</code>的区域</li></ul><h2 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h2><p>有时需要在B,G,R通道图像上单独工作。需要将BGR图像分割为单个平面或者需要将这些单独的通道连接到BGR图像。可以通过以下方式完成：</p><pre><code class="lang-python">b,g,r = cv2.split(img)img = cv2.merge((b,g,r))</code></pre><p><code>cv2.split()</code> 是一项代价昂贵的的操作（就运算时间而言）。所以只有在需要时才使用这个方法。否则请使用Numpy索引。</p><pre><code class="lang-python">b = img[:,:,0]</code></pre><p>假设，想要将所有红色像素设为零，不需要像这样分割并将其等于零。 可以简单地使用Numpy索引，这样更快。</p><pre><code class="lang-python">img[:,:,2] = 0</code></pre><h1 id="图片亮度和对比度"><a href="#图片亮度和对比度" class="headerlink" title="图片亮度和对比度"></a>图片亮度和对比度</h1><p>简单的改变图片的亮度和对比度可以是一个线性的过程：</p><script type="math/tex; mode=display">g\left (i,j  \right )= \alpha \cdot f\left ( i,j \right )+\beta\tag{1}</script><p>式子1中<script type="math/tex">f\left ( i,j \right )</script>相当于就是原图像每个像素点对应色彩或灰度的映射。直观上看，<script type="math/tex">\alpha</script>决定了对比度，<script type="math/tex">\alpha</script>越大，各像素之间的差别越大，对比度越大。<script type="math/tex">\beta</script>决定了亮度，<script type="math/tex">\beta</script>越大，各像素整体都变大，亮度提升了。</p><p>但其实这种表述并不准确，因为在对图像进行线性处理时存在溢出的问题，当<script type="math/tex">\beta</script>值太大时，<script type="math/tex">g\left (i,j  \right )</script>由于超过数据类型的上限被OpenCV置为特定值（比如CV_8U会被置为255）。对于灰度图，这些值都被置为相同值，相当于这部分像素点对比度调节完全失效了；对于三通道的彩色图，有一部分通道溢出，则会导致对比度比预期小的现象。</p><p>另一个层面上，<script type="math/tex">\alpha</script>的改变也影响了亮度，因为上式中<script type="math/tex">\alpha</script>的变化会统一的放大或缩小所有像素点的灰度值。当想要提高对比度时，如果不变化<script type="math/tex">\beta</script>的值，视觉上的”亮度“还是会提升。不妨把上式改写成如下式子：</p><script type="math/tex; mode=display">g\left (i,j  \right )= \alpha \cdot \left (f\left ( i,j \right )-T  \right )+\beta\tag{2}</script><p>当<script type="math/tex">\alpha</script>大于1时，式子2表示将比T小的像素点的灰度值变得更小，把比T大的像素点的灰度值变得更大，这样当T值等于图像的平均灰度值（当然，是否就是平均灰度值也有待商榷）时就不会带来<script type="math/tex">\alpha</script>的改变影响亮度的问题了。式子1实际上就是式子2中T等于0的特例，所有像素点的灰度值都大于等于0，所以整幅图像的亮度被<script type="math/tex">\alpha</script>影响了。</p><p>完整的调整代码如下：</p><pre><code class="lang-python">import cv2import numpy as npimg = cv2.imread(&#39;connelly.jpg&#39;)# 此处需注意，下面有说明res = np.uint8(np.clip((2 * (np.int16(img) - 60) + 50), 0, 255))tmp = np.hstack((img, res))  # 两张图片横向合并显示cv2.imshow(&#39;image&#39;, tmp)cv2.waitKey(0)</code></pre><p>输出效果如下：</p><p><img src="compare.jpg" alt=""></p><p>在用python改变图片的亮度和对比度时，有两个问题需要注意，第一个问题是数据类型，式子中其实有一个乘法，这是极有可能出现溢出的，如果代码是这样<code>res = np.uint8(np.clip((2 * img - 60) + 50), 0, 255))</code>，就会出现这样的结果:</p><p><img src="compare_wrong.jpg" alt=""></p><p>解决的办法有两个，一是改变img的类型：使用<code>np.int16(img)</code>代替<code>img</code>；二是用浮点数<code>2.0</code>代替<code>2</code>，这样<code>2.0 * img</code>的数据类型会自动变成<code>float64</code>。</p><pre><code class="lang-python">print((2.0 * img).dtype) # float64</code></pre><p>第二个问题是对于溢出NumPy和OpenCV的处理方式不同：</p><pre><code class="lang-python">x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y))  # 250 + 10 = 260 =&gt; 255 --255封顶print(x + y)  # 250 + 10 = 260 % 256 = 4 --会溢出</code></pre><p>如果我们使用NumPy处理就需要使用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener"><code>np.clip()</code></a>函数将数据限定在0~255。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.numpy.org.cn/article/other/py_basic_ops.html#目标" target="_blank" rel="noopener">https://www.numpy.org.cn/article/other/py_basic_ops.html#%E7%9B%AE%E6%A0%87</a></li><li><a href="https://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">https://blog.csdn.net/abc20002929/article/details/40474807</a></li><li><a href="https://docs.opencv.org/2.4/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html#basic-linear-transform" target="_blank" rel="noopener">https://docs.opencv.org/2.4/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html#basic-linear-transform</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NumPy</tag>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记三</title>
    <link href="/2020/02/19/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <url>/2020/02/19/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>图像混合与形态学操作</p><a id="more"></a><h1 id="图片混合"><a href="#图片混合" class="headerlink" title="图片混合"></a>图片混合</h1><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>图像混合<code>cv2.addWeighted()</code>要求两幅图片的形状（高度/宽度/通道数）必须相同，<script type="math/tex">\omega_{1}</script>和<script type="math/tex">\omega_{2}</script>分别为两幅图像的权重，b则是一个偏置：</p><script type="math/tex; mode=display">dst = \omega_{1}\times img1+\omega_{2}\times img2 + b</script><pre><code class="lang-python">img1 = cv2.imread(&#39;img1_name.jpg&#39;)img2 = cv2.imread(&#39;img2_name.png&#39;)res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0)</code></pre><p>特别的，当<script type="math/tex">\omega_{1}</script>和<script type="math/tex">\omega_{2}</script>都为1，b为0时，就是两张图片相加。可以用<code>cv2.add()</code>函数。numpy 中可以直接用<code>res = img1 + img2</code>相加，但这两者的结果并不相同：</p><pre><code class="lang-python">x = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y))  # 250 + 10 = 260 =&gt; 255 --255封顶print(x + y)  # 250 + 10 = 260 % 256 = 4 --会溢出</code></pre><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>按位操作包括按位与/或/非/异或操作，如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。</p><ul><li><code>cv2.bitwise_and()</code>：按位与操作 </li><li><code>cv2.bitwise_not()</code>：按位非操作</li><li><code>cv2.bitwise_or()</code>：按位或操作</li><li><code>cv2.bitwise_xor()</code>：按位异或操作</li></ul><p>通过位操作，我们可以得到<a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a>（mask）——用来对另外一幅图片进行局部的遮挡的二值化图片，通过掩膜把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><pre><code class="lang-python">import cv2img1 = cv2.imread(&#39;lena.jpg&#39;)img2 = cv2.imread(&#39;opencv-logo-white.png&#39;)# 把logo放在左上角，所以我们只关心这一块区域rows, cols = img2.shape[:2]roi = img1[:rows, :cols]# 创建掩膜img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)mask_inv = cv2.bitwise_not(mask)# 保留除logo外的背景img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)dst = cv2.add(img1_bg, img2)  # 进行融合img1[:rows, :cols] = dst  # 融合后放在原图上cv2.imshow(&quot;dst&quot;,img1)cv2.waitKey(10000)</code></pre><p><img src="2020-02-20 124157.png" alt=""></p><h1 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h1><h2 id="腐蚀膨胀"><a href="#腐蚀膨胀" class="headerlink" title="腐蚀膨胀"></a>腐蚀膨胀</h2><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有 0 和 255 ，所以小区域内有一个是 0 该像素点就为 0 。</p><p><img src="cv2_understand_erosion.jpg" alt=""></p><pre><code class="lang-python"># 腐蚀img = cv2.imread(&#39;j.bmp&#39;, 0)kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel)</code></pre><ul><li><code>kernel</code>：结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素：<ul><li>矩形结构：<code>cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))</code>  </li><li>椭圆结构：<code>cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))</code>  </li><li>十字形结构：<code>cv2.getStructuringElement(cv2.MORPH_CROSS, (5, 5))</code></li></ul></li></ul><p><img src="cv2_morphological_struct_element.jpg" alt=""></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片”变胖”：</p><pre><code class="lang-python"># 膨胀dilation = cv2.dilate(img, kernel)</code></pre><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住），其作用是：分离物体，消除小区域。这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p><pre><code class="lang-python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))  # 定义结构元素img = cv2.imread(&#39;j_noise_out.bmp&#39;, 0)opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  # 开运算</code></pre><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p><pre><code class="lang-python">img = cv2.imread(&#39;j_noise_in.bmp&#39;, 0)closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  # 闭运算</code></pre><p><img src="cv2_morphological_opening_closing.jpg" alt=""></p><h2 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h2><ul><li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li></ul><pre><code class="lang-python">img = cv2.imread(&#39;school.bmp&#39;, 0)gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</code></pre><ul><li>顶帽：原图减去开运算后的图：<code>src - opening</code></li></ul><pre><code class="lang-python">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</code></pre><ul><li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li></ul><pre><code class="lang-python">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://codec.wang/opencv-python-erode-and-dilate/" target="_blank" rel="noopener">http://codec.wang/opencv-python-erode-and-dilate/</a></li><li><a href="http://codec.wang/opencv-python-image-blending/" target="_blank" rel="noopener">http://codec.wang/opencv-python-image-blending/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记二</title>
    <link href="/2020/02/17/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/02/17/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>滤波与阈值分割</p><a id="more"></a><h1 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h1><p>滤波是一种卷积操作，常用于图像的预处理。低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。</p><ul><li>低通滤波器是模糊</li><li>高通滤波器是锐化</li></ul><p>常见噪声有<a href="https://baike.baidu.com/item/椒盐噪声/3455958?fr=aladdin" target="_blank" rel="noopener">椒盐噪声</a>和<a href="https://baike.baidu.com/item/高斯噪声" target="_blank" rel="noopener">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><script type="math/tex; mode=display">kernel_{m} = \frac{1}{9}\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & 1 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><pre><code class="lang-python">img = cv2.imread(&#39;lena.jpg&#39;)blur = cv2.blur(img, (3, 3))  # 均值模糊</code></pre><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><script type="math/tex; mode=display">kernel_{b} = a\left[ \begin{matrix} 1 & 1 & 1 \newline 1 & 1 & 1 \newline 1 & 1 & 1 \end{matrix} \right]</script><p>用<code>cv2.boxFilter()</code>函数实现，当</p><pre><code class="lang-python"># 前面的均值滤波也可以用方框滤波实现blur = cv2.boxFilter(img, -1, (3, 3), normalize=True)</code></pre><ul><li>参数2：<code>ddtype</code>为目标的数据类型，取-1表示和原图相同</li><li>可选参数<code>normalize</code>为<code>True</code>的时候，方框滤波就是均值滤波，上式中的a就等于1/9；<code>normalize</code>为<code>False</code>的时候，a=1，相当于求区域内的像素和。</li></ul><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小。显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a href="http://codec.wang/opencv-python-smoothing-images/#番外小篇：高斯滤波卷积核" target="_blank" rel="noopener">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核：</p><script type="math/tex; mode=display">kernel_{g} = \left[ \begin{matrix} 0.0625 & 0.125 & 0.0625 \newline 0.125 & 0.25 & 0.125 \newline 0.0625 & 0.125 & 0.0625 \end{matrix} \right]</script><p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><pre><code class="lang-python"># 高斯滤波gaussian = cv2.GaussianBlur(img, (5, 5), 1)</code></pre><p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。</p><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除<strong>椒盐噪声</strong>和<strong>斑点噪声</strong>。中值是一种<strong>非线性操作</strong>，效率相比前面几种线性滤波要慢。</p><pre><code class="lang-python"># 中值滤波median = cv2.medianBlur(img, 5)</code></pre><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了另一种<strong>非线性滤波</strong>双边滤波。双边滤波在高斯滤波的基础上加入了对<strong>灰度信息的权重</strong>，即在邻域内，灰度值越接近中心点灰度值的点的权重更大，灰度值相差大的点权重越小。此权重大小，则由值域高斯函数确定。两者权重系数相乘，得到最终的卷积模板。</p><pre><code class="lang-python"># 双边滤波blur = cv2.bilateralFilter(img, 9, 75, 75)</code></pre><ul><li>参数2：d – Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from <code>sigmaSpace</code> .</li><li>参数3：sigmaColor – Filter sigma in the color space. </li><li>参数4：sigmaSpace – Filter sigma in the coordinate space. </li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p><p>上面的滤波函数都有一个可选参数<code>borderType</code>用来输入padding类型。</p><blockquote><p>BORDER_CONSTANT  <code>iiiiii|abcdefgh|iiiiiii</code> with some specified <code>i</code>  <br>BORDER_REPLICATE  <code>aaaaaa|abcdefgh|hhhhhhh</code>  <br>BORDER_REFLECT  <code>fedcba|abcdefgh|hgfedcb</code>  <br>BORDER_WRAP  <code>cdefgh|abcdefgh|abcdefg</code>  <br>BORDER_REFLECT_101  <code>gfedcb|abcdefgh|gfedcba</code>  <br>BORDER_TRANSPARENT  <code>uvwxyz|absdefgh|ijklmno</code>  <br>BORDER_REFLECT101  same as BORDER_REFLECT_101  <br>BORDER_DEFAULT  same as BORDER_REFLECT_101  <br>BORDER_ISOLATED  do not look outside of ROI</p></blockquote><h2 id="滤波总结"><a href="#滤波总结" class="headerlink" title="滤波总结"></a>滤波总结</h2><ul><li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li><li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li><li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li><li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li><li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li></ul><h1 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h1><h2 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h2><p>固定阈值分割很直接，像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><pre><code class="lang-PYTHON"># 阈值分割ret, th = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</code></pre><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><p><img src="threshold.png" alt=""></p><p>最常见的就是前两种，相当于二值化。</p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<strong>它并不适用于明暗分布不均的图片</strong>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。</p><pre><code class="lang-python">import matplotlib.pyplot as pltimport cv2# 自适应阈值对比固定阈值img = cv2.imread(&#39;img_name.jpg&#39;, 0)# 固定阈值ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# 自适应阈值th2 = cv2.adaptiveThreshold(    img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 4)th3 = cv2.adaptiveThreshold(    img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 17, 6)titles = [&#39;Original&#39;, &#39;Global(v = 127)&#39;, &#39;Adaptive Mean&#39;, &#39;Adaptive Gaussian&#39;]images = [img, th1, th2, th3]for i in range(4):    plt.subplot(2, 2, i + 1), plt.imshow(images[i], &#39;gray&#39;)    plt.title(titles[i], fontsize=8)    plt.xticks([]), plt.yticks([])plt.show()</code></pre><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><h2 id="Otsu阈值法"><a href="#Otsu阈值法" class="headerlink" title="Otsu阈值法"></a>Otsu阈值法</h2><pre><code class="lang-python"># 先进行高斯滤波，再使用Otsu阈值法blur = cv2.GaussianBlur(img, (5, 5), 0)ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</code></pre><script type="math/tex; mode=display">g=\omega_0\omega_1(\mu_0-\mu_1)^2</script><p><strong>$ g $就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$ g $最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。<a href="http://codec.wang/opencv-python-extra-otsu-thresholding/" target="_blank" rel="noopener">原文地址</a></p><h2 id="背景差分"><a href="#背景差分" class="headerlink" title="背景差分"></a>背景差分</h2><p>背景差分（Background Subtraction, BS）是通过使用<strong>静态</strong>相机来生成前景蒙版（即包含属于场景中的<strong>移动对象</strong>的像素的二进制图像）的通用且广泛使用的技术。 顾名思义，BS是在当前帧和背景模型之间执行减法运算，其中场景的静态部分，或者可视为背景的所有内容将被减去，移动对象将会被提取出来。如下图所示。</p><p><img src="Background_Subtraction_Tutorial_Scheme.png" alt=""></p><p>后台建模包括两个主要步骤：</p><ul><li>背景初始化 </li><li>当前帧更新 </li></ul><p>官方给出了下面的例子：</p><pre><code class="lang-python">from __future__ import print_functionimport cv2 as cvimport argparseparser = argparse.ArgumentParser(description=&#39;This program shows how to use background subtraction methods provided by OpenCV. You can process both videos and images.&#39;)parser.add_argument(&#39;--input&#39;, type=str, help=&#39;Path to a video or a sequence of image.&#39;, default=&#39;Video_name.mp4&#39;) # 输入视频路径parser.add_argument(&#39;--algo&#39;, type=str, help=&#39;Background subtraction method (KNN, MOG2).&#39;, default=&#39;KNN&#39;) # 输入差分方法: KNN or MOG2args = parser.parse_args()## [create]#create Background Subtractor objectsif args.algo == &#39;MOG2&#39;:    backSub = cv.createBackgroundSubtractorMOG2()else:    backSub = cv.createBackgroundSubtractorKNN()## [create]## [capture]capture = cv.VideoCapture(cv.samples.findFileOrKeep(args.input))if not capture.isOpened:    print(&#39;Unable to open: &#39; + args.input)    exit(0)## [capture]while True:    ret, frame = capture.read()    if frame is None:        break    ## [apply]    #update the background model    fgMask = backSub.apply(frame)    ## [apply]    ## [display_frame_number]    #get the frame number and write it on the current frame    cv.rectangle(frame, (10, 2), (100,20), (255,255,255), -1)    cv.putText(frame, str(capture.get(cv.CAP_PROP_POS_FRAMES)), (15, 15),               cv.FONT_HERSHEY_SIMPLEX, 0.5 , (0,0,0))    ## [display_frame_number]    ## [show]    #show the current frame and the fg masks    cv.imshow(&#39;Frame&#39;, frame)    cv.imshow(&#39;FG Mask&#39;, fgMask)    ## [show]    keyboard = cv.waitKey(30)    if keyboard == ord(&#39;q&#39;) or keyboard == 27:        break</code></pre><p>关于KNN，MOG2，GMG的区别之后再补充。移动的哆啦A梦如图</p><p><img src="114759.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/06. 阈值分割" target="_blank" rel="noopener">https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/06.%20%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2</a></li><li><a href="http://codec.wang/opencv-python-smoothing-images/#目标" target="_blank" rel="noopener">http://codec.wang/opencv-python-smoothing-images/#%E7%9B%AE%E6%A0%87</a></li><li><a href="https://docs.opencv.org/4.2.0/d1/dc5/tutorial_background_subtraction.html" target="_blank" rel="noopener">https://docs.opencv.org/4.2.0/d1/dc5/tutorial_background_subtraction.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV-python学习笔记一</title>
    <link href="/2020/02/09/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/09/OpenCV-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>图片与视频的基础操作</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>18年结束毕业设计之后，对OpenCV接触很少了。那时使用的是C++，借由最近使用python较多，学习OpenCV-python算是一种温故。本文主要参考了<a href="http://codec.wang/opencv-python" target="_blank" rel="noopener">OpenCV-Python图像处理教程</a>以及<a href="https://docs.opencv.org/4.2.0/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>需要注意图片的x，y轴排布，三通道以B-G-R排布，灰度图只有一个通道。</p><p><img src="1546842698102_gWO39TIUVK.jpg" alt=""></p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><pre><code class="lang-python"># 加载灰度图img = cv2.imread(&#39;lena.jpg&#39;, 0)</code></pre><ul><li>参数1：图片的文件名<ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li>参数2：读入方式，省略即采用默认值<ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><pre><code class="lang-python"># 创建窗口cv2.namedWindow(&#39;lena2&#39;, cv2.WINDOW_NORMAL)</code></pre><ul><li>参数1：窗口名称</li><li>参数2：窗口模式<ul><li><code>cv2.WINDOW_AUTOSIZE</code>表示窗口大小自适应图片</li><li><code>cv2.WINDOW_NORMAL</code>表示窗口大小可调整</li></ul></li></ul><pre><code class="lang-python"># 显示图片cv2.imshow(&#39;lena&#39;, img)</code></pre><ul><li>参数1：窗口名称</li><li>参数2：图片实例</li></ul><pre><code class="lang-python"># 保持图片显示cv2.waitKey(0)</code></pre><ul><li><p>参数：暂停时长，ms</p><p>为0时，表示无限长。</p></li><li><p>传回按键的ascii码, 如<code>ESC:27</code>、<code>s:115</code></p></li></ul><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><pre><code class="lang-python"># 保存图片cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>参数1：是包含后缀名的文件名</li></ul><pre><code class="lang-python">if cv2.waitKey(10000) == 115:     cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>显示10秒，当按下<code>s</code>时，保存图片</li></ul><pre><code class="lang-python">if cv2.waitKey(10000) == ord(&#39;q&#39;):     cv2.imwrite(&#39;lena_gray.jpg&#39;, img)</code></pre><ul><li>也可以用<code>ord()</code>，按下<code>q</code>时，保存。</li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>OpenCV中很多简单的操作实际上是NumPy的操作，请参照<a href="https://lil-q.github.io/2020/02/20/OpenCV-python学习笔记四/">第四篇</a>。</p><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><pre><code class="lang-python">px = img[y, x]</code></pre><ul><li>先输入行，再输入列</li><li>对于彩色图像会返回依次为B-G-R三个通道的值组成的列表，例如<code>[100, 110, 120]</code></li><li>对于灰度图或者单通道图，只有一个值。例如<code>100</code></li></ul><pre><code class="lang-python">px_blue = img[y, x, 0]px_green = img[y, x, 1]px_red = img[y, x, 2]</code></pre><ul><li>获取单通道值</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h4><pre><code class="lang-python"># 彩色图像，返回一个包含行数（高度）、列数（宽度）和通道数的元组height, width, channels = img.shape# 灰度图，返回行数和列数的元组height, width = img.shape</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code class="lang-python">img.dtype</code></pre><p>实际上<code>img.dtype</code>现实的是图像的深度<code>depth</code>，C++中<code>type</code>包含图像深度<code>depth</code>（低三位）和通道数<code>channel</code>（高三位）。<code>channel</code>可以是1，2，3，n。<code>depth</code>有以下可选：</p><pre><code class="lang-c++">// &lt;interface.h&gt;#define CV_8U   0#define CV_8S   1#define CV_16U  2#define CV_16S  3#define CV_32S  4#define CV_32F  5#define CV_64F  6#define CV_16F  7</code></pre><ul><li>数字表示一个像素占几位内存，<code>U</code>表示<code>unsigned</code>，<code>S</code>表示<code>signed</code>，F表示<code>float</code></li></ul><h4 id="ROI-Region-of-Interest"><a href="#ROI-Region-of-Interest" class="headerlink" title="ROI (Region of Interest)"></a>ROI (Region of Interest)</h4><pre><code class="lang-python"># 截取ROIroi = img[100:200, 200:300]</code></pre><ul><li>直接指定范围即可，上面表示行数为<code>100-200</code>，列数为<code>200-300</code>的区域</li></ul><h4 id="通道分割和合并"><a href="#通道分割和合并" class="headerlink" title="通道分割和合并"></a>通道分割和合并</h4><pre><code class="lang-python"># 分割b, g, r = cv2.split(img)# 合并img = cv2.merge((b, g, r))</code></pre><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><pre><code class="lang-python">b = img[:, :, 0]</code></pre><h4 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h4><pre><code class="lang-python"># 转换图片类型cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></pre><ul><li>参数2：<a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li>颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code></li></ul><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><pre><code class="lang-python"># 按照指定的宽度、高度缩放图片res = cv2.resize(img, (132, 150))</code></pre><ul><li>参数2：顺序是宽度，高度；并非<code>.shape</code>中高度，宽度，通道的顺序</li></ul><pre><code class="lang-python"># 按照比例缩放，如x,y轴均放大一倍res2 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)</code></pre><ul><li><code>interpolation</code>，插值方法，默认是<code>INTER_LINEAR</code>，<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a>：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Enumerator</th><th></th></tr></thead><tbody><tr><td style="text-align:left">INTER_NEAREST Python: cv.INTER_NEAREST</td><td>nearest neighbor interpolation</td></tr><tr><td style="text-align:left">INTER_LINEAR Python: cv.INTER_LINEAR</td><td>bilinear interpolation</td></tr><tr><td style="text-align:left">INTER_CUBIC Python: cv.INTER_CUBIC</td><td>bicubic interpolation</td></tr><tr><td style="text-align:left">INTER_AREA Python: cv.INTER_AREA</td><td>resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.</td></tr><tr><td style="text-align:left">INTER_LANCZOS4 Python: cv.INTER_LANCZOS4</td><td>Lanczos interpolation over 8x8 neighborhood</td></tr><tr><td style="text-align:left">INTER_LINEAR_EXACT Python: cv.INTER_LINEAR_EXACT</td><td>Bit exact bilinear interpolation</td></tr><tr><td style="text-align:left">INTER_MAX Python: cv.INTER_MAX</td><td>mask for interpolation codes</td></tr><tr><td style="text-align:left">WARP_FILL_OUTLIERS Python: cv.WARP_FILL_OUTLIERS</td><td>flag, fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero</td></tr><tr><td style="text-align:left">WARP_INVERSE_MAP Python: cv.WARP_INVERSE_MAP</td><td>flag, inverse transformationFor example, <a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaa38a6884ac8b6e0b9bed47939b5362f3" target="_blank" rel="noopener">linearPolar</a> or <a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaec3a0b126a85b5ca2c667b16e0ae022d" target="_blank" rel="noopener">logPolar</a> transforms:flag is <strong>not</strong> set: dst(ρ,ϕ)=src(x,y)flag is set:</td></tr></tbody></table></div><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><pre><code class="lang-python">dst = cv2.flip(img, 1)</code></pre><ul><li>参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</li></ul><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><pre><code class="lang-python"># 平移图片import numpy as nprows, cols = img.shape[:2]# 定义平移矩阵，需要是numpy的float32类型# x轴平移100，y轴平移50M = np.float32([[1, 0, 100], [0, 1, 50]])# 用仿射变换实现平移dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#39;shift&#39;, dst)cv2.waitKey(0)</code></pre><ul><li><code>M</code>实际上是<a href="[https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/4289056?fr=aladdin](https://baike.baidu.com/item/仿射变换/4289056?fr=aladdin">仿射矩阵</a>)去除了最后一行，由矩阵<code>A</code>和向量<code>b</code>组成，由于只做平移，<code>A = [[1, 0], [0, 1]]</code></li></ul><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>平移相当于旋转的一种特例，但是由于仿射变换比较复杂，一般直接找很难找到这个矩阵，OpenCV提供了根据变换前后三个点的对应关系来自动求解，<code>M=cv2.getAffineTransform(pos1,pos2)</code>，其中两个位置就是变换前后的对应位置关系。输出的就是仿射矩阵<code>M</code>。然后再使用函数<code>cv2.warpAffine()</code>。</p><pre><code class="lang-python">from matplotlib import pyplot as pltimport cv2import numpy as npimg = cv2.imread(&#39;aier.jpg&#39;)rows,cols = img.shape[:2]pts1 = np.float32([[50,50],[200,50],[50,200]])pts2 = np.float32([[10,100],[200,20],[100,250]])M = cv2.getAffineTransform(pts1,pts2)#第三个参数：变换后的图像大小res = cv2.warpAffine(img,M,(rows,cols))plt.subplot(121)plt.imshow(img[:,:,::-1])plt.subplot(122)plt.imshow(res[:,:,::-1])plt.show()</code></pre><p>如果仅作旋转和缩放，可以使用 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><pre><code class="lang-python"># 45°旋转图片并缩小一半M = cv2.getRotationMatrix2D((cols / 2, rows / 2), 45, 0.5)dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#39;rotation&#39;, dst)cv2.waitKey(0)</code></pre><p>关于仿射和透视请参照<a href="http://codec.wang/opencv-python-extra-warpaffine-warpperspective/" target="_blank" rel="noopener">这里</a></p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><pre><code class="lang-python"># 打开摄像头capture = cv2.VideoCapture(0)</code></pre><ul><li>参数：摄像头的编号</li><li><code>capture</code>相当于创建的<code>VideoCapture</code>对象</li></ul><pre><code class="lang-python"># 获取摄像头画面ret, frame = capture.read()</code></pre><ul><li>返回值<code>ret</code>：布尔值，表示当前这一帧是否获取正确</li><li>返回值<code>frame</code>：一帧图像</li></ul><pre><code class="lang-python"># 获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等cap.get(propId)# 修改属性值cap.set(propId,value)</code></pre><ul><li><code>propId</code>是<code>0~18</code>的数字，代表不同的属性，完整的属性列表：</li></ul><blockquote><p><code>CV_CAP_PROP_POS_MSEC</code>: Current position of the video file in milliseconds.<br><code>CV_CAP_PROP_POS_FRAMES</code>: 0-based index of the frame to be decoded/captured next.<br><code>CV_CAP_PROP_POS_AVI_RATIO</code>: Relative position of the video file: 0 - start of the film, 1 - end of the film.<br><code>CV_CAP_PROP_FRAME_WIDTH</code>: Width of the frames in the video stream.<br><code>CV_CAP_PROP_FRAME_HEIGHT</code>: Height of the frames in the video stream.<br><code>CV_CAP_PROP_FPS</code>: Frame rate.<br><code>CV_CAP_PROP_FOURCC</code>: 4-character code of codec.<br><code>CV_CAP_PROP_FRAME_COUNT</code>: Number of frames in the video file.<br><code>CV_CAP_PROP_FORMAT</code>: Format of the Mat objects returned by retrieve() .<br><code>CV_CAP_PROP_MODE</code>: Backend-specific value indicating the current capture mode.<br><code>CV_CAP_PROP_BRIGHTNESS</code>: Brightness of the image (only for cameras).<br><code>CV_CAP_PROP_CONTRAST</code>: Contrast of the image (only for cameras).<br><code>CV_CAP_PROP_SATURATION</code>: Saturation of the image (only for cameras).<br><code>CV_CAP_PROP_HUE</code>: Hue of the image (only for cameras).<br><code>CV_CAP_PROP_GAIN</code>: Gain of the image (only for cameras).<br><code>CV_CAP_PROP_EXPOSURE</code>: Exposure (only for cameras).<br><code>CV_CAP_PROP_CONVERT_RGB</code>: Boolean flags indicating whether images should be converted to RGB.<br><code>CV_CAP_PROP_WHITE_BALANCE</code>: Currently unsupported<br><code>CV_CAP_PROP_RECTIFICATION</code>: Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend cur- rently)</p></blockquote><h2 id="本地视频"><a href="#本地视频" class="headerlink" title="本地视频"></a>本地视频</h2><pre><code class="lang-python"># 播放本地视频capture = cv2.VideoCapture(&#39;demo_video.mp4&#39;)while(capture.isOpened()):    ret, frame = capture.read()    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    cv2.imshow(&#39;frame&#39;, gray)    if cv2.waitKey(30) == ord(&#39;q&#39;):        break</code></pre><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><pre><code class="lang-python">capture = cv2.VideoCapture(0)# 定义编码方式并创建VideoWriter对象fourcc = cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)outfile = cv2.VideoWriter(&#39;output.avi&#39;, fourcc, 25., (640, 480))while(capture.isOpened()):    ret, frame = capture.read()    if ret:        outfile.write(frame)  # 写入文件        cv2.imshow(&#39;frame&#39;, frame)        if cv2.waitKey(1) == ord(&#39;q&#39;):            break    else:        break</code></pre><ul><li>创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：<ul><li>输出的文件名，如’output.avi’</li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码：<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a></li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul></li></ul><h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><h3 id="特定颜色物体追踪"><a href="#特定颜色物体追踪" class="headerlink" title="特定颜色物体追踪"></a>特定颜色物体追踪</h3><p><strong>HSV</strong>是一个常用于颜色识别的模型，相比<strong>BGR</strong>更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><pre><code class="lang-python">import cv2import numpy as npcapture = cv2.VideoCapture(0)# 蓝色的范围，不同光照条件下不一样，可灵活调整lower_blue = np.array([100, 100, 100])upper_blue = np.array([130, 255, 255])while(True):    # 1.捕获视频中的一帧    ret, frame = capture.read()    # 2.从BGR转换到HSV    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)    # 3.inRange()：介于lower/upper之间的为白色，其余黑色    mask = cv2.inRange(hsv, lower_blue, upper_blue)    # 4.只保留原图中的蓝色部分    res = cv2.bitwise_and(frame, frame, mask=mask)    cv2.imshow(&#39;frame&#39;, frame)    cv2.imshow(&#39;mask&#39;, mask)    cv2.imshow(&#39;res&#39;, res)    if cv2.waitKey(1) == ord(&#39;q&#39;):        break</code></pre><p>我房间比较暗，调低了点<code>lower_blue</code>中的饱和度和亮度，哆啦A梦如图：</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/2020-02-15_.png" alt=""></p><h1 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h1><pre><code class="lang-python"># 创建一个名为test的窗口cv2.namedWindow(&#39;test&#39;)# 创建一个滑动条cv2.createTrackbar(&#39;R&#39;, &#39;test&#39;, 0, 255, nothing)</code></pre><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值，也可以用<code>cv2.getTrackbarPos()</code>得到：</p><pre><code class="lang-python">r = cv2.getTrackbarPos(&#39;R&#39;, &#39;test&#39;)</code></pre><ul><li>参数1是滑动条的名称</li><li>参数2是窗口的名称。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial" target="_blank" rel="noopener">https://github.com/ex2tron/OpenCV-Python-Tutorial</a></li><li><a href="https://blog.csdn.net/m0_37167788/article/details/78603307" target="_blank" rel="noopener">https://blog.csdn.net/m0_37167788/article/details/78603307</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习</title>
    <link href="/2020/02/05/HTML%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/05/HTML%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>HTML学习笔记</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建网页的标准标记语言。HTML 是一种基础技术，常与 <strong>CSS</strong>、<strong>JavaScript</strong> 一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取 HTML 文件，并将其渲染成可视化网页。HTML 描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。</p><p><h1><a id="title1">标题</a></h1><br>标题（Heading）是通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签进行定义的。<br><code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code> 定义最小的标题。<br></p><pre><code>&lt;h1&gt;演示标题一&lt;/h1&gt;&lt;h2&gt;演示标题二&lt;/h2&gt;&lt;h3&gt;演示标题三&lt;/h3&gt;</code></pre><blockquote><p><h1>演示标题一</h1></p><p><h2>演示标题二</h2></p><h3>演示标题三</h3></blockquote><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落是通过 <code>&lt;p&gt;</code> 标签定义的。</p><pre><code>&lt;p&gt;段落一&lt;/p&gt;&lt;p&gt;段落二&lt;/p&gt;</code></pre><blockquote><p>段落一</p> <p>段落二</p></blockquote><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>使用<code>&lt;br&gt;</code>标签，与 markdown 相同。当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p><p>可使用 <code>&lt;pre&gt;</code> 标签对空行和空格进行控制。</p><pre><code>&lt;p&gt;始不垂翅，&lt;br&gt;终能奋翼&lt;/p&gt;</code></pre><blockquote><p>始不垂翅，<br>终能奋翼</p></blockquote><pre><code>&lt;p&gt;    始不垂翅，    终能奋翼&lt;/p&gt;</code></pre><blockquote><p>    始不垂翅，    终能奋翼</p></blockquote><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><pre><code>&lt;p&gt;下面有一条水平线&lt;/p&gt;&lt;hr&gt;&lt;p&gt;上面有一条水平线&lt;/p&gt;</code></pre><blockquote><p>下面有一条水平线</p><hr><p>上面有一条水平线</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>注释写法如下:</p><pre><code class="lang-HTML">&lt;!-- 这是一个注释 --&gt;</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><pre><code>&lt;b&gt;加粗文本&lt;/b&gt;&lt;br&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;br&gt;&lt;code&gt;电脑自动输出&lt;/code&gt;&lt;br&gt;这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt;</code></pre><blockquote><p><b>加粗文本</b><br><br><i>斜体文本</i><br><br><code>电脑自动输出</code><br><br>这是 <sub> 下标</sub> 和 <sup> 上标</sup></p></blockquote><p>通常标签<code>&lt;strong&gt;</code>替换加粗标签<code>&lt;b&gt;</code>来使用，<code>&lt;em&gt;</code>替换<code>&lt;i&gt;</code>标签使用。</p><p>然而，这些标签的含义是不同的：</p><blockquote><p><code>&lt;b&gt;</code>与<code>&lt;i&gt;</code>定义粗体或斜体文本。</p><p><code>&lt;strong&gt;</code>或者<code>&lt;em&gt;</code>意味着你要呈现的文本是重要的，所以要突出显示。</p></blockquote><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><pre><code>&lt;address&gt;Written by &lt;a href=&quot;mailto:qitiantianc137@outlook.com&quot;&gt;lil-q&lt;/a&gt;.&lt;br&gt; Visit us at:&lt;br&gt;Example.com&lt;br&gt;Box 564, Disneyland&lt;br&gt;USA&lt;/address&gt;</code></pre><blockquote><address>Written by <a href="mailto:qitiantianc137@outlook.com" target="_blank" rel="noopener">lil-q</a>.<br> Visit us at:<br>Example.com<br>Box 564, Disneyland<br>USA</address></blockquote><h2 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h2><pre><code>&lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;&lt;acronym title=&quot;upset&quot;&gt;happy&lt;/acronym&gt;</code></pre><blockquote><p><abbr title="etcetera">etc.</abbr></p><acronym title="upset">happy</acronym></blockquote><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><pre><code>&lt;p&gt;该段落文字从左到右显示。&lt;/p&gt;  &lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;该段落文字从右到左显示。&lt;/bdo&gt;&lt;/p&gt;</code></pre><blockquote><p>该段落文字从左到右显示。</p>  <p><bdo dir="rtl">该段落文字从右到左显示。</bdo></p> </blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>&lt;p&gt;WWF&#39;s goal is to: &lt;q&gt;Build a future where people live in harmony with nature.&lt;/q&gt;We hope they succeed.&lt;/p&gt;</code></pre><blockquote><p>WWF's goal is to: <q>Build a future where people live in harmony with nature.</q>We hope they succeed.</p></blockquote><h2 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h2><pre><code>&lt;p&gt;My favorite color is &lt;del&gt;blue&lt;/del&gt; &lt;ins&gt;red&lt;/ins&gt;!&lt;/p&gt;</code></pre><blockquote><p>My favorite color is <del>blue</del> <ins>red</ins>!</p></blockquote><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><pre><code>&lt;a href=&quot;lil-q.github.io&quot;&gt;链接文本&lt;/a&gt;</code></pre><p><a href="url">链接文本</a></p><h2 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h2><pre><code>&lt;a href=&quot;https://lil-q.github.io/&quot; target=&quot;_blank&quot;&gt;访问主页!&lt;/a&gt;</code></pre><p><a href="https://lil-q.github.io/" target="_blank">访问主页!</a></p><h2 id="id-属性"><a href="#id-属性" class="headerlink" title="id 属性"></a>id 属性</h2><p>在HTML文档中插入ID:</p><pre><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></pre><p>在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”：</p><pre><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><p>或者，从另一个页面创建一个链接到”有用的提示部分(id=”tips”）”：</p><pre><code>&lt;a href=&quot;https://www.xxx.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><p>上面的标题其实藏了一个链接：</p><pre><code>&lt;h1&gt;&lt;a id=&quot;title1&quot;&gt;标题&lt;/a&gt;&lt;/h1&gt;</code></pre><p>下面这个例子将跳回标题章节的位置。</p><pre><code>&lt;a href=&quot;#title1&quot;&gt;返回标题章节&lt;/a&gt;</code></pre><p><a href="#title1">返回标题章节</a></p><h2 id="邮箱设置"><a href="#邮箱设置" class="headerlink" title="邮箱设置"></a>邮箱设置</h2><pre><code>&lt;p&gt;这是一个电子邮件链接：&lt;a href=&quot;mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!&quot; target=&quot;_top&quot;&gt;发送邮件!&lt;/a&gt;&lt;/p&gt;</code></pre><p>这是一个电子邮件链接：<a href="mailto:someone@example.com?cc=someoneelse@example.com&bcc=andsomeoneelse@example.com&subject=Summer%20Party&body=You%20are%20invited%20to%20a%20big%20summer%20party!" target="_top">发送邮件!</a></p><p><strong>注意:</strong> 单词之间的空格使用 %20 代替，以确保浏览器可以正常显示文本。</p><h1 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h1><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code> 元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种 <code>meta</code> 信息。</p><p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;noscript&gt;</code>, and <code>&lt;base&gt;</code>.</p><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p><code>&lt;title&gt;</code> 标签定义了不同文档的标题。</p><p><code>&lt;title&gt;</code> 在 HTML/XHTML 文档中是必须的。</p><p><code>&lt;title&gt;</code> 元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p><code>&lt;base&gt;</code> 标签描述了基本的链接地址/链接目标，该标签作为 HTML 文档中所有的链接标签的默认链接:</p><pre><code>&lt;head&gt;&lt;base href=&quot;http://www.xxx.com/images/&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;</code></pre><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><code>&lt;link&gt;</code> 标签定义了文档与外部资源之间的关系。</p><p><code>&lt;link&gt;</code> 标签通常用于链接到样式表:</p><pre><code>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt;</code></pre><h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.</p><p>在 <code>&lt;style&gt;</code> 元素中你也可以直接添加样式来渲染 HTML 文档:</p><pre><code>&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body {background-color:yellow}p {color:blue}&lt;/style&gt;&lt;/head&gt;</code></pre><h2 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h2><p>meta 标签描述了一些基本的元数据。</p><p><code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><p>为搜索引擎定义关键词:</p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</code></pre><p>为网页定义描述内容:</p><pre><code>&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</code></pre><p>定义网页作者:</p><pre><code>&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</code></pre><p>每30秒钟刷新当前页面:</p><pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></pre><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p><code>&lt;script&gt;</code> 标签用于加载脚本文件，如： JavaScript。</p><p><code>&lt;script&gt;</code> 元素在以后的章节中会详细描述。</p><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>在 HTML 中，图像由<code>&lt;img&gt;</code> 标签定义。</p><p><code>&lt;img&gt;</code> 是空标签，意思是说，它只包含属性，并且没有闭合标签。</p><pre><code>&lt;img src=&quot;https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png&quot; alt=&quot;flower&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</code></pre><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png" alt="flower" width="300" height="200"></p><ul><li>src 指 “source”。源属性的值是图像的 URL 地址。</li><li>alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。</li><li>height（高度）与 width（宽度）属性用于设置图像的高度与宽度。</li><li>border（边框）可以指定图像的边框宽度。</li><li><a href="https://www.runoob.com/try/try.php?filename=tryhtml_areamap" target="_blank" rel="noopener">图片map的用法</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/html/html-tutorial.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-nCoV疫情数据可视化地图</title>
    <link href="/2020/02/01/%E5%BA%94%E7%94%A8%E4%B8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/"/>
    <url>/2020/02/01/%E5%BA%94%E7%94%A8%E4%B8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>爬取2019-nCoV新型冠状病毒肺炎各省份确诊人数分布数据并制作数据可视化地图</p><a id="more"></a><h1 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h1><p>在学习<a href="https://blog.csdn.net/xufive/article/details/104093197" target="_blank" rel="noopener">该博客</a>的数据爬取时发现数据似乎已经不再更新，所以重新在<a href="https://news.qq.com/zt2020/page/feiyan.htm?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">腾讯新闻网站</a>搜索相关数据。</p><p><img src="213627.png" alt="shuju"></p><p>使用<code>time</code>、<code>json</code>和<code>requests</code>获取数据。</p><pre><code class="lang-python">import time, json, requestsurl = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39;%int(time.time()*1000)data = json.loads(requests.get(url=url).json()[&#39;data&#39;])print(data)</code></pre><p>可以看到数据如下所示（省略部分内容）：</p><pre><code class="lang-python">{&#39;chinaTotal&#39;: {&#39;date&#39;: &#39;02.01&#39;, &#39;confirm&#39;: &#39;11890&#39;, &#39;suspect&#39;: &#39;17988&#39;, &#39;dead&#39;: &#39;259&#39;, &#39;heal&#39;: &#39;269&#39;},  &#39;lastUpdateTime&#39;: &#39;2020-02-01 21:18:01&#39;,  &#39;areaTree&#39;:      [{&#39;name&#39;: &#39;中国&#39;,       &#39;children&#39;: [{&#39;name&#39;: &#39;湖北&#39;,                     &#39;children&#39;: [...],                     &#39;total&#39;: {&#39;confirm&#39;: 7153, &#39;suspect&#39;: 0, &#39;dead&#39;: 249, &#39;heal&#39;: 166},                     &#39;today&#39;: {&#39;confirm&#39;: 1347, &#39;suspect&#39;: -49, &#39;dead&#39;: 49, &#39;heal&#39;: 15}},                    {&#39;name&#39;: &#39;浙江&#39;,                     &#39;children&#39;: [...],                     &#39;total&#39;: {&#39;confirm&#39;: 599, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 20},                     &#39;today&#39;: {&#39;confirm&#39;: 62, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 7}}, ...</code></pre><p>我们只获取各个省份确诊人数的信息已经最后更新的时间。</p><pre><code class="lang-python">def catch_distribution():    areaData = {}    url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39;%int(time.time()*1000)    data = json.loads(requests.get(url=url).json()[&#39;data&#39;])    # print(data)    # 获取更新时间    lastUpdateTime = data[&#39;lastUpdateTime&#39;]    # 找到中国信息    for item in data[&#39;areaTree&#39;]:        if item[&#39;name&#39;] == &#39;中国&#39;:            chinaData = item[&#39;children&#39;]            break    # 获取各个省份确诊的人数    for item in chinaData:        areaData[item[&#39;name&#39;]] = item[&#39;total&#39;][&#39;confirm&#39;]    return areaData, lastUpdateTime</code></pre><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>这里使用的是<a href="https://pyecharts.org/#/zh-cn/quickstart" target="_blank" rel="noopener">pyecharts v1</a>，似乎腾讯新闻也是用的这个包。由于湖北人数远高于其他省份，<a href="https://zhuanlan.zhihu.com/p/104026698" target="_blank" rel="noopener">使用连续型的视觉映射效果不好</a>，这里采用了分段式的，可以以10的整数幂为界限传入<code>pieces</code>，<code>time</code>参数即之前得到的最近更新时间。</p><pre><code class="lang-python">def map_visualmap(time, pieces) -&gt; Map:    c = (        Map()        .add(&quot;确诊人数&quot;, data.items(), &quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全国各省份确诊人数分布\n截至: &quot; + time),            visualmap_opts=opts.VisualMapOpts(max_=5000, is_piecewise=True, pieces=pieces)        )    )    return c</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="lang-python">import timeimport jsonimport requestsimport numpy as npfrom pyecharts import options as optsfrom pyecharts.charts import Mapdef catch_distribution():    areaData = {}    url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d&#39; % int(        time.time()*1000)    data = json.loads(requests.get(url=url).json()[&#39;data&#39;])    # 获取更新时间    lastUpdateTime = data[&#39;lastUpdateTime&#39;]    # 找到中国信息    for item in data[&#39;areaTree&#39;]:        if item[&#39;name&#39;] == &#39;中国&#39;:            chinaData = item[&#39;children&#39;]            break    # 获取各个省份确诊的人数    for item in chinaData:        areaData[item[&#39;name&#39;]] = item[&#39;total&#39;][&#39;confirm&#39;]    return areaData, lastUpdateTime# 官网范例中的链式调用def map_visualmap(time, pieces, data) -&gt; Map:    c = (        Map()        .add(&quot;确诊人数&quot;, data.items(), &quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全国各省份确诊人数分布\n截至: &quot; + time),            visualmap_opts=opts.VisualMapOpts(                max_=5000, is_piecewise=True, pieces=pieces)        )    )    return cdata, lastUpdateTime = catch_distribution()pieces = [    {&quot;min&quot;: 1000},    {&quot;min&quot;: 100, &quot;max&quot;: 1000},    {&quot;min&quot;: 10, &quot;max&quot;: 100},    {&quot;max&quot;: 10}]map1 = map_visualmap(lastUpdateTime, pieces, data)map1.render()</code></pre><p>最后的效果如下，</p><p><img src="2sd15400.png" alt="xiaoguo"></p><p>运行后会在根目录下生成<a href="http://lil-q.gitee.io/demo/render.html" target="_blank" rel="noopener">render.html</a></p><p><a href="https://github.com/lil-q/2019-nCoV-VisualMap/blob/master/2019-nCoV-VisualMap.py" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    
    <categories>
      
      <category>应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL(Structured Query Language)</title>
    <link href="/2020/01/16/SQL-Structured-Query-Language/"/>
    <url>/2020/01/16/SQL-Structured-Query-Language/</url>
    
    <content type="html"><![CDATA[<p>SQL基础语句快查</p><a id="more"></a><p>原教程地址：<a href="http://www.xuesql.cn/" target="_blank" rel="noopener">http://www.xuesql.cn/</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="1-1-什么是SQL-Structured-Query-Language"><a href="#1-1-什么是SQL-Structured-Query-Language" class="headerlink" title="1.1 什么是SQL(Structured Query Language)"></a>1.1 什么是SQL(Structured Query Language)</h2><p><code>SQL</code>, 全称为Structured Query Language（结构化查询语言)。 要讲SQL就绕不开database(数据库), 平时所说的数据库，一般就是指的 <code>Relational database(关系型数据库)</code>。</p><p>大家知道数据库是用来存储大量数据的一种软件，那么SQL呢是用来操作数据里的数据，具体来说SQL可以做数据查询，数据更新，写入数据等等。</p><h2 id="1-2-关系型数据库-Relational-databases"><a href="#1-2-关系型数据库-Relational-databases" class="headerlink" title="1.2 关系型数据库(Relational databases)"></a>1.2 关系型数据库(Relational databases)</h2><p>在学习SQL语法之前有必要解释一下什么是关系型数据库（Relational databases)？数据库由若干张<code>表</code>(Table)组成，这里说的数据Table很像Excel里的表; 正如Excel里的表格，Table也是由 <code>行(rows)</code>和<code>列(columns)</code>组成。</p><p>一个Table存储一个类别的数据，每一行是一条数据，每一列是这种数据的一个属性； Table就像一个二维的表格，<code>列(columns)</code>是有限固定的，<code>行(rows)</code>是无限不固定的。</p><h1 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询(SELECT)"></a>查询(SELECT)</h1><p>Select 查询某些属性列（specific columns）的语法。</p><pre><code class="lang-sql">SELECT column（列名）, another_column, …FROM mytable（表名）;</code></pre><p>Select 查询所有列。</p><pre><code class="lang-sql">SELECT *FROM mytable（表名）;</code></pre><h1 id="条件查询-WHERE"><a href="#条件查询-WHERE" class="headerlink" title="条件查询 (WHERE)"></a>条件查询 (WHERE)</h1><p>条件查询语法。WHERE</p><pre><code class="lang-SQL">SELECT column, another_column, …FROM mytableWHERE condition    AND/OR another_condition    AND/OR …;</code></pre><div class="table-container"><table><thead><tr><th>Operator（关键字）</th><th>Condition（意思）</th><th><strong>SQL Example(例子）</strong></th></tr></thead><tbody><tr><td>=, !=, &lt; &lt;=, &gt;, &gt;=</td><td>Standard numerical operators 基础的 大于，等于等比较</td><td>col_name != 4</td></tr><tr><td>BETWEEN … AND …</td><td>Number is within range of two values (inclusive) 在两个数之间</td><td>col_name BETWEEN 1.5 AND 10.5</td></tr><tr><td>NOT BETWEEN … AND …</td><td>Number is not within range of two values (inclusive) 不在两个数之间</td><td>col_name NOT BETWEEN 1 AND 10</td></tr><tr><td>IN (…)</td><td>Number exists in a list 在一个列表</td><td>col_name IN (2, 4, 6)</td></tr><tr><td>NOT IN (…)</td><td>Number does not exist in a list 不在一个列表</td><td>col_name NOT IN (1, 3, 5)</td></tr></tbody></table></div><h1 id="模糊查询-LIKE-和-通配符-）"><a href="#模糊查询-LIKE-和-通配符-）" class="headerlink" title="模糊查询(LIKE) 和 通配符(%）"></a>模糊查询(LIKE) 和 通配符(%）</h1><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE “ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col<em>name LIKE “AN</em>“ (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr><tr><td>NOT IN (…)</td><td>String does not exist in a list 不在列表</td><td>col_name NOT IN (“D”, “E”, “F”)</td></tr></tbody></table></div><h1 id="过滤-DISTINCT"><a href="#过滤-DISTINCT" class="headerlink" title="过滤(DISTINCT)"></a>过滤(DISTINCT)</h1><p>选取出唯一的结果的语法</p><pre><code class="lang-sql">SELECT DISTINCT column, another_column, … FROM mytable WHERE condition(s);</code></pre><h1 id="排序-ORDER"><a href="#排序-ORDER" class="headerlink" title="排序(ORDER)"></a>排序(ORDER)</h1><p>结果排序（ordered results）</p><pre><code class="lang-sql">SELECT column, another_column, … FROM mytable WHERE condition(s)ORDER BY column ASC/DESC;</code></pre><p><code>ASC</code>：升序；<code>DESC</code>：降序。</p><h1 id="选取-LIMIT-OFFSET"><a href="#选取-LIMIT-OFFSET" class="headerlink" title="选取(LIMIT, OFFSET)"></a>选取(LIMIT, OFFSET)</h1><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。</p><pre><code class="lang-sql">SELECT column, another_column, …FROM table1WHERE condition(s)ORDER BY column ASC/DESC, another_column ASC/DESC, …LIMIT num_limit OFFSET num_offset;</code></pre><h1 id="多表联合-JOIN"><a href="#多表联合-JOIN" class="headerlink" title="多表联合(JOIN)"></a>多表联合(JOIN)</h1><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键。借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来。</p><p><img src="joins.png" alt="joins"></p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>用INNER JOIN 连接表的语法。通过<code>ON</code>条件描述的关联关系;<code>INNER JOIN</code> 先将两个表数据连接到一起. 两个表中如果通过ID互相找不到的数据将会舍弃。</p><pre><code class="lang-sql">SELECT table1.column, table2.another_table_column, … FROM table1 （主表） INNER JOIN table2 （要连接的表）        ON table1.id = table2.matching_id WHERE condition(s) ORDER BY table1.column, … ASC/DESC LIMIT num_limit OFFSET num_offset;</code></pre><h2 id="OUTER-JOINs"><a href="#OUTER-JOINs" class="headerlink" title="OUTER JOINs"></a>OUTER JOINs</h2><p><code>INNER JOIN</code> 只会保留两个表都存在的数据（还记得之前的交集吗），这看起来意味着一些数据的丢失，在某些场景下会有问题.</p><p>用LEFT/RIGHT/FULL JOINs 做多表查询</p><pre><code class="lang-sql">SELECT table1.column, table2.another_table_column, … FROM table1 （主表） LEFT/RIGHT/FULL JOIN table2 （要连接的表）        ON table1.id = table2.matching_id WHERE condition(s) ORDER BY table1.column, … ASC/DESC LIMIT num_limit OFFSET num_offset;</code></pre><h1 id="表达式-AS"><a href="#表达式-AS" class="headerlink" title="表达式(AS)"></a>表达式(AS)</h1><p>当我们用表达式对col属性计算时，很多事可以在SQL内完成，这让SQL更加灵活，但表达式如果长了则很难一下子读懂。所以SQL提供了<code>AS</code>关键字， 来给表达式取一个别名.</p><pre><code class="lang-sql">SELECT col_expression AS expr_descriptionFROM table1 AS newTableNameWHERE condition(s)ORDER BY expr_description ASC/DESCLIMIT num_limit OFFSET num_offset;</code></pre><h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><p>下面介绍几个常用统计函数:</p><div class="table-container"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(column)**</td><td>计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数.</td></tr><tr><td><strong>MIN(column)</strong></td><td>找column最小的一行.</td></tr><tr><td><strong>MAX(column)</strong></td><td>找column最大的一行.</td></tr><tr><td><strong>AVG(column)</strong></td><td>对column所有行取平均值.</td></tr><tr><td><strong>SUM(column)</strong></td><td>对column所有行求和.</td></tr></tbody></table></div><p>当不求整组数据时，可以使用<code>GROUP BY</code> 对数据分组。</p><pre><code class="lang-sql">SELECT column, count(*)*100/(SELECT count(*) FROM table1) FROM table1 WHERE column in (1,3,5,7)GROUP BY column;</code></pre><p>可以通过嵌套一个select来实现百分比的求解。</p><p>数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选就需要使用 <code>HAVING</code> 语法。</p><pre><code class="lang-sql">SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …FROM mytableWHERE conditionGROUP BY columnHAVING group_condition;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的SELECT查询</p><pre><code class="lang-sql">SELECT DISTINCT column, AGG_FUNC(column_or_expression), …FROM mytableJOIN another_table    ON mytable.column = another_table.columnWHERE constraint_expressionGROUP BY columnHAVING constraint_expressionORDER BY column ASC/DESCLIMIT count OFFSET COUNT;</code></pre><h2 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. FROM 和 JOINs</h2><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p><h2 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. WHERE</h2><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h2 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. GROUP BY</h2><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h2 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. HAVING</h2><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p><h2 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. SELECT</h2><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p><h2 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. DISTINCT</h2><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p><h2 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. ORDER BY</h2><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p><h2 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. LIMIT / OFFSET</h2><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>松山湖</title>
    <link href="/2020/01/14/%E6%9D%BE%E5%B1%B1%E6%B9%96/"/>
    <url>/2020/01/14/%E6%9D%BE%E5%B1%B1%E6%B9%96/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>这个镜头和我一样，罹患飞蚊症。大光圈时倒是看不出来，调小了拍风景就变得显眼。不经意看拍的松山湖，还以为有飞鸟击水。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7350.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7339.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7367.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7377.png" alt=""></p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7475.png" alt=""></p><p align="right">一月十四日同实习期同事于松山湖</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch基础</title>
    <link href="/2020/01/02/PyTorch%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/01/02/PyTorch%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>PyTorch官方中文文档学习笔记</p><a id="more"></a><h1 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量(Tensors)"></a>张量(Tensors)</h1><h2 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h2><pre><code class="lang-python"># 创建一个5x3的矩阵，不初始化x_1 = torch.empty(5, 3)# 构造一个随机初始化的矩阵x_2 = torch.rand(5, 3)# 构造一个矩阵全为 0，而且数据类型是 longx_3 = torch.zeros(5, 3, dtype=torch.long)# 构造一个张量，直接使用数据x_4 = torch.tensor([5.5, 3])</code></pre><p>输出：</p><pre><code class="lang-python">x_1: tensor([[1.2875e-35, 0.0000e+00, 1.2875e-35],             [0.0000e+00, 1.7290e-39, 0.0000e+00],             [1.7290e-39, 0.0000e+00, 1.2876e-35],             [0.0000e+00, 1.2876e-35, 0.0000e+00],             [1.2876e-35, 0.0000e+00, 1.2876e-35]])x_2: tensor([[0.8532, 0.0308, 0.7529],             [0.0109, 0.3987, 0.9199],             [0.8618, 0.2898, 0.7708],             [0.8400, 0.3074, 0.9531],             [0.8799, 0.3668, 0.9811]])x_3: tensor([[0, 0, 0],             [0, 0, 0],             [0, 0, 0],             [0, 0, 0],             [0, 0, 0]])x_4: tensor([5.5000, 3.0000])</code></pre><h2 id="张量数据类型"><a href="#张量数据类型" class="headerlink" title="张量数据类型"></a>张量数据类型</h2><p>PyTorch提供了9种用于CPU和GPU的张量类型：</p><div class="table-container"><table><thead><tr><th>Data type</th><th>dtype</th><th>CPU tensor</th><th>GPU tensor</th></tr></thead><tbody><tr><td>32-bit floating point</td><td><code>torch.float32</code> or <code>torch.float</code></td><td><code>torch.FloatTensor</code></td><td><code>torch.cuda.FloatTensor</code></td></tr><tr><td>64-bit floating point</td><td><code>torch.float64</code> or <code>torch.double</code></td><td><code>torch.DoubleTensor</code></td><td><code>torch.cuda.DoubleTensor</code></td></tr><tr><td>16-bit floating point</td><td><code>torch.float16</code> or <code>torch.half</code></td><td><code>torch.HalfTensor</code></td><td><code>torch.cuda.HalfTensor</code></td></tr><tr><td>8-bit integer (unsigned)</td><td><code>torch.uint8</code></td><td><code>torch.ByteTensor</code></td><td><code>torch.cuda.ByteTensor</code></td></tr><tr><td>8-bit integer (signed)</td><td><code>torch.int8</code></td><td><code>torch.CharTensor</code></td><td><code>torch.cuda.CharTensor</code></td></tr><tr><td>16-bit integer (signed)</td><td><code>torch.int16</code> or <code>torch.short</code></td><td><code>torch.ShortTensor</code></td><td><code>torch.cuda.ShortTensor</code></td></tr><tr><td>32-bit integer (signed)</td><td><code>torch.int32</code> or <code>torch.int</code></td><td><code>torch.IntTensor</code></td><td><code>torch.cuda.IntTensor</code></td></tr><tr><td>64-bit integer (signed)</td><td><code>torch.int64</code> or <code>torch.long</code></td><td><code>torch.LongTensor</code></td><td><code>torch.cuda.LongTensor</code></td></tr><tr><td>Boolean</td><td><code>torch.bool</code></td><td><code>torch.BoolTensor</code></td><td><code>torch.cuda.BoolTensor</code></td></tr></tbody></table></div><h2 id="张量的运算"><a href="#张量的运算" class="headerlink" title="张量的运算"></a>张量的运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><pre><code class="lang-python">x_1 = torch.ones(3, 3)print(&#39;x_1&#39;, x_1, x_1.dtype)x_2 = x_1 * 2print(&#39;x_2&#39;, x_2)# 加法一y_1 = x_1 + x_2print(&#39;y_1&#39;, y_1)# 加法二y_2 = torch.add(x_1, x_2)print(&#39;y_2&#39;, y_2)# 加法三y_3 = x_1.add(x_2)print(&#39;y_3&#39;, y_3)print(&#39;x_1&#39;, x_1)# 加法四(in-place)y_3 = x_1.add_(x_2)print(&#39;y_3&#39;, y_3)print(&#39;x_1&#39;, x_1)</code></pre><p>输出：</p><pre><code class="lang-python">x_1 tensor([[1., 1., 1.],            [1., 1., 1.],            [1., 1., 1.]]) torch.float32x_2 tensor([[2., 2., 2.],            [2., 2., 2.],            [2., 2., 2.]])# 加法一：y_1 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])# 加法二：y_2 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])# 加法三：y_3 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])x_1 tensor([[1., 1., 1.],            [1., 1., 1.],            [1., 1., 1.]])# 加法四(in-place)：y_3 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])x_1 tensor([[3., 3., 3.],            [3., 3., 3.],            [3., 3., 3.]])</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre><code class="lang-python"># 哈达玛积(element wise，对应元素相乘)# mul和*等效y_4 = torch.mul(x_1, x_2)y_5 = x_1*x_2# 矩阵相乘# matmul和mm等效y_6 = torch.matmul(x_1, x_2)y_7 = torch.mm(x_1, x_2)y_8 = x_1.mm(x_2)</code></pre><p>输出：</p><pre><code class="lang-python"># 哈达玛积(element wise，对应元素相乘)# mul和*等效# 注意：x_1中的值已经变成3了y_4 tensor([[6., 6., 6.],            [6., 6., 6.],            [6., 6., 6.]])y_5 tensor([[6., 6., 6.],            [6., 6., 6.],            [6., 6., 6.]])# 矩阵相乘# matmul和mm等效y_6 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])y_7 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])y_8 tensor([[18., 18., 18.],            [18., 18., 18.],            [18., 18., 18.]])</code></pre><h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><p><code>torch.Tensor</code> 是包的核心类。如果将其属性 <code>.requires_grad</code>设置为<code>True</code>，则会开始跟踪针对 <code>tensor</code> 的所有操作。完成计算后，您可以调用 <code>.backward()</code>来自动计算所有梯度。该张量的梯度将累积到<code>.grad</code>属性中。</p><pre><code class="lang-python">import torchx = torch.ones(2, 2)print(x.requires_grad)# print: Falsex.requires_grad_(True)# print: tensor([[1., 1.],#                 [1., 1.]], requires_grad=True)</code></pre><p>还有一个类对于 <code>autograd</code> 实现非常重要那就是 <code>Function</code>。<code>Tensor</code> 和 <code>Function</code> 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息。每个张量都有一个 <code>.grad_fn</code> 属性保存着创建了张量的 <code>Function</code> 的引用，（如果用户自己创建张量，则<code>grad_fn</code> 是 <code>None</code> ）。</p><p>如果你想计算导数，你可以调用 <code>Tensor.backward()</code>。如果 <code>Tensor</code> 是标量（<strong>即它包含一个元素数据，相当于权重是1</strong>），则不需要指定任何参数<code>backward()</code>，但是如果它有更多元素，则需要指定一个<code>gradient</code> 参数（<strong>每个维度的权重</strong>）来指定张量的形状。</p><pre><code class="lang-python">y = x + 2print(y)# print:# tensor([[3., 3.],#         [3., 3.]], grad_fn=&lt;AddBackward0&gt;)print(y.grad_fn)# print: (y 作为操作的结果被创建，所以它有 grad_fn)# &lt;AddBackward0 object at 0x7fe1db427470&gt;z = y * y * 3out = z.mean()print(z, out)# print: # tensor([[27., 27.],#         [27., 27.]], grad_fn=&lt;MulBackward0&gt;) # tensor(27., grad_fn=&lt;MeanBackward0&gt;)out.backward()print(x.grad)# print:# tensor([[4.5000, 4.5000],#        [4.5000, 4.5000]])</code></pre><p>需要输入权重的雅克比向量积的例子：</p><pre><code class="lang-python">x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000:    y = y * 2print(y)# print:# tensor([ -444.6791,   762.9810, -1690.0941], grad_fn=&lt;MulBackward0&gt;)v = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(v)print(x.grad)# print:# tensor([1.0240e+02, 1.0240e+03, 1.0240e-01])</code></pre><p>要停止<code>tensor</code>历史记录的跟踪，可以调用<code>.detach()</code>，它将其与计算历史记录分离，并防止将来的计算被跟踪。还可以将代码块使用 <code>with torch.no_grad():</code> 包装起来。在评估模型时，这是特别有用，因为模型在训练阶段具有 <code>requires_grad = True</code>的可训练参数有利于调参，但在评估阶段我们不需要梯度。</p><pre><code class="lang-python">print(x.requires_grad)print((x ** 2).requires_grad)# print:# True# Truewith torch.no_grad():    print((x ** 2).requires_grad)# print:# False</code></pre><h1 id="数据-Dataset"><a href="#数据-Dataset" class="headerlink" title="数据(Dataset)"></a>数据(Dataset)</h1><p>本节内容针对<a href="http://pytorch123.com/ThirdSection/DataLoding/" target="_blank" rel="noopener">PyTorch中文文档-数据加载和处理</a>。</p><h2 id="建立数据集"><a href="#建立数据集" class="headerlink" title="建立数据集"></a>建立数据集</h2><p><code>torch.utils.data.Dataset</code>是代表自定义数据集方法的<a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">抽象类</a>，你可以自己定义你的数据类继承这个抽象类，非常简单，只需要定义<code>__len__</code>和<code>__getitem__</code>这两个方法就可以。</p><pre><code class="lang-python">class FaceLandmarksDataset(Dataset):    &quot;&quot;&quot;面部标记数据集.&quot;&quot;&quot;    def __init__(self, csv_file, root_dir, transform=None):        &quot;&quot;&quot;        csv_file（string）：带注释的csv文件的路径。        root_dir（string）：包含所有图像的目录。        transform（callable， optional）：一个样本上的可用的可选变换        &quot;&quot;&quot;        self.landmarks_frame = pd.read_csv(csv_file)        self.root_dir = root_dir        self.transform = transform    def __len__(self):        return len(self.landmarks_frame)    def __getitem__(self, idx):        # 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。        # iloc相当于切片。index location        img_name = os.path.join(self.root_dir,                                self.landmarks_frame.iloc[idx, 0])        # skimage.io.imread: 直接返回numpy.ndarray 对象，通道顺序为RGB，通道值默认范围0-255，uint8。        image = io.imread(img_name)        landmarks = self.landmarks_frame.iloc[idx, 1:]        landmarks = np.array([landmarks])        # uint8-&gt;float        landmarks = landmarks.astype(&#39;float&#39;).reshape(-1, 2)        sample = {&#39;image&#39;: image, &#39;landmarks&#39;: landmarks}        if self.transform:            sample = self.transform(sample)        return sample</code></pre><h2 id="数据变形"><a href="#数据变形" class="headerlink" title="数据变形"></a>数据变形</h2><p>通过上面的例子我们会发现图片并不是同样的尺寸。绝大多数神经网络都假定图片的尺寸相同。因此我们需要做一些预处理。让我们创建三个转换: <em> <code>Rescale</code>：缩放图片 </em> <code>RandomCrop</code>：对图片进行随机裁剪。这是一种数据增强操作 * <code>ToTensor</code>：把numpy格式图片转为torch格式图片 (我们需要交换坐标轴).</p><p>我们会把它们写成可调用的类的形式而不是简单的函数，这样就不需要每次调用时传递一遍参数。我们只需要实现<code>__call__</code>方法，必 要的时候实现 <code>__init__</code>方法。我们可以这样调用这些转换:</p><pre><code class="lang-python">tsfm = Transform(params)transformed_sample = tsfm(sample)</code></pre><pre><code class="lang-python">class Rescale(object):    &quot;&quot;&quot;将样本中的图像重新缩放到给定大小。.    Args:        output_size（tuple或int）：所需的输出大小。 如果是元组，则输出为         与output_size匹配。 如果是int，则匹配较小的图像边缘到output_size保持纵横比相同。    &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        self.output_size = output_size    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w = image.shape[:2]        if isinstance(self.output_size, int):            if h &gt; w:                new_h, new_w = self.output_size * h / w, self.output_size            else:                new_h, new_w = self.output_size, self.output_size * w / h        else:            new_h, new_w = self.output_size        new_h, new_w = int(new_h), int(new_w)        img = transform.resize(image, (new_h, new_w))        # h and w are swapped for landmarks because for images,        # x and y axes are axis 1 and 0 respectively        landmarks = landmarks * [new_w / w, new_h / h]        return {&#39;image&#39;: img, &#39;landmarks&#39;: landmarks}class RandomCrop(object):    &quot;&quot;&quot;随机裁剪样本中的图像.    Args:       output_size（tuple或int）：所需的输出大小。 如果是int，方形裁剪是。             &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        if isinstance(output_size, int):            self.output_size = (output_size, output_size)        else:            assert len(output_size) == 2            self.output_size = output_size    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w = image.shape[:2]        new_h, new_w = self.output_size        top = np.random.randint(0, h - new_h)        left = np.random.randint(0, w - new_w)        image = image[top: top + new_h,                      left: left + new_w]        landmarks = landmarks - [left, top]        return {&#39;image&#39;: image, &#39;landmarks&#39;: landmarks}class ToTensor(object):    &quot;&quot;&quot;将样本中的ndarrays转换为Tensors.&quot;&quot;&quot;    def __call__(self, sample):        image, landmarks = sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        # 交换颜色轴因为        # numpy包的图片是: H * W * C        # torch包的图片是: C * H * W        image = image.transpose((2, 0, 1))        return {&#39;image&#39;: torch.from_numpy(image),                &#39;landmarks&#39;: torch.from_numpy(landmarks)}</code></pre><p>可以调用一个简单的类 <code>torchvision.transforms.Compose</code>来实现组合变换。</p><pre><code class="lang-python">scale = Rescale(256)crop = RandomCrop(128)composed = transforms.Compose([Rescale(256),                               RandomCrop(224)])</code></pre><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p><code>torch.utils.data.DataLoader</code>是一个提供上述所有这些功能的迭代器。下面使用的参数必须是清楚的。一个值得关注的参数是<code>collate_fn</code>, 可以通过它来决定如何对数据进行批处理。但是绝大多数情况下默认值就能运行良好。</p><pre><code class="lang-python"># Windows下num_workers值取0不会报错，取其他值可能出现多线程bugdataloader = DataLoader(transformed_dataset, batch_size=4,                        shuffle=True, num_workers=4)</code></pre><h1 id="TensorFlow-和-PyTorch"><a href="#TensorFlow-和-PyTorch" class="headerlink" title="TensorFlow 和 PyTorch"></a>TensorFlow 和 PyTorch</h1><p>PyTorch自动求导看起来非常像TensorFlow：这两个框架中，我们都定义计算图，使用自动微分来计算梯度。两者最大的不同就是TensorFlow的计算图是静态的，而PyTorch使用动态的计算图。</p><p>在TensorFlow中，我们定义计算图一次，然后重复执行这个相同的图，可能会提供不同的输入数据。而在PyTorch中，每一个前向通道定义一个新的计算图。</p><p>静态图的好处在于你可以预先对图进行优化。例如，一个框架可能要融合一些图的运算来提升效率，或者产生一个策略来将图分布到多个GPU或机器上。如果重复使用相同的图，那么在重复运行同一个图时，，前期潜在的代价高昂的预先优化的消耗就会被分摊开。</p><p>在TensorFlow中，更新权重值的行为是计算图的一部分; 但在PyTorch中，这发生在计算图形之外。</p><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p>实际中，基本没有人会从零开始（随机初始化）训练一个完整的卷积网络，因为相对于网络，很难得到一个足够大的数据集[网络很深, 需要足够大数据集]。通常的做法是在一个很大的数据集上进行预训练得到卷积网络ConvNet, 然后将这个ConvNet的参数作为目标任务的初始化参数或者固定这些参数。</p><p>转移学习的两个主要场景：</p><ul><li>微调<strong>Convnet</strong>：使用预训练的网络(如在<code>imagenet 1000</code>上训练而来的网络)来初始化自己的网络，而不是随机初始化。其他的训练步骤不变。</li><li>将<strong>Convnet</strong>看成固定的特征提取器:首先固定ConvNet除了最后的全连接层外的其他所有层。最后的全连接层被替换成一个新的随机 初始化的层，只有这个新的层会被训练[只有这层参数会在反向传播时更新]。</li></ul><h2 id="微调Torchvision"><a href="#微调Torchvision" class="headerlink" title="微调Torchvision"></a>微调Torchvision</h2><p><a href="http://pytorch123.com/FourSection/FinetuningTorchVisionModel/" target="_blank" rel="noopener">原文</a>，整理成<code>.py</code>后运行会报错，需要把主程序放入<code>if __name__ == &#39;__main__&#39;:</code>下，或者将<code>num_workers</code>置为0。似乎是一个多进程处理的bug，即使修改，在PyCharm下运行完会进入死循环。</p><pre><code class="lang-python">#!/usr/bin/env python# coding: utf-8from __future__ import print_functionfrom __future__ import divisionimport torchimport torch.nn as nnimport torch.optim as optimimport numpy as npimport torchvisionfrom torchvision import datasets, models, transformsimport matplotlib.pyplot as pltimport timeimport osimport copydef train_model(model, dataloaders, criterion, optimizer, num_epochs=25, is_inception=False):     since = time.time()    val_acc_history = []    best_model_wts = copy.deepcopy(model.state_dict())    best_acc = 0.0    for epoch in range(num_epochs):        print(&#39;Epoch {}/{}&#39;.format(epoch, num_epochs - 1))        print(&#39;-&#39; * 10)        # 每个epoch都有一个训练和验证阶段        for phase in [&#39;train&#39;, &#39;val&#39;]:            if phase == &#39;train&#39;:                model.train()  # Set model to training mode            else:                model.eval()   # Set model to evaluate mode            running_loss = 0.0            running_corrects = 0            # 迭代数据            for inputs, labels in dataloaders[phase]:                inputs = inputs.to(device)                labels = labels.to(device)                # 零参数梯度                optimizer.zero_grad()                # 前向                # 如果只在训练时则跟踪轨迹                with torch.set_grad_enabled(phase == &#39;train&#39;):                    # 获取模型输出并计算损失                    # 开始的特殊情况，因为在训练中它有一个辅助输出。                    # 在训练模式下，我们通过将最终输出和辅助输出相加来计算损耗                    # 但在测试中我们只考虑最终输出。                    if is_inception and phase == &#39;train&#39;:                        # From https://discuss.pytorch.org/t/how-to-optimize-inception-model-with-auxiliary-classifiers/7958                        outputs, aux_outputs = model(inputs)                        loss1 = criterion(outputs, labels)                        loss2 = criterion(aux_outputs, labels)                        loss = loss1 + 0.4*loss2                    else:                        outputs = model(inputs)                        loss = criterion(outputs, labels)                    _, preds = torch.max(outputs, 1)                    # backward + optimize only if in training phase                    if phase == &#39;train&#39;:                        loss.backward()                        optimizer.step()                # 统计                running_loss += loss.item() * inputs.size(0)                running_corrects += torch.sum(preds == labels.data)            epoch_loss = running_loss / len(dataloaders[phase].dataset)            epoch_acc = running_corrects.double() / len(dataloaders[phase].dataset)            print(&#39;{} Loss: {:.4f} Acc: {:.4f}&#39;.format(phase, epoch_loss, epoch_acc))            # deep copy the model            if phase == &#39;val&#39; and epoch_acc &gt; best_acc:                best_acc = epoch_acc                best_model_wts = copy.deepcopy(model.state_dict())            if phase == &#39;val&#39;:                val_acc_history.append(epoch_acc)        print()    time_elapsed = time.time() - since    print(&#39;Training complete in {:.0f}m {:.0f}s&#39;.format(time_elapsed // 60, time_elapsed % 60))    print(&#39;Best val Acc: {:4f}&#39;.format(best_acc))    # load best model weights    model.load_state_dict(best_model_wts)    return model, val_acc_historydef set_parameter_requires_grad(model, feature_extracting):    if feature_extracting:        for param in model.parameters():            param.requires_grad = Falsedef initialize_model(model_name, num_classes, feature_extract, use_pretrained=True):    # 初始化将在此if语句中设置的这些变量。     # 每个变量都是模型特定的。    model_ft = None    input_size = 0    if model_name == &quot;resnet&quot;:        &quot;&quot;&quot; Resnet18 &quot;&quot;&quot;        model_ft = models.resnet18(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.fc.in_features        model_ft.fc = nn.Linear(num_ftrs, num_classes)        input_size = 224    elif model_name == &quot;alexnet&quot;:        &quot;&quot;&quot; Alexnet &quot;&quot;&quot;        model_ft = models.alexnet(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier[6].in_features        model_ft.classifier[6] = nn.Linear(num_ftrs,num_classes)        input_size = 224    elif model_name == &quot;vgg&quot;:        &quot;&quot;&quot; VGG11_bn &quot;&quot;&quot;        model_ft = models.vgg11_bn(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier[6].in_features        model_ft.classifier[6] = nn.Linear(num_ftrs,num_classes)        input_size = 224    elif model_name == &quot;squeezenet&quot;:        &quot;&quot;&quot; Squeezenet &quot;&quot;&quot;        model_ft = models.squeezenet1_0(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        model_ft.classifier[1] = nn.Conv2d(512, num_classes, kernel_size=(1,1), stride=(1,1))        model_ft.num_classes = num_classes        input_size = 224    elif model_name == &quot;densenet&quot;:        &quot;&quot;&quot; Densenet &quot;&quot;&quot;        model_ft = models.densenet121(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        num_ftrs = model_ft.classifier.in_features        model_ft.classifier = nn.Linear(num_ftrs, num_classes)        input_size = 224    elif model_name == &quot;inception&quot;:        &quot;&quot;&quot; Inception v3 Be careful, expects (299,299) sized images and has auxiliary output &quot;&quot;&quot;        model_ft = models.inception_v3(pretrained=use_pretrained)        set_parameter_requires_grad(model_ft, feature_extract)        # 处理辅助网络        num_ftrs = model_ft.AuxLogits.fc.in_features        model_ft.AuxLogits.fc = nn.Linear(num_ftrs, num_classes)        # 处理主要网络        num_ftrs = model_ft.fc.in_features        model_ft.fc = nn.Linear(num_ftrs,num_classes)        input_size = 299    else:        print(&quot;Invalid model name, exiting...&quot;)        exit()    return model_ft, input_sizeif __name__ == &#39;__main__&#39;:    # 顶级数据目录。 这里我们假设目录的格式符合ImageFolder结构    data_dir = &quot;./hymenoptera_data&quot;    # 从[resnet, alexnet, vgg, squeezenet, densenet, inception]中选择模型    model_name = &quot;squeezenet&quot;    # 数据集中类别数量    num_classes = 2    # 训练的批量大小（根据您的内存量而变化）    batch_size = 8    # 你要训练的epoch数    num_epochs = 15    # 用于特征提取的标志。 当为False时，我们微调整个模型，    # 当True时我们只更新重新形成的图层参数    feature_extract = True    # 在这步中初始化模型    model_ft, input_size = initialize_model(model_name, num_classes, feature_extract, use_pretrained=True)    # 打印我们刚刚实例化的模型    print(&#39;model_ft&#39;)    # 数据扩充和训练规范化    # 只需验证标准化    data_transforms = {        &#39;train&#39;: transforms.Compose([            transforms.RandomResizedCrop(input_size),            transforms.RandomHorizontalFlip(),            transforms.ToTensor(),            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])        ]),        &#39;val&#39;: transforms.Compose([            transforms.Resize(input_size),            transforms.CenterCrop(input_size),            transforms.ToTensor(),            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])        ]),    }    print(&quot;Initializing Datasets and Dataloaders...&quot;)    # 创建训练和验证数据集    image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x]) for x in [&#39;train&#39;, &#39;val&#39;]}    # 创建训练和验证数据加载器    dataloaders_dict = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size, shuffle=True, num_workers=0) for x in [&#39;train&#39;, &#39;val&#39;]}    # 检测我们是否有可用的GPU    device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)    # 将模型发送到GPU    model_ft = model_ft.to(device)    # 在此运行中收集要优化/更新的参数。    # 如果我们正在进行微调，我们将更新所有参数。    # 但如果我们正在进行特征提取方法，我们只会更新刚刚初始化的参数，即`requires_grad`的参数为True。    params_to_update = model_ft.parameters()    print(&quot;Params to learn:&quot;)    if feature_extract:        params_to_update = []        for name,param in model_ft.named_parameters():            if param.requires_grad == True:                params_to_update.append(param)                print(&quot;\t&quot;,name)    else:        for name,param in model_ft.named_parameters():            if param.requires_grad == True:                print(&quot;\t&quot;,name)    # 观察所有参数都在优化    optimizer_ft = optim.SGD(params_to_update, lr=0.001, momentum=0.9)    # 设置损失函数    criterion = nn.CrossEntropyLoss()    # Train and evaluate    model_ft, hist = train_model(model_ft, dataloaders_dict, criterion, optimizer_ft, num_epochs=num_epochs, is_inception=(model_name==&quot;inception&quot;))</code></pre><h1 id="保存与加载模型"><a href="#保存与加载模型" class="headerlink" title="保存与加载模型"></a>保存与加载模型</h1><p>当保存和加载模型时，需要熟悉三个核心功能：</p><ol><li><code>torch.save</code>：将序列化对象保存到磁盘。此函数使用Python的<code>pickle</code>模块进行序列化。使用此函数可以保存如模型、tensor、字典等各种对象。</li><li><code>torch.load</code>：使用pickle的<code>unpickling</code>功能将pickle对象文件反序列化到内存。此功能还可以有助于设备加载数据。</li><li><code>torch.nn.Module.load_state_dict</code>：使用反序列化函数 state_dict 来加载模型的参数字典。</li></ol><h2 id="状态字典-state-dict"><a href="#状态字典-state-dict" class="headerlink" title="状态字典(state_dict)"></a>状态字典(state_dict)</h2><p>在PyTorch中，<code>torch.nn.Module</code>模型的可学习参数（即权重和偏差）包含在模型的参数中，（使用<code>model.parameters()</code>可以进行访问）。 <code>state_dict</code>是Python字典对象，它将每一层映射到其参数张量。注意，只有具有可学习参数的层（如卷积层，线性层等）的模型 才具有<code>state_dict</code>这一项。目标优化<code>torch.optim</code>也有<code>state_dict</code>属性，它包含有关优化器的状态信息，以及使用的超参数。</p><p>因为state_dict的对象是Python字典，所以它们可以很容易的保存、更新、修改和恢复，为PyTorch模型和优化器添加了大量模块。</p><h2 id="保存和加载推理模型"><a href="#保存和加载推理模型" class="headerlink" title="保存和加载推理模型"></a>保存和加载推理模型</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save(model.state_dict(), PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.eval()</code></pre><p>当保存好模型用来推断的时候，只需要保存模型学习到的参数，使用<code>torch.save()</code>函数来保存模型<code>state_dict</code>，在 PyTorch 中最常见的模型保存使‘.pt’或者是‘.pth’作为模型文件扩展名。</p><p>请记住在运行<code>evaluation</code>之前，务必调用<code>model.eval()</code>去设置 dropout 和 batch normalization 为评估。如果不这样做，有可能得到不一致的<code>evaluation</code>结果。 如果你想要恢复训练，请调用<code>model.train()</code>以确保这些层处于训练模式。</p><ul><li>注意</li></ul><p><code>load_state_dict()</code>函数只接受字典对象，而不是保存对象的路径。这就意味着在你传给<code>load_state_dict()</code>函数之前，你必须反序列化 你保存的<code>state_dict</code>。例如，你无法通过 <code>model.load_state_dict(PATH)</code>来加载模型。</p><h2 id="保存和加载-Checkpoint-用于推理-继续训练"><a href="#保存和加载-Checkpoint-用于推理-继续训练" class="headerlink" title="保存和加载 Checkpoint 用于推理/继续训练"></a>保存和加载 Checkpoint 用于推理/继续训练</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save({            &#39;epoch&#39;: epoch,            &#39;model_state_dict&#39;: model.state_dict(),            &#39;optimizer_state_dict&#39;: optimizer.state_dict(),            &#39;loss&#39;: loss,            ...            }, PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">model = TheModelClass(*args, **kwargs)optimizer = TheOptimizerClass(*args, **kwargs)checkpoint = torch.load(PATH)model.load_state_dict(checkpoint[&#39;model_state_dict&#39;])optimizer.load_state_dict(checkpoint[&#39;optimizer_state_dict&#39;])epoch = checkpoint[&#39;epoch&#39;]loss = checkpoint[&#39;loss&#39;]model.eval()# - or -model.train()</code></pre><p>当保存成 Checkpoint 的时候，可用于推理或者是继续训练，保存的不仅仅是模型的 state_dict 。保存优化器的 state_dict 也很重要, 因为它包含作为模型训练更新的缓冲区和参数。你也许想保存其他项目，比如最新记录的训练损失，外部的<code>torch.nn.Embedding</code>层等等。</p><p>要保存多个组件，请在字典中组织它们并使用<code>torch.save()</code>来序列化字典。PyTorch 中常见的保存checkpoint 是使用 .tar 文件扩展名。</p><p>要加载项目，首先需要初始化模型和优化器，然后使用<code>torch.load()</code>来加载本地字典。这里,你可以非常容易的通过简单查询字典来访问你所保存的项目。</p><h2 id="在一个文件中保存多个模型"><a href="#在一个文件中保存多个模型" class="headerlink" title="在一个文件中保存多个模型"></a>在一个文件中保存多个模型</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save({            &#39;modelA_state_dict&#39;: modelA.state_dict(),            &#39;modelB_state_dict&#39;: modelB.state_dict(),            &#39;optimizerA_state_dict&#39;: optimizerA.state_dict(),            &#39;optimizerB_state_dict&#39;: optimizerB.state_dict(),            ...            }, PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">modelA = TheModelAClass(*args, **kwargs)modelB = TheModelBClass(*args, **kwargs)optimizerA = TheOptimizerAClass(*args, **kwargs)optimizerB = TheOptimizerBClass(*args, **kwargs)checkpoint = torch.load(PATH)modelA.load_state_dict(checkpoint[&#39;modelA_state_dict&#39;])modelB.load_state_dict(checkpoint[&#39;modelB_state_dict&#39;])optimizerA.load_state_dict(checkpoint[&#39;optimizerA_state_dict&#39;])optimizerB.load_state_dict(checkpoint[&#39;optimizerB_state_dict&#39;])modelA.eval()modelB.eval()# - or -modelA.train()modelB.train()</code></pre><p>当保存一个模型由多个<code>torch.nn.Modules</code>组成时，例如GAN(对抗生成网络)、sequence-to-sequence (序列到序列模型), 或者是多个模 型融合, 可以采用与保存常规检查点相同的方法。换句话说，保存每个模型的 state_dict 的字典和相对应的优化器。如前所述，可以通 过简单地将它们附加到字典的方式来保存任何其他项目，这样有助于恢复训练。</p><p>PyTorch 中常见的保存 checkpoint 是使用 .tar 文件扩展名。</p><p>要加载项目，首先需要初始化模型和优化器，然后使用<code>torch.load()</code>来加载本地字典。这里，你可以非常容易的通过简单查询字典来访问你所保存的项目。</p><h2 id="使用在不同模型参数下的热启动模式"><a href="#使用在不同模型参数下的热启动模式" class="headerlink" title="使用在不同模型参数下的热启动模式"></a>使用在不同模型参数下的热启动模式</h2><ul><li>保存</li></ul><pre><code class="lang-python">torch.save(modelA.state_dict(), PATH)</code></pre><ul><li>加载</li></ul><pre><code class="lang-python">modelB = TheModelBClass(*args, **kwargs)modelB.load_state_dict(torch.load(PATH), strict=False)</code></pre><p>在迁移学习或训练新的复杂模型时，部分加载模型或加载部分模型是常见的情况。利用训练好的参数，有助于热启动训练过程，并希望帮助你的模型比从头开始训练能够更快地收敛。</p><p>无论是从缺少某些键的 state_dict 加载还是从键的数目多于加载模型的 state_dict , 都可以通过在<code>load_state_dict()</code>函数中将<code>strict</code>参数设置为 False 来忽略非匹配键的函数。</p><p>如果要将参数从一个层加载到另一个层，但是某些键不匹配，主要修改正在加载的 state_dict 中的参数键的名称以匹配要在加载到模型中的键即可。</p><h2 id="通过设备保存-加载模型"><a href="#通过设备保存-加载模型" class="headerlink" title="通过设备保存/加载模型"></a>通过设备保存/加载模型</h2><h3 id="Save-on-GPU-Load-on-CPU"><a href="#Save-on-GPU-Load-on-CPU" class="headerlink" title="Save on GPU, Load on CPU"></a>Save on GPU, Load on CPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&#39;cpu&#39;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH, map_location=device))</code></pre><h3 id="Save-on-GPU-Load-on-GPU"><a href="#Save-on-GPU-Load-on-GPU" class="headerlink" title="Save on GPU, Load on GPU"></a>Save on GPU, Load on GPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&quot;cuda&quot;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH))model.to(device)# Make sure to call input = input.to(device) on any input tensors that you feed to the model</code></pre><p>当在GPU上训练并把模型保存在GPU，只需要使用<code>model.to(torch.device(&#39;cuda&#39;))</code>，将初始化的 model 转换为 CUDA 优化模型。另外，请 务必在所有模型输入上使用<code>.to(torch.device(&#39;cuda&#39;))</code>函数来为模型准备数据。请注意，调用<code>my_tensor.to(device)</code>会在GPU上返回<code>my_tensor</code>的副本。 因此，请记住手动覆盖张量：<code>my_tensor= my_tensor.to(torch.device(&#39;cuda&#39;))</code>。</p><h3 id="Save-on-CPU-Load-on-GPU"><a href="#Save-on-CPU-Load-on-GPU" class="headerlink" title="Save on CPU, Load on GPU"></a>Save on CPU, Load on GPU</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code>device = torch.device(&quot;cuda&quot;)model = TheModelClass(*args, **kwargs)model.load_state_dict(torch.load(PATH, map_location=&quot;cuda:0&quot;))  # Choose whatever GPU device number you wantmodel.to(device)# Make sure to call input = input.to(device) on any input tensors that you feed to the model</code></pre><p>在CPU上训练好并保存的模型加载到GPU时，将<code>torch.load()</code>函数中的<code>map_location</code>参数设置为<code>cuda:device_id</code>。这会将模型加载到 指定的GPU设备。接下来，请务必调用<code>model.to(torch.device(&#39;cuda&#39;))</code>将模型的参数张量转换为 CUDA 张量。最后，确保在所有模型输入上使用 <code>.to(torch.device(&#39;cuda&#39;))</code>函数来为CUDA优化模型。请注意，调用<code>my_tensor.to(device)</code>会在GPU上返回<code>my_tensor</code>的新副本。它不会覆盖<code>my_tensor</code>。 因此， 请手动覆盖张量<code>my_tensor = my_tensor.to(torch.device(&#39;cuda&#39;))</code>。</p><h3 id="Saving-torch-nn-DataParallel-Models"><a href="#Saving-torch-nn-DataParallel-Models" class="headerlink" title="Saving torch.nn.DataParallel Models"></a>Saving <code>torch.nn.DataParallel</code> Models</h3><p><strong>Save:</strong></p><pre><code>torch.save(model.module.state_dict(), PATH)</code></pre><p><strong>Load:</strong></p><pre><code># Load to whatever device you want</code></pre><p><code>torch.nn.DataParallel</code>是一个模型封装，支持并行GPU使用。要普通保存 DataParallel 模型, 请保存<code>model.module.state_dict()</code>。 这样，你就可以非常灵活地以任何方式加载模型到你想要的设备中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://pytorch123.com/" target="_blank" rel="noopener">http://pytorch123.com/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编程基础</title>
    <link href="/2020/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>总结一些计算机基础知识</p><a id="more"></a><h1 id="储存单位"><a href="#储存单位" class="headerlink" title="储存单位"></a>储存单位</h1><ul><li><strong>位(bit)</strong>：数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。计算机中的CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一个机器周期内可以处理32位二进制数据的计算机。</li><li><strong>字节(byte)</strong>：是8个二进制数，即8 bit 就称为一个字节（Byte）。字节这个词最早起源于1956年前后，由IBM公司提出。最早的拼写方式是bite，但是为了避免与bit混淆用y代替了i。</li><li><strong>字(word)</strong>：字由若干字节构成，字的位数叫字长，一台8位机子：一个字等于1个字节，字长为8位，如果是16位的机子，一个字等于2个字节，字长为16，字是计算机处理数据和运算的单位。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">位</th><th style="text-align:left">范围</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">-128 到 127 或者 0 到 255</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">0 到 255</td></tr><tr><td style="text-align:left">signed char</td><td style="text-align:left">1 个字节</td><td style="text-align:left">-128 到 127</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">-2147483648 到 2147483647</td></tr><tr><td style="text-align:left">unsigned int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">0 到 4294967295</td></tr><tr><td style="text-align:left">signed int</td><td style="text-align:left">4 个字节</td><td style="text-align:left">-2147483648 到 2147483647</td></tr><tr><td style="text-align:left">short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">-32768 到 32767</td></tr><tr><td style="text-align:left">unsigned short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">0 到 65,535</td></tr><tr><td style="text-align:left">signed short int</td><td style="text-align:left">2 个字节</td><td style="text-align:left">-32768 到 32767</td></tr><tr><td style="text-align:left">long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left">signed long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left">unsigned long int</td><td style="text-align:left">8 个字节</td><td style="text-align:left">0 到 18,446,744,073,709,551,615</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">4 个字节</td><td style="text-align:left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8 个字节</td><td style="text-align:left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td style="text-align:left">long double</td><td style="text-align:left">16 个字节</td><td style="text-align:left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td style="text-align:left">wchar_t</td><td style="text-align:left">2 或 4 个字节</td><td style="text-align:left">1 个宽字符</td></tr></tbody></table></div><p><strong>注意：</strong>不同系统会有所差异。</p><h1 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h1><p>我们知道现在计算机普遍使用二进制来表示，这是因为二进制能够工作的更好。对于二进制数来说，单独的讲某一个位没有太多的意义，但是可以将多个位组合起来，再加上某种解释，就可以用来表示我们日常生活中常用的数字。 计算机中常用表示的数又分为<strong>有符号数</strong>、<strong>无符号数</strong>和<strong>浮点数</strong>。</p><p><img src="20180503165002430.png" alt="image1"></p><h2 id="无符号"><a href="#无符号" class="headerlink" title="无符号"></a>无符号</h2><p>无符号表示大于或者等于0的数字，是基于传统的二进制表示法进行编码。无符号的二进制数表示一个很重要的特性，也就是对于任何介于0~2^w-1 之间的数值都有一个唯一w为的值编码。</p><h2 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h2><p>有符号数表示可以为正或者为负的数字，通常采用<strong>补码</strong>进行编码。 负数是有符号的数值,对于负数来说，我们最难的就是如何表示它的负号.先来看看什么是<strong>原码</strong>、<strong>补码</strong>、<strong>反码</strong>。</p><p><strong>原码</strong></p><p>原码是计算机中数字的二进制定点表示法。数码序列中最高位表示符号位，符号0表示正数，符号1表示负数，其余位表示数值的大小。</p><p>这样我们使用一个符号位的引用就可以表示正数、负数。对于一个8位二进制数来说，能够表示的范围就是-127(1111 1111)~127(0111 1111)。 但对于原码表示有一个致命的缺点，就是不能参加运算。例如：-1(1000 0001) + 1(0000 0001) = 0(1000 0010) 这个二进制数的实际数值是-2.这显然不对。</p><p><strong>反码</strong></p><p>正数的反码就是它本身。</p><p>负数的反码是在原码的基础上，符号位不变，数值位按位取反。</p><p>这样对于上述-1+1等于-2的问题就解决了。0001 + 1110(-1的反码) = 1111(反码) 转换到对应的数为-0. 但这又带来了一个问题.即0这个数有两种表示法+0和-0。</p><p><strong>补码</strong></p><p>正数的补码是其原码本身。</p><p>负数的补码是在其反码基础上再加1。</p><p>例如：</p><p>【+7】补码 = 0000 0111</p><p>【-7】 补码 = 1111 1001</p><p>我们使用补码来计算时，如果丢弃最高位对的进位，正负相加的确是为0的。而11111111表示的数字是-128，不再是-0。</p><p>至此，我们可以使用补码来表示我们生活中常用的正数、负数；当然，这是我们丢弃了最高位的代价来换取的。</p><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>小数点为定点，用来表示小数的，采用的是BCD码来编码。BCD码将0~9中的每个数用4位二进制数来表示，这样对于32位就可以表示8个数字，表示的数字范围也就是0~999999.99之间的1亿个实数。</p><p>BCD编码也有很多用途，比如银行、超市这种需要用到小数记金额的情况就很合适，但是如果表示很小、或者很大的数就不是很合适了，比如地球到太阳的距离，一个氢原子的半径等等。而且这样编码非常浪费，对于32位整数我们可以表示将近40亿个数字，而BCD编码的数字只能表示1亿个数字。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>IEEE754标准规定，浮点数由“符号”、“指数”和“尾数”3部分构成，float的规格化表示为：<script type="math/tex">±1.*f*×2^{*E*−127}</script><br> ，其中，<em>f</em>是尾数，<em>E</em>是指数。以float为例：<br><img src="20180716165243972.png" alt="image2"></p><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>srand函数是随机数发生器的初始化函数。</p><pre><code class="lang-c++">void srand(unsigned seed)</code></pre><p><code>srand()</code>需要提供一个种子，这个种子会对应一个随机数，如果使用相同的种子后面的rand()函数会出现一样的随机数。如：<code>srand(1)</code>，直接使用 1 来初始化种子。不过为了防止随机数每次重复，常常使用系统时间来初始化，即使用 time 函数来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数，然后将 time_t 型数据转化为(unsigned)型再传给 srand 函数，即： srand((unsigned) time(&amp;t)); 还有一个经常用法，不需要定义time_t型t变量，即： srand((unsigned) time(NULL))；直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的t数据。</p><pre><code class="lang-c++">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt; /*用到了time函数，所以要有这个头文件*/#define MAX 10int main(void){    int number[MAX] = { 0 };    int i;    srand((unsigned)time(NULL)); /*播种子*/    for (i = 0; i &lt; MAX; i++)    {        number[i] = rand() % 100; /*产生100以内的随机整数*/        printf(&quot;%d &quot;, number[i]);    }    printf(&quot;\n&quot;);    return 0;}</code></pre><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><div class="table-container"><table><thead><tr><th style="text-align:left">转义序列</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">\</td><td style="text-align:left">\ 字符</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">‘ 字符</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“ 字符</td></tr><tr><td style="text-align:left">\?</td><td style="text-align:left">? 字符</td></tr><tr><td style="text-align:left">\a</td><td style="text-align:left">警报铃声</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格键</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行符</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平制表符</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">一到三位的八进制数</td></tr><tr><td style="text-align:left">\xhh . . .</td><td style="text-align:left">一个或多个数字的十六进制数</td></tr></tbody></table></div><h1 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h1><p>在 C++ 中，有两种简单的定义常量的方式：</p><ul><li><p>使用 <strong>#define</strong> 预处理器。</p><pre><code class="lang-c++">#define identifier value</code></pre></li><li><p>使用 <strong>const</strong> 关键字。</p><pre><code class="lang-c++">const type variable = value;</code></pre></li></ul><h1 id="Struct和Class"><a href="#Struct和Class" class="headerlink" title="Struct和Class"></a>Struct和Class</h1><p>C++ 中关键字<code>struct</code>和<code>class</code>都是用来定义类的，二者除了默认访问限定符不同，结构体（包括共用体）默认成员为public，而类默认成员是private型的。其他所有方面都一样。</p><p>数组里的对象，不论是类对象（struct或者class），还是基础数据类型，如果没有给初始化列表，一律执行<strong>值初始化</strong>，即基础数据类型都初始化为0，类对象执行<strong>默认构造函数</strong>（即不接受任何参数的构造函数）。如果struct里面自己定义了一个构造函数，那么编译器不会隐式地声明一个默认构造函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/return9/article/details/79888603" target="_blank" rel="noopener">https://blog.csdn.net/return9/article/details/79888603</a></li><li><a href="https://blog.csdn.net/chihujiang3132/article/details/100930007" target="_blank" rel="noopener">https://blog.csdn.net/chihujiang3132/article/details/100930007</a></li><li><a href="https://blog.csdn.net/whyel/article/details/81067989" target="_blank" rel="noopener">https://blog.csdn.net/whyel/article/details/81067989</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查并集(Union-find algorithm)</title>
    <link href="/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/"/>
    <url>/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</url>
    
    <content type="html"><![CDATA[<p>查并集的进化之路</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p><ul><li>查找（Find）：确定某个元素处于哪个子集；</li><li>合并（Union）：将两个子集合并成一个集合。</li></ul><p>也就是说，不支持集合的分离、删除。</p><h1 id="Quick-Find算法"><a href="#Quick-Find算法" class="headerlink" title="Quick-Find算法"></a>Quick-Find算法</h1><p>以下图为例，连通关系为<code>[(1,2), (0, 1), (0, 3), (4, 7), (5, 6), (5, 7), (7, 8), (8, 9)]</code>。</p><p><img src="uf1.png" alt="uf"></p><p>首先初始化所有节点，认为它们属于一个组，因此不连通的节点必然就属于不同的组：</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>输入pair<code>(1, 2)</code>，则将<strong>所有</strong><code>group number</code>为<code>0</code>和<code>1</code>的<code>element</code>改为一致（都为<code>0</code>或都为<code>1</code>，这里以较小值为例）。</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td>1</td><td><strong>1</strong></td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>输入pair<code>(0， 1)</code>，这里就需要把<code>element 1</code>和<code>element 2</code>的<code>group number</code>都改为<code>0</code>，：</p><div class="table-container"><table><thead><tr><th>element</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>group number / id</td><td>0</td><td><strong>0</strong></td><td><strong>0</strong></td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p>正因为每次都需要找到所有的特定<code>group number</code>的<code>element</code>，所以<code>union</code>的时间复杂度为O(N)，<code>find</code>的时间复杂度为O(1)。N为<code>element</code>的个数，下同。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickFind(object):    id = []    count = 0    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):            return self.id[p]    def union(self, p, q):        idp = self.find(p)        idq = self.find(q)        if idp != idq:            for i in range(len(self.id)):                if self.id[i] == idq: # 将q所在组内的所有节点的id都设为p的当前id                    self.id[i] = idp            self.count -= 1</code></pre><h1 id="Quick-Union算法"><a href="#Quick-Union算法" class="headerlink" title="Quick-Union算法"></a>Quick-Union算法</h1><p>对于只需要实现查找和合并的并查集，O(n)的时间复杂度还是太高了，当时间复杂度需要降低到对数级，我们自然想到了<strong>树</strong>这个数据结构。由于并查集初始化中每一个<code>element</code>对于一个<code>group number</code>，所以可以通过数组中的跳转来实现树的寻找父节点功能。以下图为例，最开始每一个<code>element</code>的父节点都是自身，每次查找沿着父节点向上， 直到根节点。每次合并把找到的两个根节点的其中一个设置为另一个的父节点。</p><p><img src="1339479431_6633.png" alt="qu"></p><p><code>union</code>和<code>find</code>的时间复杂度取决于树的高度。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickUnion(object):    id = []    count = 0    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):            while (p != self.id[p]):            p = self.id[p]        return p    def union(self, p, q):        root_p = self.find(p)        root_q = self.find(q)        if root_p != root_q:            self.id[root_q] = root_p            self.count -= 1</code></pre><p><em>注意：此时<code>self.id</code>存放的不再是每个元素的组别而是父节点。</em></p><h1 id="Weighted-Quick-Union-算法"><a href="#Weighted-Quick-Union-算法" class="headerlink" title="Weighted Quick-Union 算法"></a>Weighted Quick-Union 算法</h1><p>既然采用了<strong>树</strong>的结构，就有可能出现极端情况，是的树操作的时间复杂度退化成O(N)。为了避免这种情况，常规方法是使用平衡树，而对于并查集，只需要在<code>union</code>时，选择将小的树合并到大树上就可以了。</p><p><img src="1339479587_5986.png" alt="wqu"></p><p>理论上在平衡树合并两个树时，应当用根的高度来衡量两个树的大小，但是这里使用根节点的子孙节点的数量来衡量，<code>union</code>和<code>find</code>的时间复杂度接近于O(log  N)。这是因为这个方法还可以优化，通过路径压缩可以将<code>union</code>和<code>find</code>的时间复杂度降低至O(1)，而这样做会改变根的高度。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class WeightedQuickUnion(object):    id = []    count = 0    sz = []    def __init__(self, n):        self.count = n        for i in range(n):            self.id.append(i)            self.sz.append(1) # inital size of each tree is 1    def connected(self, p, q):        return self.find(p) == self.find(q)    def find(self, p):           while (p != self.id[p]):            p = self.id[p]        return p    def union(self, p, q):        root_p = self.find(p)        root_q = self.find(q)        if root_p != root_q:            if self.sz[root_p] &lt; self.sz[root_q]:                self.id[root_p] = root_q                self.sz[root_q] += self.sz[root_p]            else:                self.id[root_q] = root_p                self.sz[root_p] += self.sz[root_q]                           self.count -=1</code></pre><p>输出<code>self.sz</code>可以看到<code>id = 1</code>和<code>id = 5</code>的组别包含了所有元素，<code>id = 4</code>组中的<code>(4, 7)</code>实际上已经移动到<code>id = 5</code>组中。</p><pre><code class="lang-python">size:  [1, 4, 1, 1, 2, 6, 1, 1, 1, 1]</code></pre><h1 id="Weighted-Quick-Union-With-Path-Compression-算法"><a href="#Weighted-Quick-Union-With-Path-Compression-算法" class="headerlink" title="Weighted Quick-Union With Path Compression 算法"></a>Weighted Quick-Union With Path Compression 算法</h1><p>第一种方法是在<code>find</code>方法的执行过程中保存所有路过的中间节点到一个数组中，然后在<code>while</code>循环结束之后，将这些中间节点的父节点指向根节点。但是这个方法在<code>find</code>操作很频繁时会频繁生成中间节点数组，相应的分配销毁的时间自然就上升了。另一种方法是在寻找<code>q</code>的根节点的同时不断改变父节点，相当于在寻找根节点的同时，不断地将<code>q</code>移动到上一级的节点下，对路径进行了压缩，使整个树结构扁平化。相应的实现如下，实际上只需要在<code>find</code>方法中添加一行代码。</p><pre><code class="lang-python">def find(self, p):           while (p != self.id[p]):            self.id[p] = self.id[self.id[p]]            p = self.id[p]        return p</code></pre><p>这样<code>self.id</code>中保存的既是个元素的组别又是各元素的父节点，正因为如此<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。</p><pre><code class="lang-python">final parent/id list is 1,1,1,1,5,5,5,5,5,5</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="leetcode-200-岛屿数量"><a href="#leetcode-200-岛屿数量" class="headerlink" title="leetcode 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode 200. 岛屿数量</a></h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><pre><code class="lang-python">输入:   1 1 1 1 0      ====&gt;     输出: 1          1 1 0 1 0              1 1 0 0 0        1 0 0 0 0</code></pre><p>简单应用<a href="https://lil-q.github.io/2020/01/02/查并集-union-find-algorithm/#Quick-Union算法">Quick-Union算法</a>即可，用<code>dict</code>代替<code>list</code>。</p><pre><code class="lang-python">class Solution:    def numIslands(self, grid: List[List[str]]) -&gt; int:        if not grid or not grid[0]:            return 0         row = len(grid)        col = len(grid[0])        def find(x):            f.setdefault(x, x)            while f[x] != x:                x = f[x]            return x        def union(x, y):            rootx = find(x)            rooty = find(y)            if rootx != rooty:                f[rootx] = rooty                return 1            return 0        s = 0        f = {}        for i in range(row):            for j in range(col):                if grid[i][j] == &#39;1&#39;:                    s += 1                    for x, y in ((1, 0), (0, 1)):                        tmp_i = i + x                        tmp_j = j + y                        if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &#39;1&#39;:                            # 如果需要合并那么总岛屿数就减一，不需要合并则不变（减零）                            s -= union((i, j), (tmp_i, tmp_j))        return s</code></pre><h2 id="leetcode-684-冗余连接"><a href="#leetcode-684-冗余连接" class="headerlink" title="leetcode 684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">leetcode 684. 冗余连接</a></h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:  1 / \2 - 3</code></pre><p>遍历所有的边，<code>union</code>所有边的两个顶点，如果出现两个顶点已经连接的情况，说明已经构成换，删掉这条边即可。实现如下：</p><pre><code class="lang-python">class Solution:    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:        def find(x):            f.setdefault(x,x)            while x != f[x]:                f[x] = f[f[x]]                x = f[x]            return x        def union(x, y):            rootx = find(x)            rooty = find(y)            if rootx != rooty:                f[rootx] = rooty                return 1            return 0        f = {}        for x, y in edges:            if not union(x, y): return[x, y]</code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着一步步地深入，我们最终将查并集<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。本文中的四种算法的时间复杂度如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>Algorithm</strong></th><th style="text-align:center"><strong>Constructor</strong></th><th style="text-align:center"><strong>Union</strong></th><th style="text-align:center"><strong>Find</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>Quick-Find</strong></td><td style="text-align:center">N</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center"><strong>Quick-Union</strong></td><td style="text-align:center">N</td><td style="text-align:center">Tree height</td><td style="text-align:center">Tree height</td></tr><tr><td style="text-align:center"><strong>Weighted Quick-Union</strong></td><td style="text-align:center">N</td><td style="text-align:center">near to O(log N)</td><td style="text-align:center">near to O(log N)</td></tr><tr><td style="text-align:center"><strong>Weighted Quick-Union With Path Compression</strong></td><td style="text-align:center">N</td><td style="text-align:center">Very near to O(1)</td><td style="text-align:center">Very near to O(1)</td></tr></tbody></table></div><p>需要注意<code>Path Compression</code>是将各节点压缩到根节点下，所以<code>Weighted</code>仍然有意义。当然如果还需要输出连通路径，这个方法是没办法实现的，需要BFS或DFS算法来实现。</p><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Union-Find" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/Guo15331092/article/details/78702686" target="_blank" rel="noopener">https://blog.csdn.net/Guo15331092/article/details/78702686</a></li><li><a href="https://www.jianshu.com/p/72da76a34db1" target="_blank" rel="noopener">https://www.jianshu.com/p/72da76a34db1</a></li><li><a href="https://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/7655764</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>查并集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图(graph)</title>
    <link href="/2019/12/27/%E5%9B%BE-graph/"/>
    <url>/2019/12/27/%E5%9B%BE-graph/</url>
    
    <content type="html"><![CDATA[<p>生活不就是一张图吗？</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>图</strong>(Graph)用于表示物件与物件之间的关系，是<a href="https://zh.wikipedia.org/wiki/圖論" target="_blank" rel="noopener">图论</a>的基本研究对象。一张图由一些小圆点（称为<strong>顶点</strong>或<strong>结点</strong>）和连结这些圆点的直线或曲线（称为<strong>边</strong>）组成。</p><p>一个图 $G$ 是一个二元组，即序偶 $\langle V,E\rangle$ ，或记作 $G= \langle V,E\rangle$ ，其中 $V$ 是有限非空集合，称为 $G$ 的顶点集， $V$ 中的元素称为顶点或结点； $E$ 称为 $G$ 的边的集合， $\forall e_i \in E$ ，都有 $V$ 中的结点与之对应，称 $e_i$ 为 $G$ 的边。</p><p>简单来说，就是图 $G$ 就是一个结点的集合 $V$ 和边的集合 $E$ ，其中任意一条边都可以表示为两个结点之间的关系。若 $e_i\in E$ 表示为 $\langle u,v\rangle$ ，则有 $u\in V , v\in V$ 。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>无向图：每条边都是无向边的图。</p><p>有向图：每条边都是有向边的图。</p><p>有权图：每条边具有一定的权重(weight)，通常是一个数字</p><p>无权图：每条边均没有权重，也可以理解为权为 1</p><p>连通图：所有的点都有路径相连</p><p>非连通图：存在某两个点没有路径相连</p><p>混合图：在一个图中，有些边是有向边，另一些边是无向边，则该图为混合图。</p><p>有限图：一个图的点集和边集都是有穷集的图。</p><p>零图：边集为空集的图。</p><p>平凡图：仅有一个结点而没有边构成的图。</p><p>关联：若有 $e_i=(u,v)$ 且 $e_i\in E$ ，则称 $u$ 是和 $v$ 相关联的。</p><p>孤立点：无边关联的点。</p><p>自环：若一条边所关联的两个结点重合，则称此边为自环。</p><p>邻接：关联于同一条边的两个点 $u$ 和 $v$ 称为邻接的；关联于同一个点的两条边 $e_1$ 和 $e_2$ 是邻接的（或相邻的）。</p><h2 id="结点的度数"><a href="#结点的度数" class="headerlink" title="结点的度数"></a>结点的度数</h2><p>设图 $G= \langle V,E\rangle$ 为一个有向图， $v\in V$ ，关联于结点 $v$ 的 <strong>边</strong> 的条数，称为点 $v$ 的度数，记作 $\deg(v)$ 。</p><p>注意：一个自环为它的端点增加 2 度。</p><p>当图 $G= \langle V,E\rangle$ 为一个有向图， $v\in V$ ，称以 $v$ 作为始点的边数之和称为结点 $v$ 的出度，记为 $\deg^{+} (v)$ 。将以 $v$ 作为终点的边数之和称为结点 $v$ 的入度，记为 $\deg^{-} (v)$ 。称以 $v$ 作为端点的边数之和为结点 $v$ 的度数或度，记为 $\deg(v)$ 。</p><p>显然， $\forall v\in V,\deg(v)=deg^{+} (v)+\deg^{-} (v)$ 。</p><h2 id="子图的概念"><a href="#子图的概念" class="headerlink" title="子图的概念"></a>子图的概念</h2><p>设有图 $G= \langle V,E\rangle$ 和图 $G’= \langle V’,E’\rangle$ 。</p><p>如果 $V’\subseteq V,E’\subseteq E$ ，则称 $G’$ 是 $G$ 的子图，记作 $G’\subseteq G$ 。</p><p>如果 $G’\subsetneqq G$ ，即 $V’\subset V$ 或 $E’\subset E$ ，则称 $G’$ 是 $G$ 的真子图，记作 $G’\subset G$ 。</p><p>如果 $V’=V,E’\subseteq E$ ，则称 $G’$ 是 $G$ 的生成子图。</p><p>如果 $V’’\subseteq V$ 且 $V’’ \neq \varnothing$ ，以 $V’’$ 为结点集，以两端点均在 $V’’$ 中的边为边集的 $G$ 的子图，称为 $V’’$ 导出的 $G$ 的子图，简称为 $V’’$ 的导出子图。</p><p>如果 $G’’= \langle V’’,E’’\rangle$ 使得 $E’’=E-E’$ ，且 $V’’$ 中仅包含 $E’’$ 中的边所关联的结点，则称 $G’’$ 是子图 $G’$ 相对于原图 $G$ 的补图。</p><h2 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h2><p>树：边数比结点数少一的连通图。更多内容，详见 树相关基础。</p><p>森林：由 $m$ 棵（ $m\ge 0$ ）互不相交的树组成的图。</p><p>基环树：边数和点数相等的连通图。</p><p>仙人掌：每条边至多属于一个简单环的无向连通图。</p><p>在无向图中，关联一对顶点的边多于 $1$ 条，则称这些边为重边（平行边），重边的条数称为重数。</p><p>简单图：不含重边和自环的图。</p><p>多重图：含重边的图。</p><p>完全图：每对不同的顶点之间都恰连有一条边相连的简单无向图。容易证明， $n$ 个顶点的完全图有 $\dfrac{n(n-1)}{2}$ 条边。</p><p>竞赛图：通过在完全图中为每条边分配方向而获得的有向图。</p><p><em>参考资料：离散数学（修订版），田文成 周禄新 编著，天津文学出版社，P184-187</em></p><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>以下图作为例子。</p><p><img src="21cd2731928c7c13057eee000e3697de82ccc058.png" alt="edge lists"></p><h2 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h2><p>建立一个数组，数组里每个元素是图的一条边。</p><p>这样做有个缺点，每次想要知道两个点之间是否有连边（或者说一条边是否存在），都需要在数组里进行一番查找。而且如果没有对边事先排序的话，就不能使用二分查找的方法（ $O(\log n)$ ），而是每次只能按顺序找（ $O(n)$ ），成本较高。</p><p>什么时候会用到这个方法呢？最简单的一个例子是使用 Kruskal 算法求最小生成树的时候。</p><pre><code class="lang-python">[ [0,1], [0,6], [0,8], [1,4], [1,6], [1,9], [2,4], [2,6], [3,4], [3,5],[3,8], [4,5], [4,9], [7,8], [7,9] ]</code></pre><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵的英文名是 adjacency matrix。它的形式是 <code>bool adj[n][n]</code> ，这里面 $n$ 是节点个数， $adj[i][j]$ 表示 $i$ 和 $j$ 之间是否有边。</p><p>如果边有权值，也可以直接用 <code>int adj[n][n]</code> ，直接把边权存进去。</p><p>它的优点是可以在 $O(1)$ 时间内得到一条边是否存在，缺点是需要占用 $O(n^2)$ 的空间。对于一个稀疏的图（边相对于点数的平方比较少）来说，用邻接矩阵来存的话，成本偏高。</p><p><img src="549bca1a52774846b25caff86d244d03ee63fd38.png" alt="matrix"></p><pre><code class="lang-python">[ [0, 1, 0, 0, 0, 0, 1, 0, 1, 0],  [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],  [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],  [0, 0, 0, 0, 1, 1, 0, 0, 1, 0],  [0, 1, 1, 1, 0, 1, 0, 0, 0, 1],  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],  [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1],  [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],  [0, 1, 0, 0, 1, 0, 0, 1, 0, 0] ]</code></pre><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表英文名是 adjacency list。它的形式是 <code>vector adj[n]</code> ，用 <code>adj[i]</code> 存以 $i$ 为起点的边。</p><p>用 <code>vector</code> 无法科学地删除，所以常用 <code>list</code> 实现。</p><p>它的特点是可以用来按顺序访问一个结点的出边（或者入边）。</p><p><img src="cc82379521bd84738e86d6cf9552738ca9138420.png" alt="linklist"></p><pre><code class="lang-python">[ [1, 6, 8],  [0, 4, 6, 9],  [4, 6],  [4, 5, 8],  [1, 2, 3, 5, 9],  [3, 4],  [0, 1, 2],  [8, 9],  [0, 3, 7],  [1, 4, 7] ]</code></pre><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><strong>图的遍历</strong>问题分为四类：</p><ul><li>遍历完所有的<strong>边</strong>而不能有重复，即所谓“欧拉路径问题”（又名<a href="https://zh.wikipedia.org/wiki/一笔画问题" target="_blank" rel="noopener">一笔画问题</a>）；</li><li>遍历完所有的<strong>顶点</strong>而没有重复，即所谓“<a href="https://zh.wikipedia.org/wiki/哈密頓路徑問題" target="_blank" rel="noopener">哈密顿路径问题</a>”。</li><li>遍历完所有的<strong>边</strong>而可以有重复，即所谓“<a href="https://zh.wikipedia.org/wiki/中国邮递员问题" target="_blank" rel="noopener">中国邮递员问题</a>”；</li><li>遍历完所有的<strong>顶点</strong>而可以重复，即所谓“<a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">旅行推销员问题</a>”。</li></ul><p>对于第一和第三类问题已经得到了完满的解决，而第二和第四类问题则只得到了部分解决。</p><p>第一类问题就是研究所谓的<a href="https://zh.wikipedia.org/wiki/欧拉图" target="_blank" rel="noopener">欧拉图</a>的性质，而第二类问题则是研究所谓的<a href="https://zh.wikipedia.org/wiki/哈密顿图" target="_blank" rel="noopener">哈密顿图</a>的性质。</p><p>图的遍历方法有深度优先搜索法和广度(宽度)优先搜索法。以下图为例。</p><p><img src="graph1.png" alt="graph"></p><p>建立邻接表：</p><pre><code class="lang-python">adjacencylists = [[1, 2, 3],                  [0, 4, 5],                  [0, 6],                  [0, 6],                  [1, 5],                  [1, 4, 6],                  [2, 3, 5]]</code></pre><h2 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索(Depth First Search, DFS)"></a>深度优先搜索(Depth First Search, DFS)</h2><p><strong>深度优先搜索算法</strong>(Depth-First-Search，DFS)是一种用于遍历或搜索<strong>树</strong>或<strong>图</strong>的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p><p><img src="graph2.png" alt="graph2"></p><h2 id="广度优先搜索-Breadth-First-Search-BFS"><a href="#广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="广度优先搜索(Breadth First Search, BFS)"></a>广度优先搜索(Breadth First Search, BFS)</h2><p><strong>广度优先搜索算法</strong>(Breadth-First-Search，缩写为BFS)，又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种图形搜索算法。简单的说，BFS是从<strong>根节点](<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1)开始，沿着树的宽度遍历树的" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1)开始，沿着树的宽度遍历树的</a></strong>节点**。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。</p><p><img src="graph3.png" alt="graph3"></p><h2 id="Python的简易实现"><a href="#Python的简易实现" class="headerlink" title="Python的简易实现"></a>Python的简易实现</h2><pre><code class="lang-python"># 设置总节点数num_vertexs = 7# 建立邻接表adjacencylists = [[1, 2, 3],                  [0, 4, 5],                  [0, 6],                  [0, 6],                  [1, 5],                  [1, 4, 6],                  [2, 3, 5]]class graph:    def __init__(self, num_vertexs, adjacencylists):        self.num_vertexs = num_vertexs        self.adjacencylists = adjacencylists    def dfs(self, start):        # 记录节点是否已经访问        visited = [False] * self.num_vertexs        res = []        def helper(v):                if visited[v]:                return            visited[v] = True            res.append(v)            for i in self.adjacencylists[v]:                helper(i)        helper(start)        return res    def bfs(self, start):        visited = [False] * self.num_vertexs        visited[start] = True        res = [start,]        queue = [start,]        while queue:            cur = queue.pop(0)            for i in self.adjacencylists[cur]:                if  not visited[i]:                    queue.append(i)                    visited[i] = True                    res.append(i)        return resif __name__ == &#39;__main__&#39;:        # 实例化    graph = graph(num_vertexs, adjacencylists)    t1 = graph.dfs(0)    print(&quot;深度优先搜索：&quot;, t1)    t2 = graph.bfs(0)    print(&quot;广度优先搜索：&quot;, t2)</code></pre><p>注意：这里用index表示节点名称，最后还需要映射出结果（假设0,1,2,3…分别对应A,B,C,D…下文会使用字典来实现邻接表，这样就不需要这一步了）：</p><pre><code class="lang-python">vertexs = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]t3 = list(map(lambda x: vertexs[x], t1))print(&quot;深度优先搜索：&quot;, t3)t4 = list(map(lambda x: vertexs[x], t2))print(&quot;广度优先搜索：&quot;, t4)</code></pre><p><img src="graph4.png" alt="graph2"></p><p>输出：</p><pre><code class="lang-python">深度优先搜索： [0, 1, 4, 5, 6, 2, 3]广度优先搜索： [0, 1, 2, 3, 4, 5, 6]深度优先搜索： [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;C&#39;, &#39;D&#39;]广度优先搜索： [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</code></pre><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Dijkstra 算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。Dijkstra 算法属于单源算法，即只能求出某点到其它点最短距离，并不能得出任意两点之间的最短距离，只能用权值为正数的图，存在负数时可能回陷入死循环。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组distances来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：nodes。以下图为例，假设求A点到其他点的距离。</p><p><img src="graph5.png" alt="graph2"></p><ol><li><p>初始化distances，原点 s 的路径权重被赋为 0 （dis[s] = 0）。把到其他顶点的路径长度设为无穷大。</p><pre><code class="lang-python">distances = {&#39;A&#39;: 0, &#39;B&#39;: inf, &#39;C&#39;: inf, &#39;D&#39;: inf, &#39;E&#39;: inf, &#39;F&#39;: inf, &#39;G&#39;: inf}</code></pre></li><li><p>初始nodes，理论上集合nodes只有顶点s。这里创建了其他节点是方便之后的进堆操作，不用再考虑节点是否存在两种情况。</p><pre><code class="lang-python">nodes = [[0, &#39;A&#39;], [inf, &#39;B&#39;], [inf, &#39;C&#39;], [inf, &#39;D&#39;], [inf, &#39;E&#39;], [inf, &#39;F&#39;], [inf, &#39;G&#39;]]</code></pre></li><li><p>从distances数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到nodes中。</p><pre><code class="lang-python">distances = {&#39;A&#39;: 0, &#39;B&#39;: 4, &#39;C&#39;: 2, &#39;D&#39;: 3, &#39;E&#39;: inf, &#39;F&#39;: inf, &#39;G&#39;: inf} # 加入了A的近邻B，C，Dnodes = [[2, &#39;C&#39;], [3, &#39;D&#39;], [4, &#39;B&#39;], [inf, &#39;G&#39;], [inf, &#39;E&#39;], [inf, &#39;F&#39;]] # A被推出，更新B，C，D</code></pre></li><li><p>重复这个过程，直到nodes为s空或nodes中的最小值是无穷大（与剩下的节点都不连通）时。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">import heapqclass Graph:    def __init__(self):        self.vertices = {}    def add_vertex(self, name, edges):        self.vertices[name] = edges    def shortest_path(self, start, finish):        distances = {} # 记录各点到起点距离        previous = {}  # 记录先前路径，注意：对于求最小路径时，每个点的先前路径是唯一的。        nodes = [] # 优先队列        for vertex in self.vertices:            if vertex == start: # 原点 s 的路径权重被赋为 0 （dis[s] = 0）。把到其他顶点的路径长度设为无穷大。                distances[vertex] = 0                heapq.heappush(nodes, [0, vertex])            else:                distances[vertex] = float(&#39;inf&#39;)                heapq.heappush(nodes, [float(&#39;inf&#39;), vertex])            previous[vertex] = None        while nodes:            smallest = heapq.heappop(nodes)[1] # pop优先队列的第一个节点            if smallest == finish: # 保存路径                path = []                cur = smallest                while cur: # 循环到起点，其先前节点为None，结束                    path.append(cur)                    cur = previous[cur]                path.reverse()            if distances[smallest] == float(&#39;inf&#39;): # 剩余所有节点已不相邻                break                  for neighbor in self.vertices[smallest]: # 获取近邻节点                alt = distances[smallest] + self.vertices[smallest][neighbor]                 if alt &lt; distances[neighbor]: # 得到的路径比之前的近，则更新nodes，previous                    previous[neighbor] = smallest                    distances[neighbor] = alt                    for n in nodes:                        if n[1] == neighbor:                            n[0] = alt                            break                    heapq.heapify(nodes)            #print(distances,nodes)        return distances[finish], path    def __str__(self):        return str(self.vertices)if __name__ == &#39;__main__&#39;:    # 实例化，这个类需要依次传入所有边。    g = Graph()    g.add_vertex(&#39;A&#39;, {&#39;B&#39;: 4, &#39;C&#39;: 2, &#39;D&#39;: 3})    g.add_vertex(&#39;B&#39;, {&#39;A&#39;: 4, &#39;E&#39;: 2, &#39;F&#39;: 5})    g.add_vertex(&#39;C&#39;, {&#39;A&#39;: 2, &#39;G&#39;: 1})    g.add_vertex(&#39;D&#39;, {&#39;A&#39;: 3, &#39;G&#39;: 2})    g.add_vertex(&#39;E&#39;, {&#39;B&#39;: 2, &#39;F&#39;: 4})    g.add_vertex(&#39;F&#39;, {&#39;B&#39;: 5, &#39;E&#39;: 4, &#39;G&#39;: 3})    g.add_vertex(&#39;G&#39;, {&#39;C&#39;: 1, &#39;D&#39;: 2, &#39;F&#39;: 3})    print(g.shortest_path(&#39;A&#39;, &#39;G&#39;))</code></pre><h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>Floyd-Warshall算法</strong>(Floyd-Warshall algorithm)，中文亦称<strong>弗洛伊德算法</strong>，是解决任意两点间的最短路径的一种算法，可以正确处理<strong>有向图</strong>或<strong>负权</strong>（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。</p><p>Floyd 算法是一个经典的动态规划算法。</p><p>设<script type="math/tex">D_{i,j,k}</script>为从<script type="math/tex">i</script>到<script type="math/tex">j</script>的只以<script type="math/tex">(i, j)</script>集合中的节点为中间节点的最短路径的长度。</p><ol><li>若最短路径经过点k，则<script type="math/tex">D_{i,j,k}=D_{i,k,k-1}+D_{k,j,k-1}</script>；</li><li>若最短路径不经过点k，则<script type="math/tex">D_{i,j,k}=D_{i,j,k-1}</script></li></ol><p>因此，<script type="math/tex">D_{i,j,k}=min(D_{i,j,k-1},D_{i,k,k-1}+D_{k,j,k-1})</script>。</p><p>在实际算法中，为了节约空间，可以直接在原来空间上进行迭代，这样空间可降至二维。</p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="1920px-Floyd-Warshall_example.svg.png" alt="graphh"></p><p><img src="2019-12-30 224429.png" alt="gg"></p><p>Floyd-Warshall算法的<a href="https://zh.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a>为<script type="math/tex">O(N^{3})</script>，<a href="https://zh.wikipedia.org/wiki/空间复杂度" target="_blank" rel="noopener">空间复杂度</a>为<script type="math/tex">O(N^{2})</script>。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def floyd(graph):    length = len(graph)    path = {}    # 建立初始路径path    for i in range(length):        path[i] = {}        for j in range(length):            if i != j and graph[i][j] != float(&#39;inf&#39;):                path[i][j] = [i, j]    # i为选取的中间节点    for i in range(length):                # j为中间节点i的前节点        for j in range(length):            if i == j:                continue            # k为中间节点i的后节点            for k in range(length):                if k == i or k == j:                    continue                new_len = graph[j][i] + graph[i][k]                if graph[j][k] &gt; new_len:                    graph[j][k] = new_len                    new_node = i                    # 合并路径                    path[j][k] = path[j][i][:-1] + path[i][k]    return graph, pathif __name__ == &#39;__main__&#39;:    ini = float(&#39;inf&#39;)    graph_list = [                      [0, ini, -2, ini],                    [4, 0, 3, ini],                    [ini, ini, 0, 2],                    [ini, -1, ini, 0]                 ]    new_graph, path = floyd(graph_list)    print(new_graph, &#39;\n\n\n&#39;, path)</code></pre><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>对连通<strong>图</strong>进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。</p><p><img src="2-1Z106101951H4.gif" alt="连通图及其对应的生成树"></p><p>a) 是一张连通图，b) 是其对应的 2 种生成树。</p><p>连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。</p><p>连通图中的生成树必须满足以下 2 个条件：</p><ol><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ol><p>因此，连通图的生成树具有这样的特征，即生成树中<code>边的数量 = 顶点数 - 1</code>。</p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p><strong>普里姆算法</strong>（Prim’s algorithm），<strong>图论</strong>中的一种算法，可在加权连通图里搜索<strong>最小生成树</strong>。意即由此算法搜索到的<strong>边</strong>子集所构成的<strong>树</strong>中，不但包括了连通图里的所有<strong>顶点</strong>，且其所有边的权值之和亦为最小。</p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>输入：一个加权连通图，其中顶点集合为 V，边集合为 E</li><li>初始化：Vnew = {x}，其中 x 为集合 V 中的任一节点(起始点)，Enew = {} 为空</li><li>在集合 E 中选取权值最小的边 <u, v>，其中 u 为集合 Vnew 中的元素，而 v 不在 Vnew 集合当中，并且 v∈V (如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）</li><li>将 v 加入集合 Vnew 中，将 <u, v> 边加入集合 Enew 中</li><li>重复步骤 3、4 直到 Vnew = V</li></ol><p><img src="graph6.png" alt="g"></p><p>时间复杂度：<script type="math/tex">O(V^2)</script></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def prim(graph, root):    assert type(graph)==dict    nodes = list(graph)    nodes.remove(root)    visited = [root]    path = []    next = None    while nodes:        distance = float(&#39;inf&#39;)         for s in visited:            for d in graph[s]:                if d in visited or s == d:                    continue                if graph[s][d] &lt; distance:                    distance = graph[s][d]                    pre = s                    next = d        path.append((pre, next))        visited.append(next)        nodes.remove(next)    return pathif __name__ == &#39;__main__&#39;:    ini = float(&#39;inf&#39;)    graph_dict = {  &#39;A&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 4,   &#39;C&#39;: 2,   &#39;D&#39;: 3,   &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: ini},                    &#39;B&#39;: {&#39;A&#39;: 4,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: 2,   &#39;F&#39;: 5,   &#39;G&#39;: ini},                    &#39;C&#39;: {&#39;A&#39;: 2,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: 1  },                    &#39;D&#39;: {&#39;A&#39;: 3,   &#39;B&#39;: ini, &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: ini, &#39;G&#39;: 2  },                    &#39;E&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 2,   &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: ini, &#39;F&#39;: 4,   &#39;G&#39;: ini},                    &#39;F&#39;: {&#39;A&#39;: ini, &#39;B&#39;: 5,   &#39;C&#39;: ini, &#39;D&#39;: ini, &#39;E&#39;: 4,   &#39;F&#39;: ini, &#39;G&#39;: 3  },                    &#39;G&#39;: {&#39;A&#39;: ini, &#39;B&#39;: ini, &#39;C&#39;: 1,   &#39;D&#39;: 2,   &#39;E&#39;: ini, &#39;F&#39;: 3,   &#39;G&#39;: ini},                 }    path = prim(graph_dict, &#39;A&#39;)    print(&quot;path:&quot;, path)</code></pre><p>可以看到输出顺序和上图是一致的：</p><pre><code class="lang-python">path: [(&#39;A&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;G&#39;), (&#39;G&#39;, &#39;D&#39;), (&#39;G&#39;, &#39;F&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;E&#39;)]</code></pre><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p><strong>Kruskal算法</strong>是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。基于<a href="https://lil-q.github.io/2020/01/02/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/">并查集</a>的数据结构。</p><p><img src="383px-MST_kruskal_en.gif" alt="kru"></p><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol><li>新建图<script type="math/tex">G</script>，<script type="math/tex">G</script>中拥有原图中相同的节点，但没有边</li><li>将原图中所有的边按权值从小到大排序</li><li>从权值最小的边开始，如果这条边连接的两个节点于图<script type="math/tex">G</script>中不在同一个连通分量中，则添加这条边到图<script type="math/tex">G</script>中</li><li>重复3，直至图<script type="math/tex">G</script>中所有的节点都在同一个连通分量中</li></ol><p><img src="graph7.png" alt="kur"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def find(id, p):    while p != id[p]:        id[p] = id[id[p]]        p = id[p]    return pdef union(id, size, p, q):    root_p = find(id, p)    root_q = find(id, q)    if root_p != root_q:        if size[p] &lt; size[q]:            id[root_p] = root_q            size[q] += size[p]        else:            id[root_q] = root_p            size[p] += size[q]def kruskal(graph):    assert type(graph)==dict    edges = [(graph[u][v], u, v) for u in graph for v in graph[u] if graph[u][v] != float(&#39;inf&#39;)]    path = []    id, size = {u:u for u in graph}, {u:0 for u in graph}    for _, u, v in sorted(edges):        if find(id, u) != find(id, v):            path.append((u, v))            union(id, size, u, v)    return path</code></pre><p>输入与理论一致：</p><pre><code class="lang-python">path:  [(&#39;C&#39;, &#39;G&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;E&#39;), (&#39;D&#39;, &#39;G&#39;), (&#39;F&#39;, &#39;G&#39;), (&#39;A&#39;, &#39;B&#39;)]</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-leetcode-778-水位上升的泳池中游泳"><a href="#1-leetcode-778-水位上升的泳池中游泳" class="headerlink" title="1. leetcode 778. 水位上升的泳池中游泳"></a>1. <a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">leetcode 778. 水位上升的泳池中游泳</a></h2><p>在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</p><p>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</p><pre><code class="lang-python">输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]输入: 16解释:0   1   2   3   4             　 512  13  14  15  1611  10  9   8   7   6</code></pre><p>使用简化版的Dijkstra算法。</p><pre><code class="lang-python">class Solution(object):    def swimInWater(self, grid):        N = len(grid)        seen = {(0, 0)} # 记录已经访问过的点        pq = [(grid[0][0], 0, 0)] # 创建优先队列        ans = 0        while pq:            d, r, c = heapq.heappop(pq)            # 更新最小路径中的最大值            ans = max(ans, d)            if r == c == N-1: return ans            # 将有可能经过的点都加入到优先队列            for cr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):                if 0 &lt;= cr &lt; N and 0 &lt;= cc &lt; N and (cr, cc) not in seen:                    heapq.heappush(pq, (grid[cr][cc], cr, cc))                    seen.add((cr, cc))</code></pre><h2 id="2-leetcode-207-课程表"><a href="#2-leetcode-207-课程表" class="headerlink" title="2. leetcode 207. 课程表"></a>2. <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">leetcode 207. 课程表</a></h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>这是典型的有向图的拓扑排序问题。有两种解法，利用入度表和深度有限搜索。</p><h3 id="解法一：入度表"><a href="#解法一：入度表" class="headerlink" title="解法一：入度表"></a>解法一：入度表</h3><ol><li>将边信息转换为邻接表<code>adjacency</code>，同时记录每个点的入度<code>indegrees</code></li><li>取出所有入度为0的点加入队列<code>queue</code></li><li>宽度优先搜索，每从队列里取出一个节点，numCourses -= 1, 环内的节点入度不会为0，所以当有环时, numcourses不为0</li></ol><pre><code class="lang-python">class Solution:    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:        indegrees = [0 for _ in range(numCourses)]        adjacency = [[] for _ in range(numCourses)]        queue = []        # 将边信息转换为邻接表adjacency，同时记录每个点的入度indegrees        for cur, pre in prerequisites:            indegrees[cur] += 1            adjacency[pre].append(cur)        # 取出所有入度为0的点加入队列queue        for i in range(len(indegrees)):            if not indegrees[i]: queue.append(i)        # 宽度优先搜索        while queue:            pre = queue.pop(0)            numCourses -= 1            for cur in adjacency[pre]:                indegrees[cur] -= 1                if not indegrees[cur]: queue.append(cur)        return not numCourses</code></pre><h3 id="解法二：深度优先搜索"><a href="#解法二：深度优先搜索" class="headerlink" title="解法二：深度优先搜索"></a>解法二：深度优先搜索</h3><p>借助一个标志列表 flags，用于判断每个节点 i （课程）的状态：</p><blockquote><p>未被 DFS 访问：i == 0；<br>已被其他节点启动的DFS访问：i == -1；<br>已被当前节点启动的DFS访问：i == 1。 </p></blockquote><pre><code class="lang-python">class Solution(object):    def canFinish(self, numCourses, prerequisites):        # 深度优先搜索        def dfs(i,adjacency,flags):            if flags[i]==1:return False            if flags[i]==-1:return True            flags[i]=1            print(i,adjacency)            for nex in adjacency[i]:                if not dfs(nex,adjacency,flags):return False            flags[i]=-1            return True        # 建立邻接表，并在最后加入一个节点指向所有的节点        flags=[0 for _ in range(numCourses+1)]        adjacency=[[] for _ in range(numCourses)]         adjacency.append([i for i in range(numCourses)])                for cur,pre in prerequisites:            adjacency[pre].append(cur)        # 对最后的dummy节点进行深度优先搜索            return dfs(numCourses,adjacency,flags)</code></pre><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Graph" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/skywang12345/p/3691463.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3691463.html</a></li><li><a href="https://zh.wikipedia.org/wiki/图_(数学" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)</a>)</li><li><a href="https://oi-wiki.org/graph/" target="_blank" rel="noopener">https://oi-wiki.org/graph/</a></li><li><a href="http://data.biancheng.net/view/202.html" target="_blank" rel="noopener">http://data.biancheng.net/view/202.html</a></li><li><a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs</a></li><li><a href="https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组(Array)和哈希表(Hash table)</title>
    <link href="/2019/12/09/%E6%95%B0%E7%BB%84-Array/"/>
    <url>/2019/12/09/%E6%95%B0%E7%BB%84-Array/</url>
    
    <content type="html"><![CDATA[<p>数组和哈希表的学习和python实现</p><a id="more"></a><h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><p><strong>数组数据结构</strong>(array data structure)，简称<strong>数组</strong>(Array)，是由相同类型的元素(element)的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引(index)可以计算出该元素对应的存储地址。</p><p>数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表(list)和字符串(string)。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是向量处理器），经常会针对数组操作进行优化。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>Python中 list 数据结构的复杂度。</p><div class="table-container"><table><thead><tr><th>操作</th><th>操作说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>index(value)</td><td>查找list某个元素的索引</td><td>O(1)</td></tr><tr><td>a = index(value)</td><td>索引赋值</td><td>O(1)</td></tr><tr><td>append(value)</td><td>队尾添加</td><td>O(1)</td></tr><tr><td>pop()</td><td>队尾删除</td><td>O(1)</td></tr><tr><td>pop(index)</td><td>根据索引删除某个元素</td><td>O(n)</td></tr><tr><td>insert(index, value)</td><td>根据索引插入某个元素</td><td>O(n)</td></tr><tr><td>iterration</td><td>列表迭代</td><td>O(n)</td></tr><tr><td>search(in)</td><td>列表搜索（其实就是in关键字）</td><td>O(n)</td></tr><tr><td>slice [x:y]</td><td>切片, 获取x, y为O(1), 获取x,y 中间的值为O(k)</td><td>O(k)</td></tr><tr><td>del slice [x:y]</td><td>删除切片，删除切片后数据需要重新移动/合并</td><td>O(n)</td></tr><tr><td>reverse</td><td>列表反转</td><td>O(n)</td></tr><tr><td>sort</td><td>排序</td><td>O(nlogn)</td></tr></tbody></table></div><h1 id="哈希表-Hash-table"><a href="#哈希表-Hash-table" class="headerlink" title="哈希表(Hash table)"></a>哈希表(Hash table)</h1><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据键(Key)而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。</p><ol><li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值为散列地址。</li><li><strong>数字分析法</strong>：假设关键字是以<em>r</em>为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</li><li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。</li><li><strong>折叠法</strong>：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</li><li><strong>随机数法</strong></li><li><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。不仅可以对关键字直接取模，也可在<strong>折叠法</strong>、<strong>平方取中法</strong>等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。</li></ol><h3 id="1-正整数"><a href="#1-正整数" class="headerlink" title="1. 正整数"></a>1. 正整数</h3><p>获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。</p><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h3><p>将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如</p><pre><code class="lang-python">def getHashCode(str):    hash = 0    for char in str:        hash = int(char) + (31 * hash)    return hash</code></pre><p>上面的哈希值是Horner计算字符串哈希值的方法，公式为:</p><script type="math/tex; mode=display">h = s[0] · 31^{L–1} + … + s[L – 3] · 31^2 + s[L – 2] · 31^1 + s[L – 1] · 31^0</script><p>举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 3045982 = 99·31^3 + 97·31^2 + 108·31^1 + 108·31^0 = 108 + 31· (108 + 31 · (97 + 31 · (99)))。</p><pre><code class="lang-python">print(getHashCode(&quot;call&quot;))&#39;&#39;&#39;输出： 3045982&#39;&#39;&#39;</code></pre><p>如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值。但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串：</p><p><img src="312300343319616.jpg" alt="hash code collision"></p><p>如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。</p><h2 id="哈希冲撞"><a href="#哈希冲撞" class="headerlink" title="哈希冲撞"></a>哈希冲撞</h2><p>如果将2450个密钥散列到一百万个存储桶中，即使具有完全均匀的随机分布，则根据生日问题，至少有两个密钥散列到同一存储桶的机率大约为95％。<script type="math/tex">1*\frac{10^6-1}{10^6}*\frac{10^6-2}{10^6}</script>…<script type="math/tex">\frac{10^6-2449}{10^6}</script></p><pre><code class="lang-python">res=1n=1000000for i in range(2450):    res*=(n-1)/nprint(res)&#39;&#39;&#39;0.9975529975784029&#39;&#39;&#39;</code></pre><p><a href="https://zh.wikipedia.org/zh-hans/生日攻击" target="_blank" rel="noopener">有兴趣可以了解一下生日攻击。</a></p><h3 id="1-Separate-chaining"><a href="#1-Separate-chaining" class="headerlink" title="1. Separate chaining"></a>1. Separate chaining</h3><p>每一个<code>bucket</code>指向一个数组、链表或其他数据结构。</p><p><img src="675px-Hash_table_5_0_1_1_1_1_1_LL.svg.png" alt="spe"></p><h3 id="2-Open-addressing"><a href="#2-Open-addressing" class="headerlink" title="2. Open addressing"></a>2. Open addressing</h3><p>每一个<code>bucket</code>存放一个<code>entry record</code>,添加时如果已占用就下移一格，查找同理。</p><p><img src="570px-Hash_table_5_0_1_1_1_1_0_SP.svg.png" alt="opa"></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>Python中 dict 数据结构的复杂度</p><div class="table-container"><table><thead><tr><th>操作</th><th>操作说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>copy</td><td>复制</td><td>O(n)</td></tr><tr><td>get(value)</td><td>获取</td><td>O(1)</td></tr><tr><td>set(value)</td><td>修改</td><td>O(1)</td></tr><tr><td>delete(value)</td><td>删除</td><td>O(1)</td></tr><tr><td>search(in)</td><td>字典搜索</td><td>O(1)</td></tr><tr><td>iterration</td><td>字典迭代</td><td>O(n)</td></tr></tbody></table></div><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-力扣（leetcode）204-计数质数"><a href="#1-力扣（leetcode）204-计数质数" class="headerlink" title="1. 力扣（leetcode）204. 计数质数"></a>1. <a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">力扣（leetcode）204. 计数质数</a></h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p><pre><code class="lang-python">class Solution:    def countPrimes(self, n: int) -&gt; int:        isPrime = [1] * n         for i in range(2, int(n ** 0.5) + 1):            if isPrime[i]:                for j in range(i * i, n, i):                    isPrime[j] = 0        counts = 0        for i in range(2,len(isPrime)):            if isPrime[i] : counts += 1        return counts</code></pre><h2 id="2-力扣（leetcode）355-设计推特"><a href="#2-力扣（leetcode）355-设计推特" class="headerlink" title="2. 力扣（leetcode）355. 设计推特"></a>2. <a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">力扣（leetcode）355. 设计推特</a></h2><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p><p>postTweet(userId, tweetId): 创建一条新的推文<br>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。<br>follow(followerId, followeeId): 关注一个用户<br>unfollow(followerId, followeeId): 取消关注一个用户</p><pre><code class="lang-python">from collections import defaultdictclass Twitter:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.timeline = defaultdict(list)        self.userId_follower = defaultdict(set)        self.now = 1    class post:        def __init__(self, tweetId, time):            self.id = tweetId            self.time = time            self.next = None    def postTweet(self, userId: int, tweetId: int) -&gt; None:        &quot;&quot;&quot;        Compose a new tweet.        &quot;&quot;&quot;        po = self.post(tweetId, self.now)        if len(self.timeline[userId]) &gt; 0:            po.next = self.timeline[userId][-1]        self.timeline[userId].append(po)        self.now += 1    def getNewsFeed(self, userId):        &quot;&quot;&quot;        Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.        &quot;&quot;&quot;        res = []        queue = []        for uid in self.userId_follower[userId] | {userId}:            if len(self.timeline[uid]) &gt; 0:                queue.append(self.timeline[uid][-1])        if not queue: return []        for _ in range(10):            maxIndex = 0            maxId = 0            f = 0            for i in range(len(queue)):                if queue[i] and (queue[i].time &gt; maxId):                    maxId=queue[i].time                    maxIndex = i                    f = 1            if f == 0 and not queue[0]: break            res.append(queue[maxIndex].id)            queue[maxIndex]=queue[maxIndex].next         return res    def follow(self, followerId: int, followeeId: int) -&gt; None:        &quot;&quot;&quot;        Follower follows a followee. If the operation is invalid, it should be a no-op.        &quot;&quot;&quot;        self.userId_follower[followerId].add(followeeId)    def unfollow(self, followerId: int, followeeId: int) -&gt; None:        &quot;&quot;&quot;        Follower unfollows a followee. If the operation is invalid, it should be a no-op.        &quot;&quot;&quot;        self.userId_follower[followerId].discard(followeeId)</code></pre><p>采用了<a href="https://leetcode-cn.com/problems/design-twitter/solution/mian-xiang-dui-xiang-she-ji-he-bing-k-ge-you-xu-li/" target="_blank" rel="noopener">优先队列</a>的思路</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84</a></li><li><a href="https://zh.wikipedia.org/zh-hans/哈希表" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%93%88%E5%B8%8C%E8%A1%A8</a></li><li><a href="https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html</a></li><li><a href="https://www.jianshu.com/p/fa57d21b9ad7" target="_blank" rel="noopener">https://www.jianshu.com/p/fa57d21b9ad7</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈(Stack)和队列(Queue)</title>
    <link href="/2019/12/08/%E6%A0%88-Stack-%E5%92%8C%E9%98%9F%E5%88%97-Queue/"/>
    <url>/2019/12/08/%E6%A0%88-Stack-%E5%92%8C%E9%98%9F%E5%88%97-Queue/</url>
    
    <content type="html"><![CDATA[<p>栈和队列的学习和python实现</p><a id="more"></a><h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><p><strong>堆栈</strong>(stack)又称为<strong>栈</strong>或<strong>堆叠</strong>，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，top）进行加入数据(push)和移除数据(pop)的运算。因而按照后进先出(LIFO, Last In First Out)原理运作。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>堆栈使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：</p><ul><li>推入：将数据放入堆栈顶端，堆栈顶端移到新放入的数据。</li><li>弹出：将堆栈顶端数据移除，堆栈顶端移到移除后的下一笔数据。</li></ul><p>在python中，可用<code>list</code>模拟栈，<code>append()</code>模拟入栈，<code>pop()</code>模拟出栈。</p><p><img src="300px-Data_stack.svg.png" alt="stack"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="leetcode-20-有效的括号"><a href="#leetcode-20-有效的括号" class="headerlink" title="leetcode 20.有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">leetcode 20.有效的括号</a></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。注意空字符串可被认为是有效字符串。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><pre><code class="lang-python">class Solution:    def isValid(self, s: str) -&gt; bool:        dic={&#39;)&#39;:&#39;(&#39;,&#39;}&#39;:&#39;{&#39;,&#39;]&#39;:&#39;[&#39;}        stack=[]        for char in s:            # 右括号匹配栈顶的字符            if char in dic:                # 空栈或不匹配，则输出False                if not stack or stack[-1]!=dic[char]:                    return False                # 匹配成功，左括号出栈                else:                    stack.pop()            # 左括号直接插入            else:                stack.append(char)        return True if not stack else False</code></pre><h3 id="leetcode-84-柱状图中最大的矩形"><a href="#leetcode-84-柱状图中最大的矩形" class="headerlink" title="leetcode 84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">leetcode 84. 柱状图中最大的矩形</a></h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="histogram_area.png" alt="84"></p><pre><code class="lang-python">class Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        stack = [0]        # 增加左右边界        heights = [0] + heights + [0]        res = 0        # 建立一个递增栈，记录index，方便计算宽度        for i in range(1,len(heights)):            # 当出现递减的数时，对栈内大于该数的数处理            while heights[stack[-1]] &gt; heights[i]:                tmp = stack.pop()                res = max(res, (i - stack[-1] - 1) * heights[tmp])            stack.append(i)        return res</code></pre><h3 id="leetcode-316-去除重复字母"><a href="#leetcode-316-去除重复字母" class="headerlink" title="leetcode 316. 去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">leetcode 316. 去除重复字母</a></h3><p>给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><pre><code class="lang-python">class Solution:    def removeDuplicateLetters(self, s: str) -&gt; str:        stack = []        existed = set()        counter = {}        for c in s:            counter[c]=counter.get(c,0)+1        for c in s:            if c not in existed:                 # 后面还有这个数，我们才能放心的删除                while stack and stack[-1] &gt; c and counter[stack[-1]]:                    existed.remove(stack.pop())                stack.append(c)                existed.add(c)            counter[c]-=1        return &#39;&#39;.join(stack)</code></pre><p>其实也是建立了一个递增栈，但是这里需要满足所有的字母最后只出现一次。</p><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p><strong>队列</strong>(queue)，是先进先出(FIFO, First-In-First-Out)的线性表。在具体应用中通常用链表或者数组来实现。</p><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><p>队列只允许在后端（<em>rear</em>）进行插入操作，在前端（<em>front</em>）进行删除操作。</p><p>在python中，可用<code>list</code>模拟简单模拟队列，<code>append()</code>模拟插入，<code>pop(0)</code>模拟删除。或使用<code>deque</code>。</p><pre><code class="lang-python">from collections import deque</code></pre><p><a href="https://zhuanlan.zhihu.com/p/45798936" target="_blank" rel="noopener">队列的实现分为顺序存储结构和链式存储结构，前者基于数组实现，后者则实基于单链表。</a>简单来说，顺序储存结构在进行队列删除操作时会留出空的储存空间，最后导致假溢。解决办法是引入了循环向量这个概念，也就是把队列的头尾相连接并且使用顺序存储结构进行数据存储的队列，这时队列称<strong>循环队列</strong>。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="leetcode-622-设计循环队列"><a href="#leetcode-622-设计循环队列" class="headerlink" title="leetcode 622. 设计循环队列"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">leetcode 622. 设计循环队列</a></h3><pre><code class="lang-python">class MyCircularQueue:    def __init__(self, k: int):        self.size = k        self.cq = [0]*k        self.eq = 0        self.dq = 0        self.count = 0    def enQueue(self, value: int) -&gt; bool:        if self.count == self.size:            return False        self.cq[self.eq] = value        self.eq += 1        if self.eq == self.size:            self.eq = 0        self.count += 1        return True    def deQueue(self) -&gt; bool:        if self.count == 0:            return False        self.dq += 1        if self.dq == self.size:            self.dq = 0        self.count -= 1        return True    def Front(self) -&gt; int:        if self.count == 0:            return -1        return self.cq[self.dq]    def Rear(self) -&gt; int:        if self.count == 0:            return -1        return self.cq[self.eq-1]    def isEmpty(self) -&gt; bool:        return self.count == 0    def isFull(self) -&gt; bool:        return self.count == self.size</code></pre><p>这里每当头尾指针溢出（也就是等于k时），将其置为0。当然也可以一直使用<code>self.eq%self.size</code>和<code>self.dq%self.size</code>作为指针。</p><h3 id="leetcode-102-二叉树的层次遍历"><a href="#leetcode-102-二叉树的层次遍历" class="headerlink" title="leetcode 102. 二叉树的层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode 102. 二叉树的层次遍历</a></h3><pre><code class="lang-python">from collections import dequeclass Solution:    def levelOrder(self, root):        levels = []        if not root:            return levels                level = 0        queue = deque([root,])        while queue:            levels.append([])            level_length = len(queue)                      for i in range(level_length):                node = queue.popleft()                levels[level].append(node.val)                if node.left:                    queue.append(node.left)                if node.right:                    queue.append(node.right)            level += 1         return levels</code></pre><p>当然如果不分层的话会更直观：</p><pre><code class="lang-python">from collections import dequedef levelOrderTraversal(root):    res=[]    queue = deque([root,])    while queue:        node = queue.popleft()        if node.left :            queue.append(node.left)            if node.right:                queue.append(node.right)                res.append(node.val)    return res</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/堆栈" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88</a></li><li><a href="https://zh.wikipedia.org/wiki/队列" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树(Tree)</title>
    <link href="/2019/12/04/%E6%A0%91-tree/"/>
    <url>/2019/12/04/%E6%A0%91-tree/</url>
    
    <content type="html"><![CDATA[<p>之所以叫树是因为他看起来像一棵倒挂的树</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>树</strong>（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点都只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ol><li><strong>节点的度(Degree)</strong>：一个节点含有的子树的个数称为该节点的度</li><li><strong>树的度(Degree of tree)</strong>：一棵树中，最大的节点度称为树的度</li><li><strong>叶节点(Leaf)</strong>：度为零的节点</li><li><strong>分支节点(Branch node)</strong>：度不为零的节点</li><li><strong>父节点(Parent)</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点</li><li><strong>子节点(child)</strong>：一个节点含有的子树的根节点称为该节点的子节点</li><li><strong>兄弟节点(siblings)</strong>：具有相同父节点的节点互称为兄弟节点</li><li><strong>层次(level)</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推</li><li><strong>深度(depth)</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0</li><li><strong>高度(height)</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0</li><li><strong>节点的祖先(ancestor)</strong>：从根到该节点所经分支上的所有节点</li><li><strong>森林(forest)</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林</li></ol><p><img src="height-depth.jpg" alt="层次深度和高度"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>本文将介绍二叉树(Binary tree)、二叉搜索树(Binary search tree)和字典树(Trie)。关于AVL树(AVL tree)、红黑树(Red–black tree)和Ｂ树(B-tree)，不做深入探讨。</p><p><img src="tree-cate.jpg" alt="cate"></p><p>这里区分一下完全二叉树、满二叉树、完美二叉树:</p><ol><li>完全二叉树：最后一层的叶子节点均需在最左边</li><li>满二叉树：满足完全二叉树性质，树中除了叶子节点，每个节点都有两个子节点</li><li>完美二叉树：满足满二叉树性质，树的叶子节点铺满最后一层</li></ol><p><img src="BinaryTree2.png" alt="full"></p><h2 id="二叉树-Binary-tree"><a href="#二叉树-Binary-tree" class="headerlink" title="二叉树(Binary tree)"></a>二叉树(Binary tree)</h2><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p><pre><code class="lang-python"># 建一个单节点class Node(object):    def __init__(self, value):        self.val = value        self.left = None #左节点        self.right = None #右节点&#39;&#39;&#39;# 建一个二叉树#           1 #         /   \ #        2     3#       / \   / \#      4   5 6   7&#39;&#39;&#39;root = Node(1)stack = [root]value = 2for i in range(3):    cur = stack.pop(0)    cur.left = Node(value)    stack.append(cur.left)    value += 1    cur.right = Node(value)    stack.append(cur.right)    value += 1</code></pre><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历有前序遍历、中序遍历、后序遍历和层序遍历等，这里用迭代和递归两个方法介绍。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def preorderTraversal(root):    if not root:        return     print(root.val, end = &#39; &#39;)    preorderTraversal(root.left)    preorderTraversal(root.right)</code></pre><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><pre><code class="lang-python"># 方法一def preorderTraversalIter(root):    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        print(node.val, end = &#39; &#39;)        if node.right:            stack.append(node.right)        if node.left:            stack.append(node.left)# 方法二def preorderTraversalIter(root):    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            print(root.val, end = &#39; &#39;)            root=root.left        root=stack.pop()        root=root.right</code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def inorderTraversal(root):    if not root:        return      inorderTraversal(root.left)    print(root.val)    inorderTraversal(root.right)</code></pre><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><pre><code class="lang-python">def inorderTraversalIter(root):    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            root=root.left        root=stack.pop()        print(root.val, end = &#39; &#39;)        root=root.right</code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h5><pre><code class="lang-python">def postorderTraversal(root):    if not root:        return      postorderTraversal(root.left)    postorderTraversal(root.right)    print(root.val)</code></pre><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>比较tricky的办法是吧后序遍历转变成中右左遍历的倒序，代码如下</p><pre><code class="lang-python"># 方法一def postorderTraversalIter(root):    res = []    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        if node.left :            stack.append(node.left)        if node.right:            stack.append(node.right)        res.append(node.val)    return res[::-1]# 方法二def postorderTraversalIter(root):    res = []    if not root:        return res    stack = []    while root or stack:        while root:            stack.append(root)            res.append(root.val)            root = root.right        root = stack.pop()        root = root.left    return res[::-1]</code></pre><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><pre><code class="lang-python">def levelOrderTraversal(root):    # 使用列表模拟先进先出队列queue    queue = [root]    while queue:        node = queue.pop(0)        if node.left :            queue.append(node.left)        if node.right:            queue.append(node.right)        print(node.val, end = &#39; &#39;)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code class="lang-python">前序遍历_递归：1 2 4 5 3 6 7 前序遍历_迭代：1 2 4 5 3 6 7 中序遍历_递归：4 2 5 1 6 3 7 中序遍历_迭代：4 2 5 1 6 3 7 后序遍历_递归：4 5 2 6 7 3 1 后序遍历_迭代：4 5 2 6 7 3 1 层序遍历：1 2 3 4 5 6 7</code></pre><h3 id="二叉树的序列化"><a href="#二叉树的序列化" class="headerlink" title="二叉树的序列化"></a>二叉树的序列化</h3><p>「序列化」（serialization），指的是把复杂的数据结构转化为线性结构，以方便存储的过程。序列化得到的线性结构必须能重建出原有的结构，才有意义。</p><h4 id="仅使用一种遍历的序列化方法"><a href="#仅使用一种遍历的序列化方法" class="headerlink" title="仅使用一种遍历的序列化方法"></a>仅使用一种遍历的序列化方法</h4><p>这是最常见的序列化方法。可以采用的遍历顺序包括先序、后序、层序。在遍历时，要把空指针也包含在遍历的结果中。例如，对下图的二叉树，进行先序、后序、层序遍历的结果分别为 12##3#4##、##2###431、123###4##（# 表示空指针）。</p><p><img src="v2-fa1e727f17845ced6ad75d476b9ec3cf_hd.jpg" alt="xu"></p><pre><code class="lang-python">def reconstruct(root):    if not root:        return res    stack = [root]    while stack:        node = stack.pop()        print(node.val, end=&#39; &#39;)        if node.right:            stack.append(node.right)        else:            print(&#39;#&#39;, end = &#39; &#39;)        if node.left:            stack.append(node.left)        else:            print(&#39;#&#39;, end = &#39; &#39;)</code></pre><p>而仅根据（带空指针的）中序遍历，是不能重建二叉树的。比如，上面这棵树的中序遍历为 #2#1#3#4#。事实上可以证明，任何一棵二叉树的中序遍历结果，都会是空指针与树中结点交替出现的形式，所以空指针没有提供任何额外的信息。<a href="https://zhuanlan.zhihu.com/p/26418233" target="_blank" rel="noopener">原文</a></p><h2 id="二叉搜索树-Binary-search-tree"><a href="#二叉搜索树-Binary-search-tree" class="headerlink" title="二叉搜索树(Binary search tree)"></a>二叉搜索树(Binary search tree)</h2><p><strong>二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li><li>任意节点的左、右子树也分别为二叉查找树</li><li>没有键值相等的节点</li></ol><p><img src="225px-Binary_search_tree.svg.png" alt="bst"></p><p>空间复杂度：O(<em>n</em>)。</p><p>时间复杂度：</p><div class="table-container"><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">平均</th><th style="text-align:center">最差</th></tr></thead><tbody><tr><td style="text-align:center">搜索</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(log <em>n</em>)</td><td style="text-align:center">O(<em>n</em>)</td></tr></tbody></table></div><h3 id="二叉搜索树的建立"><a href="#二叉搜索树的建立" class="headerlink" title="二叉搜索树的建立"></a>二叉搜索树的建立</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li>若b是空树，则将<code>node</code>所指节点作为根节点插入，否则：</li><li>若<code>node.val</code>等于b的根节点的数据域之值，则返回，否则：</li><li>若<code>node.val</code>小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li><li>把<code>node</code>所指节点插入到右子树中</li></ol><p>新插入节点总是叶子节点，所以数字组成相同但是排序不同的序列所构造的二叉搜索树其实是不同的。但是序列化（见后文）的结果是一致的。</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树</li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/pythonchang-gui-jie-fa-by-lil-q/" target="_blank" rel="noopener">自己做leetcode 450时的解法</a>，非递归，算法有些复杂。</p><pre><code class="lang-python">class Solution:    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:        # 删除节点返回新的子树            def delete(node):            # 没有子节点，返回None            if not node.left and not node.right:return None            # 没有左子节点，返回右子节点            elif not node.left:return node.right            # 没有右子节点，返回左子节点            elif not node.right:return node.left            # 待删除节点度为2，详细讨论            else:                # 左子节点没有右子节点                if not node.left.right:                    node.left.right=node.right                    return node.left                # 右子节点没有左子节点                elif not node.left.right:                    node.left.right=node.right                    return node.left                 # 都不满足，返回左子树最大值                else:                    # 记录父节点pre                    pre=left=node.left                    while left.right:                        pre=left                        left=left.right                    # 保存待最大值的左子树到父节点的右子树                    pre.right=left.left                    left.left=node.left                    left.right=node.right                    return left        if not root:return root                if root.val==key:            root=delete(root)            return root        father=node=root        while node.val!=key:            if node.val&gt;key:                father=node                node=node.left            else:                father=node                node=node.right            if not node:return root        if father.left==node:father.left=delete(node)        else: father.right=delete(node)        return root</code></pre><p>这里给出递归的方式。递归的好处在于不用考虑寻找父节点以及待删除结点到底是父节点的左子节点还是右子节点。</p><p>在二叉查找树删去一个结点，分三种情况讨论：</p><ol><li>若待删除结点p为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li><li>若待删除结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉查找树的特性。</li><li>若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；其二是令p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。</li></ol><p><img src="720px-Binary_search_tree_delete.svg.png" alt="deletenode"></p><h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><pre><code class="lang-python">class BinarySearchTree:    # 初始化    def __init__(self, value):        self.val = value        self.left=None        self.right=None    # 查找最小值    def find_min(self):        current = self        while current.left:            current = current.left        return current       # 查找最大值    def find_max(self):        current = self        while current.right:            current = current.right        return current       # 插入一个节点    def insert(self, value):        node = BinarySearchTree(value)        current = self        while True:            if value &lt; current.val:                if current.left is None:                    current.left = node                    return                 current = current.left            elif value &gt; current.val:                if current.right is None:                    current.right = node                    return                 current = current.right            else: return self    # 查找节点    def find(self, value):        current = self        while current:            if current.val == value:                return current            current = current.left if value &lt; current.val else current.right        # 此时current==None        return current    # 删除节点    def delete(self,value):        if self.find(value):            if value&lt;self.val:                self.left=self.left.delete(value)                return self            elif value&gt;self.val:                self.right=self.right.delete(value)                return self            elif self.left and self.right:                val=self.right.findMin().val                self.val=val                self.right=self.right.delete(val)                return self            else:                if self.left:                    return self.left                else:                    return self.right        else:            return self</code></pre><p><em>注：代码中没有考虑空树。</em></p><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树(Trie)"></a>字典树(Trie)</h2><p>Trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><pre><code class="lang-python">class Trie:    # 初始化    def __init__(self):        self.lookup = {}    def insert(self, word):        tree = self.lookup        for a in word:            if a not in tree:                tree[a] = {}            tree = tree[a]        # 单词结束标志        tree[&quot;#&quot;] = &quot;#&quot;    def search(self, word):        tree = self.lookup        for a in word:            if a not in tree:                return False            tree = tree[a]        if &quot;#&quot; in tree:            return True        return False      def startsWith(self, prefix):        tree = self.lookup        for a in prefix:            if a not in tree:                return False            tree = tree[a]        return True</code></pre><h2 id="B树-B-tree-和B-树-B-tree"><a href="#B树-B-tree-和B-树-B-tree" class="headerlink" title="B树(B-tree)和B+树(B+ tree)"></a>B树(B-tree)和B+树(B+ tree)</h2><p><strong>B树</strong>（B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</p><p>请参考<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">这篇文章</a></p><h2 id="AVL树-AVL-tree"><a href="#AVL树-AVL-tree" class="headerlink" title="AVL树(AVL tree)"></a>AVL树(AVL tree)</h2><p><strong>AVL树</strong>是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。</p><p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p><h2 id="黑红树-Red–black-tree"><a href="#黑红树-Red–black-tree" class="headerlink" title="黑红树(Red–black tree)"></a>黑红树(Red–black tree)</h2><p><strong>红黑树</strong>是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>下面是一个具体的红黑树的图例：</p><p><img src="675px-Red-black_tree_example.svg.png" alt="rbt"></p><p>操作有变色，左旋，右旋。</p><h2 id="树堆-treap"><a href="#树堆-treap" class="headerlink" title="树堆(treap)"></a>树堆(treap)</h2><p><strong>树堆</strong>（Treap）是二叉排序树（Binary Sort Tree）与堆（Heap）结合产生的一种拥有堆性质的二叉排序树。</p><p>但是这里要注意两点，第一点是Treap和二叉堆有一点不同，就是二叉堆必须是完全二叉树，而Treap并不一定是；第二点是Treap并不严格满足平衡二叉排序树（AVL树）的要求，即树堆中每个节点的左右子树高度之差的绝对值可能会超过1，只是近似满足平衡二叉排序树的性质。</p><p>Treap每个节点记录两个数据，一个是键值，一个是随机附加的优先级，Treap在以关键码构成二叉排序树的同时，又以结点优先级形成最大堆和最小堆。所以Treap必须满足这两个性质，一是二叉排序树的性质，二是堆的性质。如下图，即为一个树堆。</p><p><img src="330px-TreapAlphaKey.svg.png" alt="treap"></p><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Tree" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)</a>)</li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-he-di-gui-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-he-di-gui-by-powcai/</a></li><li><a href="https://zhuanlan.zhihu.com/p/26418233" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26418233</a></li><li><a href="https://python123.io/index/topics/data_structure/binary_tree" target="_blank" rel="noopener">https://python123.io/index/topics/data_structure/binary_tree</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/pythonjian-dan-shi-xian-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/pythonjian-dan-shi-xian-by-powcai/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治算法(Divide-and-conquer algorithm)</title>
    <link href="/2019/11/18/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2019/11/18/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>看见O(log n)时间复杂度就想到了分治算法</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换) 。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，<strong>子问题之间没有相关性</strong>，这一点是分治算法跟动态规划的明显<a href="https://zhuanlan.zhihu.com/p/33048876" target="_blank" rel="noopener">区别</a>；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. <a href="https://lil-q.github.io/2019/11/16/排序-Sort-算法/">归并排序</a></h3><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. <a href="https://lil-q.github.io/2019/11/16/排序-Sort-算法/">快速排序</a></h3><h3 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3. 二分查找"></a>3. 二分查找</h3><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。</p><pre><code class="lang-python">def extreme_insertion_index(self, nums, target, left):     &#39;&#39;&#39;    left是一个布尔值，用来决定target==nums[mid]情况下的选择：求左边界时，hi=mid，区间往左走；求右边界时，lo=mid+1，区间往右走。    &#39;&#39;&#39;    lo = 0    hi = len(nums)    while lo &lt; hi:        mid = (lo + hi) // 2        if nums[mid] &gt; target or (left and target == nums[mid]):            hi = mid        else:            lo = mid+1    return lodef searchRange(self, nums, target):    left_idx = self.extreme_insertion_index(nums, target, True)    if left_idx == len(nums) or nums[left_idx] != target:        return [-1, -1]    return [left_idx, self.extreme_insertion_index(nums, target, False)-1]</code></pre><p>上面<code>extreme_insertion_index()</code>的代码是采用左闭右开的区间，也可以改写成以下闭区间的写法：</p><pre><code class="lang-python">def extreme_insertion_index(self, nums, target, left):      lo = 0    hi = len(nums)-1 # 闭区间    while lo &lt;= hi: # 加入=，防止hi-lo=1时漏判        mid = (lo + hi) // 2        if nums[mid] &gt; target or (left and target == nums[mid]):            hi = mid+1 # 需要加一，防止陷入死循环        else:            lo = mid+1    return lo</code></pre><h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h3><p> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">leetcode 105. 从前序与中序遍历序列构造二叉树</a></p><p>根据一棵树的前序遍历与中序遍历构造二叉树（假设树中没有重复的元素）。</p><p>例如，给出</p><pre><code class="lang-python">前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>由于是树，我们很容易意识到左子树和右子树就是两个子问题。对于一个子问题，我们只需要找到根节点，连接左子树，连接右子树。</p><pre><code class="lang-python">class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder: return None        root = TreeNode(preorder[0])        mid = inorder.index(preorder[0])        root.left = self.buildTree(preorder[1:mid + 1], inorder[:mid])        root.right = self.buildTree(preorder[mid + 1:], inorder[mid + 1:])        return root</code></pre><p>官方给出的方法更好，不需要反复传入<code>list</code>并且用<code>dict</code>代替了<code>list.index()</code>：</p><pre><code class="lang-python">class Solution:    def buildTree(self, preorder, inorder):        &quot;&quot;&quot;        :type preorder: List[int]        :type inorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        def helper(in_left = 0, in_right = len(inorder)):            nonlocal pre_idx            # if there is no elements to construct subtrees            if in_left == in_right:                return None            # pick up pre_idx element as a root            root_val = preorder[pre_idx]            root = TreeNode(root_val)            # root splits inorder list            # into left and right subtrees            index = idx_map[root_val]            # recursion             pre_idx += 1            # build left subtree            root.left = helper(in_left, index)            # build right subtree            root.right = helper(index + 1, in_right)            return root        # start from first preorder element        pre_idx = 0        # build a hashmap value -&gt; its index        idx_map = {val:idx for idx, val in enumerate(inorder)}         return helper()</code></pre><p>给出c++版本:</p><pre><code class="lang-c++">class Solution {public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {        int pos = 0;        return buildTree(preorder, pos, inorder, 0, preorder.size() - 1);    }    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int&amp; pos, vector&lt;int&gt;&amp;inorder, int left, int right){        if(pos &gt;= preorder.size()){            return 0;        }        int i = left;        for(i = left; i &lt;= right; i++){            if(inorder[i] == preorder[pos]){                break;            }        }        TreeNode* node = new TreeNode(preorder[pos]);        if (left &lt; i){node-&gt;left = buildTree(preorder, ++pos, inorder, left, i - 1);}        if (i &lt; right){node-&gt;right = buildTree(preorder, ++pos, inorder, i + 1, right);}        return node;      }};</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/分治法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95</a> </li><li><a href="https://hotttao.github.io/2018/11/05/alog/divide/" target="_blank" rel="noopener">https://hotttao.github.io/2018/11/05/alog/divide/</a> </li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>分治</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆(Heap)</title>
    <link href="/2019/11/17/%E5%A0%86-heap/"/>
    <url>/2019/11/17/%E5%A0%86-heap/</url>
    
    <content type="html"><![CDATA[<p>经过努力，最值总会冒上来的！</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>在通常情况下，使用列表储存堆，堆树是一颗<a href="https://www.zhihu.com/question/36134980/answer/87490177" target="_blank" rel="noopener">完全二叉树</a>，二项堆和斐波那契堆不属于二叉树 </li><li>堆树中某个节点的值总是不大于或不小于其孩子节点的值 </li><li>堆树中每个节点的子树都是堆树 </li></ol><p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 本文以最大堆作为例子，最小堆类似。</p><h2 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h2><p>堆的建立并不建立一个新的树，而是对数组进行原地改动，第一个数（index=0）为完全二叉树的level 0，即根，第二个数和第三个数为level 1，以此类推。</p><p><img src="建堆.png" alt="建堆"></p><p>由于数组是升序数组，我们直接得到了最小堆。但是如果要进行升序排序，算法上需要建立最大堆。也就是说，当原数组是升序时，堆排序算法遇到了最坏情况。本文也以这种情况作为例子。</p><pre><code class="lang-python">nums=[1,2,3,4,5]</code></pre><h3 id="堆的维护"><a href="#堆的维护" class="headerlink" title="堆的维护"></a>堆的维护</h3><p>上图的根节点是1，小于子节点，那么这显然违反了最大堆的性质，这时候需要让该元素在最大堆中逐级下降，维护最大堆的性质。处理一次维护的代码如下：</p><pre><code class="lang-python">def adjust_heap(idx, max_len,nums):    left = 2 * idx + 1    right = 2 * idx + 2    max_loc = idx    if left &lt; max_len and nums[max_loc] &lt; nums[left]:        max_loc = left    if right &lt; max_len and nums[max_loc] &lt; nums[right]:        max_loc = right    if max_loc != idx:        nums[idx], nums[max_loc] = nums[max_loc], nums[idx]        adjust_heap(max_loc, max_len,nums)</code></pre><h3 id="建立最大堆"><a href="#建立最大堆" class="headerlink" title="建立最大堆"></a>建立最大堆</h3><ol><li>自底向上处理， 因为数组<code>list[n//2,n]</code>中的所有元素都在堆树的叶节点中，因此可以看成只包含一个元素的堆， 无需维护。其中<code>n=len(list)</code>；</li><li>从<code>index=n//2-1</code>开始，直到<code>index=0</code>，对每一个节点或根进行一次维护。</li></ol><p><em>注意：一次维护并不是最多只交换一次，而是交换到某节点满足最大堆条件或者<code>index&gt;=n</code>为止。</em></p><p><img src="heapflow.png" alt="heapflow"></p><pre><code class="lang-python">def build_heap(nums):        n = len(nums)    for i in range(n // 2 - 1, -1, -1):        adjust_heap(i, n,nums)    return numsheap=build_heap(nums)print(&quot;heap:&quot;,heap)#输出：heap: [5, 4, 3, 1, 2]</code></pre><h2 id="最大堆中插入节点"><a href="#最大堆中插入节点" class="headerlink" title="最大堆中插入节点"></a>最大堆中插入节点</h2><p>最大堆的插入节点的思想就是先在堆的最后添加一个节点，也就是在<code>list.append()</code>，然后沿着堆树上升。跟最大堆的初始建立过程大致相同。 </p><pre><code class="lang-python">def heap_insert(heap,num):    heap=heap+[num]    n=len(heap)    i=n-1    while i&gt;0 and heap[(i-1)//2]&lt;num:        heap[i]=heap[(i-1)//2]        i=(i-1)//2    heap[i]=num    return heapheap=heap_insert(heap,6)print(&quot;heapIns:&quot;,heap)#输出：heapIns: [6, 4, 5, 1, 2, 3]</code></pre><p><img src="heapinsert.png" alt="charu"></p><h2 id="最大堆节点的删除"><a href="#最大堆节点的删除" class="headerlink" title="最大堆节点的删除"></a>最大堆节点的删除</h2><p>对一个节点的删除就是交换该节点和最后一个叶子节点的值，然后从该节点开始一次<code>adjust_heap()</code>：</p><pre><code class="lang-python">def heap_delete(heap,idx):    n=len(heap)    heap[idx],heap[-1]=heap[-1],heap[idx]    adjust_heap(idx, n - 1,heap)    heap.pop()    return heapheap=heap_delete(heap,0)print(&quot;heapDel:&quot;,heap)#输出：heapDel: [5, 4, 3, 1, 2]</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>特殊地，当我们交换根和最后一个叶子节点时，就能够提出最大值，并且存放在<code>index=-1</code>的位置。然后再对前n-1个数组成的最大堆进行该处理，以此类推，最终完成堆排序。</p><pre><code class="lang-python">def heap_sorted(heap):    for i in range(1, len(heap)):        heap[0], heap[-i] = heap[-i], heap[0]        adjust_heap(0, n - i,heap)    return heapheapSort=heap_sorted(heap)print(&quot;heapSort:&quot;,heapSort)#输出：heapSort: [1, 2, 3, 4, 5]</code></pre><p><a href="https://github.com/lil-q/data-structures-python/tree/master/Heap" target="_blank" rel="noopener">完整测试代码地址</a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/pai-xu-by-powcai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/pai-xu-by-powcai-2/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法(Sorting algorithm)</title>
    <link href="/2019/11/16/%E6%8E%92%E5%BA%8F-Sort-%E7%AE%97%E6%B3%95/"/>
    <url>/2019/11/16/%E6%8E%92%E5%BA%8F-Sort-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>十种排序算法的python实现及复杂度分析</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>评价排序算法的几个指标：</p><ul><li><strong>时间复杂度</strong>：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是<script type="math/tex">O(nlog_2n)</script>，坏的性能是<script type="math/tex">O(n^2)</script>。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要<script type="math/tex">O(nlog_2n)</script>。</li><li><strong>空间复杂度</strong>：内存使用量</li><li><strong>稳定性</strong>： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是<strong>稳定</strong>的，当有两个相等键值的纪录<strong>R</strong>和<strong>S</strong>，且在原本的列表中<strong>R</strong>出现在<strong>S</strong>之前，在排序过的列表中<strong>R</strong>也将会是在<strong>S</strong>之前。</li><li><strong>依据排序的方法</strong>：插入、交换、选择、合并等等。  </li></ul><p>本文介绍了以下几种排序，推荐<strong>可视化网站<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo</a></strong>，下文代码都采用数组作为输入。</p><div class="table-container"><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(log_2n)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><script type="math/tex">O(n^{1.3})</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">O(n+k)</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><ul><li>均按从小到大排列 </li><li>k代表数值中的”数字”个数</li><li>n代表数据规模</li><li>m代表数据的最大值减最小值</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>数据分区：（无序区，有序区）。<br>从无序区透过交换找出最大元素放到有序区前端。 </p><p><img src="Bubble_sort_animation.gif" alt="冒泡排序"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="bubble_sort.gif" alt="冒泡流程"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bubble_sorted(nums):    size = len(nums)    for i in range(size-1):        for j in range(size-1-i):            if nums[j] &gt; nums[j+1]:                nums[j],nums[j+1]=nums[j+1],nums[j]    return nums</code></pre><p>但是，该算法的最优时间复杂度<a href="https://www.cnblogs.com/melon-h/archive/2012/09/20/2694941.html" target="_blank" rel="noopener">并不是O(n)，而是<script type="math/tex">O(n^2)</script></a>。需改写才能实现最优理想状态：</p><pre><code class="lang-python">def bubble_sorted(nums):    size = len(nums)    for i in range(size-1):        didSwap=False        for j in range(size-1-i):            if nums[j] &gt; nums[j+1]:                nums[j],nums[j+1]=nums[j+1],nums[j]                didSwap=True        if didSwap==False:            return    return nums</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数据分区：（有序区，无序区）。<br/>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 </p><p> <img src="Selection_sort_animation.gif" alt="选择排序"></p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ol><p><img src="selection_sort.gif" alt="选择流程"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def selection_sorted(nums):    size = len(nums)    for i in range(size-1):        min_index = i        for j in range(i, size):            if nums[j] &lt; nums[min_index]:               min_index = j        nums[i], nums[min_index] = nums[min_index], nums[i]    return nums</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>数据分区：（有序区，无序区）。<br/>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 </p><p><img src="Insertion_sort_animation.gif" alt="插入排序"></p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><p><img src="insertion_sort.gif" alt="插入流程"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def insertion_sorted(nums):    size = len(nums)    for i in range(1,size):        cur_num=nums[i]        pre_index=i-1        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:            nums[pre_index+1]=nums[pre_index]            pre_index-=1        nums[pre_index+1]=cur_num    return nums</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>数据分区：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。 <a href="https://lil-q.github.io/2019/11/17/%E5%A0%86-heap/">关于堆</a></p><p><img src="Sorting_heapsort_anim.gif" alt="heap"></p><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol><li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def heap_sorted(nums):    # 调整最大堆             def adjust_heap(idx, max_len):        left = 2 * idx + 1        right = 2 * idx + 2        max_loc = idx        if left &lt; max_len and nums[max_loc] &lt; nums[left]:            max_loc = left        if right &lt; max_len and nums[max_loc] &lt; nums[right]:            max_loc = right        if max_loc != idx:            nums[idx], nums[max_loc] = nums[max_loc], nums[idx]            adjust_heap(max_loc, max_len)      # 建堆    n = len(nums)    for i in range(n // 2 - 1, -1, -1):        adjust_heap(i, n)    # 排序    for i in range(1, n):        nums[0], nums[-i] = nums[-i], nums[0]        adjust_heap(0, n - i)    return nums</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  </p><p><img src="Merge_sort_animation2.gif" alt="merge"></p><h3 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h3><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><p><img src="merge_sort.gif" alt="mergef"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="递归法（Top-down）："><a href="#递归法（Top-down）：" class="headerlink" title="递归法（Top-down）："></a>递归法（Top-down）：</h4><pre><code class="lang-python">def merge(left, right):    result = []    while left and right:        if left[0] &lt;= right[0]:            result.append(left.pop(0))        else:            result.append(right.pop(0))    if left:        result += left    if right:        result += right    return resultdef merge_sort(L):    if len(L) &lt;= 1:        return L    mid = len(L) // 2    left = L[:mid]    right = L[mid:]    left = merge_sort(left)    right = merge_sort(right)    return merge(left, right)</code></pre><p>时间复杂度是O(nlogn)，归并的空间复杂度为临时的数组和递归时压入栈的数据占用的空间：n + logn，所以空间复杂度为: O(n)。<a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44223225" target="_blank" rel="noopener">参考</a> </p><h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>重写merge()，实现O(1)</p><pre><code class="lang-python">def merge_iter(nums,l1,l2,r2):    r1=l2-1    while r1&gt;=l1 and r2&gt;=l2:        if nums[r1]&gt;nums[r2]:            tmp=nums[r2] # 暂存较小值            nums[r2]=nums[r1]            tmp_r1=r1-1             # 将前半数组的大于tmp的值后移一个单位            while nums[tmp_r1]&gt;tmp and tmp_r1&gt;=l1:                 nums[tmp_r1+1]=nums[tmp_r1]                tmp_r1-=1            nums[tmp_r1+1]=tmp        r2-=1</code></pre><p>这里参考了<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">leetcode 88.合并两个有序数组</a>，采用双指针从后往前合并两个有序数组（其实也就是一个数组切片的前一半和后一半），实现了空间复杂度O(1)。</p><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/merge.jpg" alt="merge"></p><p><strong>方法一：使用生成器</strong></p><pre><code class="lang-python"># 生成器产生2的幂def powerOfTwo(max):    x=1    while x&lt;=max:        yield x        x*=2# 方法一：用生成器产生1，2，4，8...def merge_sorted_iter(nums):    sortedList=[]    n=len(nums)    for i in powerOfTwo(n):         for j in range(0,n,i*2):             merge_iter(nums,j,min(j+i,n-1),min(j+2*i-1,n-1))    return nums</code></pre><p><strong>方法二：使用位运算</strong></p><pre><code class="lang-python"># 方法二：用位操作产生1，2，4，8...def msi(nums):    length = len(nums)    step = 1    # 步长为1,2,4,8，...，一直合并下去    while step &lt;= length:        offset = step &lt;&lt; 1        for index in range(0, length, offset):            merge_iter(nums, index, min(index+step, length-1), min(index+offset-1, length-1))        step = offset</code></pre><p><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">时间复杂度是<script type="math/tex">O(nlog^2n)</script>,空间复杂度为: O(1)</a>。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>数据分区：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 </p><p><img src="Sorting_quicksort_anim.gif" alt="quick"></p><h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><img src="quick_sorted.gif" alt="quicks"></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">import randomdef quick_sorted(nums):    if len(nums) &lt;= 1:        return nums    left, right, mid = [], [], []    pivot = random.choice(nums)    for num in nums:        if num == pivot:            mid.append(num)        elif num &lt; pivot:            left.append(num)        else:            right.append(num)    return quick_sorted(left) + mid + quick_sorted(right)</code></pre><p>需要<script type="math/tex">{\Omega (n)}</script>的额外存储空间，也就跟归并排序一样不好。额外需要的存储空间，在实际实现时，也会极度影响速度和缓存的性能 。下面是原地排序的代码， <a href="[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#Python%E5%8E%9F%E5%9C%B0%E6%8E%92%E5%BA%8F%E7%89%88%E6%9C%AC](https://zh.wikipedia.org/wiki/快速排序#Python原地排序版本">平均可以达到<script type="math/tex">O(\log n)</script>的空间复杂度</a> )。 </p><pre><code class="lang-python">def quick_sorted_inp(nums, first, last):    if first &gt;= last:        return    mid_value = nums[first]    low = first    high = last    while low &lt; high:        while low &lt; high and nums[high] &gt;= mid_value:            high -= 1        nums[low] = nums[high]        while low &lt; high and nums[low] &lt; mid_value:            low += 1        nums[high] = nums[low]    nums[low] = mid_value    quick_sorted_inp(nums, first, low-1)    quick_sorted_inp(nums, low+1, last)</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><blockquote><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ol></blockquote><p><img src="Sorting_shellsort_anim.gif" alt="shell"></p><h3 id="流程-6"><a href="#流程-6" class="headerlink" title="流程"></a>流程</h3><ol><li>选择一个增量序列<script type="math/tex">t_1</script>，<script type="math/tex">t_2</script>，…，<script type="math/tex">t_k</script>，其中<script type="math/tex">t_i</script>&gt;<script type="math/tex">t_j</script>，<script type="math/tex">t_k</script>=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量<script type="math/tex">t_i</script>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def shell_sorted(nums):    n = len(nums)    # 初始步長，理论上只要最终步长为1任何步长序列都可以工作    gap = n // 2    while gap &gt; 0:        for i in range(gap, n):            # 每个步長進行插入排序            temp = nums[i]            j = i            # 插入排序            while j &gt;= gap and nums[j - gap] &gt; temp:                nums[j] = nums[j - gap]                j -= gap            nums[j] = temp        # 得到新的步長        gap = gap // 2    return nums</code></pre><p>实际上使用1，2，4，8…的增量序列有时会在gap=1时浪费很多时间，[Mark Allen Weiss]指出，最好的增量序列是 Sedgewick提出的 (1, 5, 19, 41, 109,…)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。<a href="https://blog.csdn.net/u013630349/article/details/48250109" target="_blank" rel="noopener">使用 Sedgewick增量 的希尔排序的完整C语言程序</a></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="流程-7"><a href="#流程-7" class="headerlink" title="流程"></a>流程</h3><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><p><img src="counting_sorted.gif" alt="countingsort"></p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def counting_sorted(nums):    # 计数排序针对非负整数，初始化最大值为-1，也可以设为nums[0]    maxValue=-1    for num in nums:        if num&gt;maxValue:            maxValue=num    bucket = [0]*(maxValue+1)    for num in nums:        bucket[num]+=1    index=0    for i in range(len(bucket)):        while bucket[i]&gt;0:            nums[index] = i            index+=1            bucket[i]-=1    return nums</code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="流程-8"><a href="#流程-8" class="headerlink" title="流程"></a>流程</h3><ol><li>取得数组中的最大数，并取得位数；</li><li>从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><p><img src="radix_sorted.gif" alt="radix"></p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def radix_sorted(nums):    # 基数排序针对非负整数，初始化最大值为-1,也可以设为nums[0]    maxValue=-1    for num in nums:        if num&gt;maxValue:            maxValue=num     # 求最高位数n    n=len(str(maxValue))    # 进行n次排序    for k in range(n):               s=[[] for i in range(10)]        for i in nums:            s[i//(10**k)%10].append(i)        nums=[a for b in s for a in b]    return nums</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="流程-9"><a href="#流程-9" class="headerlink" title="流程"></a>流程</h3><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol><p><img src="Bucket_sort_1.svg.png" alt="bucket1"></p><p><img src="Bucket_sort_2.svg.png" alt="bucket2"></p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bucket_sorted(nums):    if not nums:return nums    maxValue=nums[0]    minValue=nums[0]    for num in nums:        if num&gt;maxValue:            maxValue=num         elif num&lt;minValue:            minValue=num    # 将数据映射到桶中    bucketSize=100 # 设定桶的大小    bucketCount=(maxValue-minValue)//bucketSize+1 # 计算桶的数量    buckets=[[] for _ in range(bucketCount)]    for num in nums:        buckets[(num-minValue)//bucketSize].append(num)    # 对桶内排序，这里使用插入排序，也可以递归桶排序。    res=[]    for k in buckets:               res=res+insertion_sorted(k)    return res# 插入排序def insertion_sorted(nums):    size = len(nums)    for i in range(1,size):        cur_num=nums[i]        pre_index=i-1        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:            nums[pre_index+1]=nums[pre_index]            pre_index-=1        nums[pre_index+1]=cur_num    return nums</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桶排序、基数排序和计数排序都属于非比较类排序，其中计数排序和基数排序都用到了桶排序的思想。计数排序一共分了0，1，2…maxValue一共maxValue+1个桶，每个桶表示一个数；而基数排序则分了十个桶，从第一位开始递归桶排序。冒泡排序，选择排序，插入排序都是比较两个数然后交换。堆排序，归并排序，快速排序则是运用了分治的思想。</p><p><a href="https://github.com/lil-q/sorting-algorithm-python" target="_blank" rel="noopener"><strong>完整代码</strong></a></p><p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a> </li><li><a href="https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/数据结构与算法.md" target="_blank" rel="noopener">https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md</a> </li><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a> </li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
