<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>排序算法(Sorting algorithm) - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7744.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Saturday, November 16th 2019, 7:34 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    3.9k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      16 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          
          <div class="markdown-body">
            <p>十种排序算法的python实现及复杂度分析</p>
<a id="more"></a>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>评价排序算法的几个指标：</p>
<ul>
<li><strong>时间复杂度</strong>：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是<script type="math/tex">O(nlog_2n)</script>，坏的性能是<script type="math/tex">O(n^2)</script>。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要<script type="math/tex">O(nlog_2n)</script>。</li>
<li><strong>空间复杂度</strong>：内存使用量</li>
<li><strong>稳定性</strong>： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是<strong>稳定</strong>的，当有两个相等键值的纪录<strong>R</strong>和<strong>S</strong>，且在原本的列表中<strong>R</strong>出现在<strong>S</strong>之前，在排序过的列表中<strong>R</strong>也将会是在<strong>S</strong>之前。</li>
<li><strong>依据排序的方法</strong>：插入、交换、选择、合并等等。  </li>
</ul>
<p>本文介绍了以下几种排序，推荐<strong>可视化网站<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo</a></strong>，下文代码都采用数组作为输入。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(log_2n)</script></td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"><script type="math/tex">O(n^{1.3})</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>均按从小到大排列 </li>
<li>k代表数值中的”数字”个数</li>
<li>n代表数据规模</li>
<li>m代表数据的最大值减最小值</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>数据分区：（无序区，有序区）。<br>从无序区透过交换找出最大元素放到有序区前端。 </p>
<p><img src="Bubble_sort_animation.gif" srcset="/img/loading.gif" alt="冒泡排序"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="bubble_sort.gif" srcset="/img/loading.gif" alt="冒泡流程"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bubble_sorted(nums):
    size = len(nums)
    for i in range(size-1):
        for j in range(size-1-i):
            if nums[j] &gt; nums[j+1]:
                nums[j],nums[j+1]=nums[j+1],nums[j]
    return nums
</code></pre>
<p>但是，该算法的最优时间复杂度<a href="https://www.cnblogs.com/melon-h/archive/2012/09/20/2694941.html" target="_blank" rel="noopener">并不是O(n)，而是<script type="math/tex">O(n^2)</script></a>。需改写才能实现最优理想状态：</p>
<pre><code class="lang-python">def bubble_sorted(nums):
    size = len(nums)
    for i in range(size-1):
        didSwap=False
        for j in range(size-1-i):
            if nums[j] &gt; nums[j+1]:
                nums[j],nums[j+1]=nums[j+1],nums[j]
                didSwap=True
        if didSwap==False:
            return
    return nums
</code></pre>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数据分区：（有序区，无序区）。<br/>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 </p>
<p> <img src="Selection_sort_animation.gif" srcset="/img/loading.gif" alt="选择排序"></p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><img src="selection_sort.gif" srcset="/img/loading.gif" alt="选择流程"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def selection_sorted(nums):
    size = len(nums)
    for i in range(size-1):
        min_index = i
        for j in range(i, size):
            if nums[j] &lt; nums[min_index]:
               min_index = j
        nums[i], nums[min_index] = nums[min_index], nums[i]
    return nums
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>数据分区：（有序区，无序区）。<br/>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 </p>
<p><img src="Insertion_sort_animation.gif" srcset="/img/loading.gif" alt="插入排序"></p>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><img src="insertion_sort.gif" srcset="/img/loading.gif" alt="插入流程"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def insertion_sorted(nums):
    size = len(nums)
    for i in range(1,size):
        cur_num=nums[i]
        pre_index=i-1
        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:
            nums[pre_index+1]=nums[pre_index]
            pre_index-=1
        nums[pre_index+1]=cur_num
    return nums
</code></pre>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>数据分区：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。 <a href="https://lil-q.github.io/2019/11/17/%E5%A0%86-heap/">关于堆</a></p>
<p><img src="Sorting_heapsort_anim.gif" srcset="/img/loading.gif" alt="heap"></p>
<h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def heap_sorted(nums):
    # 调整最大堆         
    def adjust_heap(idx, max_len):
        left = 2 * idx + 1
        right = 2 * idx + 2
        max_loc = idx
        if left &lt; max_len and nums[max_loc] &lt; nums[left]:
            max_loc = left
        if right &lt; max_len and nums[max_loc] &lt; nums[right]:
            max_loc = right
        if max_loc != idx:
            nums[idx], nums[max_loc] = nums[max_loc], nums[idx]
            adjust_heap(max_loc, max_len)  
    # 建堆
    n = len(nums)
    for i in range(n // 2 - 1, -1, -1):
        adjust_heap(i, n)
    # 排序
    for i in range(1, n):
        nums[0], nums[-i] = nums[-i], nums[0]
        adjust_heap(0, n - i)
    return nums
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  </p>
<p><img src="Merge_sort_animation2.gif" srcset="/img/loading.gif" alt="merge"></p>
<h3 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h3><ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<p><img src="merge_sort.gif" srcset="/img/loading.gif" alt="mergef"></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="递归法（Top-down）："><a href="#递归法（Top-down）：" class="headerlink" title="递归法（Top-down）："></a>递归法（Top-down）：</h4><pre><code class="lang-python">def merge(left, right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    if left:
        result += left
    if right:
        result += right
    return result

def merge_sort(L):
    if len(L) &lt;= 1:
        return L
    mid = len(L) // 2
    left = L[:mid]
    right = L[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)
</code></pre>
<p><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44223225" target="_blank" rel="noopener">时间复杂度是O(nlogn)，归并的空间复杂度为临时的数组和递归时压入栈的数据占用的空间：n + logn，所以空间复杂度为: O(n)</a> 。</p>
<h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>重写merge()，实现O(1)</p>
<pre><code class="lang-python">def merge_iter(nums,l1,l2,r2):
    r1=l2-1
    while r1&gt;=l1 and r2&gt;=l2:
        if nums[r1]&gt;nums[r2]:
            tmp=nums[r2] # 暂存较小值
            nums[r2]=nums[r1]
            tmp_r1=r1-1
             # 将前半数组的大于tmp的值后移一个单位
            while nums[tmp_r1]&gt;tmp and tmp_r1&gt;=l1: 
                nums[tmp_r1+1]=nums[tmp_r1]
                tmp_r1-=1
            nums[tmp_r1+1]=tmp
        r2-=1
</code></pre>
<p>这里参考了<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">leetcode 88.合并两个有序数组</a>，采用双指针从后往前合并两个有序数组（其实也就是一个数组切片的前一半和后一半），实现了空间复杂度O(1)。</p>
<p><img src="merge.jpg" srcset="/img/loading.gif" alt="merge"></p>
<p><strong>方法一：使用生成器</strong></p>
<pre><code class="lang-python"># 生成器产生2的幂
def powerOfTwo(max):
    x=1
    while x&lt;=max:
        yield x
        x*=2
# 方法一：用生成器产生1，2，4，8...
def merge_sorted_iter(nums):
    sortedList=[]
    n=len(nums)
    for i in powerOfTwo(n):
         for j in range(0,n,i*2):
             merge_iter(nums,j,min(j+i,n-1),min(j+2*i-1,n-1))
    return nums
</code></pre>
<p><strong>方法二：使用位运算</strong></p>
<pre><code class="lang-python"># 方法二：用位操作产生1，2，4，8...
def msi(nums):
    length = len(nums)
    step = 1
    # 步长为1,2,4,8，...，一直合并下去
    while step &lt;= length:
        offset = step &lt;&lt; 1
        for index in range(0, length, offset):
            merge_iter(nums, index, min(index+step, length-1), min(index+offset-1, length-1))
        step = offset
</code></pre>
<p><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">时间复杂度是<script type="math/tex">O(nlog^2n)</script>,空间复杂度为: O(1)</a>。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>数据分区：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 </p>
<p><img src="Sorting_quicksort_anim.gif" srcset="/img/loading.gif" alt="quick"></p>
<h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p><img src="quick_sorted.gif" srcset="/img/loading.gif" alt="quicks"></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">import random
def quick_sorted(nums):
    if len(nums) &lt;= 1:
        return nums
    left, right, mid = [], [], []
    pivot = random.choice(nums)
    for num in nums:
        if num == pivot:
            mid.append(num)
        elif num &lt; pivot:
            left.append(num)
        else:
            right.append(num)
    return quick_sorted(left) + mid + quick_sorted(right)
</code></pre>
<p>需要<script type="math/tex">{\Omega (n)}</script>的额外存储空间，也就跟归并排序一样不好。额外需要的存储空间，在实际实现时，也会极度影响速度和缓存的性能 。下面是原地排序的代码， <a href="[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#Python%E5%8E%9F%E5%9C%B0%E6%8E%92%E5%BA%8F%E7%89%88%E6%9C%AC](https://zh.wikipedia.org/wiki/快速排序#Python原地排序版本">平均可以达到<script type="math/tex">O(\log n)</script>的空间复杂度</a> )。 </p>
<pre><code class="lang-python">def quick_sorted_inp(nums, first, last):
    if first &gt;= last:
        return
    mid_value = nums[first]
    low = first
    high = last
    while low &lt; high:
        while low &lt; high and nums[high] &gt;= mid_value:
            high -= 1
        nums[low] = nums[high]
        while low &lt; high and nums[low] &lt; mid_value:
            low += 1
        nums[high] = nums[low]
    nums[low] = mid_value
    quick_sorted_inp(nums, first, low-1)
    quick_sorted_inp(nums, low+1, last)
</code></pre>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<blockquote>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
</blockquote>
<p><img src="Sorting_shellsort_anim.gif" srcset="/img/loading.gif" alt="shell"></p>
<h3 id="流程-6"><a href="#流程-6" class="headerlink" title="流程"></a>流程</h3><ol>
<li>选择一个增量序列<script type="math/tex">t_1</script>，<script type="math/tex">t_2</script>，…，<script type="math/tex">t_k</script>，其中<script type="math/tex">t_i</script>&gt;<script type="math/tex">t_j</script>，<script type="math/tex">t_k</script>=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量<script type="math/tex">t_i</script>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def shell_sorted(nums):
    n = len(nums)
    # 初始步長，理论上只要最终步长为1任何步长序列都可以工作
    gap = n // 2
    while gap &gt; 0:
        for i in range(gap, n):
            # 每个步長進行插入排序
            temp = nums[i]
            j = i
            # 插入排序
            while j &gt;= gap and nums[j - gap] &gt; temp:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = temp
        # 得到新的步長
        gap = gap // 2
    return nums
</code></pre>
<p>实际上使用1，2，4，8…的增量序列有时会在gap=1时浪费很多时间，[Mark Allen Weiss]指出，最好的增量序列是 Sedgewick提出的 (1, 5, 19, 41, 109,…)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。<a href="https://blog.csdn.net/u013630349/article/details/48250109" target="_blank" rel="noopener">使用 Sedgewick增量 的希尔排序的完整C语言程序</a></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h3 id="流程-7"><a href="#流程-7" class="headerlink" title="流程"></a>流程</h3><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<p><img src="counting_sorted.gif" srcset="/img/loading.gif" alt="countingsort"></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def counting_sorted(nums):
    # 计数排序针对非负整数，初始化最大值为-1，也可以设为nums[0]
    maxValue=-1
    for num in nums:
        if num&gt;maxValue:
            maxValue=num
    bucket = [0]*(maxValue+1)
    for num in nums:
        bucket[num]+=1
    index=0
    for i in range(len(bucket)):
        while bucket[i]&gt;0:
            nums[index] = i
            index+=1
            bucket[i]-=1
    return nums
</code></pre>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h3 id="流程-8"><a href="#流程-8" class="headerlink" title="流程"></a>流程</h3><ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<p><img src="radix_sorted.gif" srcset="/img/loading.gif" alt="radix"></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def radix_sorted(nums):
    # 基数排序针对非负整数，初始化最大值为-1,也可以设为nums[0]
    maxValue=-1
    for num in nums:
        if num&gt;maxValue:
            maxValue=num 
    # 求最高位数n
    n=len(str(maxValue))
    # 进行n次排序
    for k in range(n):       
        s=[[] for i in range(10)]
        for i in nums:
            s[i//(10**k)%10].append(i)
        nums=[a for b in s for a in b]
    return nums
</code></pre>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="流程-9"><a href="#流程-9" class="headerlink" title="流程"></a>流程</h3><ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="Bucket_sort_1.svg.png" srcset="/img/loading.gif" alt="bucket1"></p>
<p><img src="Bucket_sort_2.svg.png" srcset="/img/loading.gif" alt="bucket2"></p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-python">def bucket_sorted(nums):
    if not nums:return nums
    maxValue=nums[0]
    minValue=nums[0]
    for num in nums:
        if num&gt;maxValue:
            maxValue=num 
        elif num&lt;minValue:
            minValue=num
    # 将数据映射到桶中
    bucketSize=100 # 设定桶的大小
    bucketCount=(maxValue-minValue)//bucketSize+1 # 计算桶的数量
    buckets=[[] for _ in range(bucketCount)]
    for num in nums:
        buckets[(num-minValue)//bucketSize].append(num)
    # 对桶内排序，这里使用插入排序，也可以递归桶排序。
    res=[]
    for k in buckets:       
        res=res+insertion_sorted(k)
    return res
# 插入排序
def insertion_sorted(nums):
    size = len(nums)
    for i in range(1,size):
        cur_num=nums[i]
        pre_index=i-1

        while nums[pre_index]&gt;cur_num and pre_index&gt;=0:
            nums[pre_index+1]=nums[pre_index]
            pre_index-=1
        nums[pre_index+1]=cur_num
    return nums
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桶排序、基数排序和计数排序都属于非比较类排序，其中计数排序和基数排序都用到了桶排序的思想。计数排序一共分了0，1，2…maxValue一共maxValue+1个桶，每个桶表示一个数；而基数排序则分了十个桶，从第一位开始递归桶排序。冒泡排序，选择排序，插入排序都是比较两个数然后交换。堆排序，归并排序，快速排序则是运用了分治的思想。</p>
<p><a href="https://github.com/lil-q/sorting-algorithm-python" target="_blank" rel="noopener"><strong>完整代码</strong></a></p>
<p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a> </li>
<li><a href="https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/数据结构与算法.md" target="_blank" rel="noopener">https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md</a> </li>
<li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a> </li>
</ol>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
              
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/python/">python</a>
                
                  <a class="hover-with-bg" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>
      </div>
    
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="vcomments" style="width: 90%; margin: 0 auto;"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/Valine.min.js"></script>

  <script>
    var notify = 'false' === 'true';
    var verify = 'false' === 'true';
    var oldLoad = window.onload;
    window.onload = function () {
      new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
        app_key: "wqRfy95wLQRm4b7BByawaNCK",
        placeholder: "喂？",
        avatar: "/retro",
        meta: ['nick', 'mail', 'link'],
        pageSize: "10",
      });
      oldLoad && oldLoad();
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>



    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>

    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    <!-- cnzz Analytics icon -->
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var main = $('main');
      var tocT = navHeight + (toc.offset().top - main.offset().top);
      var tocLimMin = main.offset().top - navHeight;
      var tocLimMax = $('#comments').offset().top - navHeight;
      $(window).scroll(function () {
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;
        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': tocT,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "排序算法(Sorting algorithm)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
