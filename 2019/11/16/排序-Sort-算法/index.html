<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#111">
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>排序算法(Sorting algorithm) - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


  <script  src="/js/utils.js" ></script>
</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/usbizhi.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-11-16 19:34">
      November 16, 2019 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      50
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>十种排序算法的python实现及复杂度分析</p>
<a id="more"></a>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>评价排序算法的几个指标：</p>
<ul>
<li><strong>时间复杂度</strong>：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是<script type="math/tex">O(nlog_2n)</script>，坏的性能是<script type="math/tex">O(n^2)</script>。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要<script type="math/tex">O(nlog_2n)</script>。</li>
<li><strong>空间复杂度</strong>：内存使用量</li>
<li><strong>稳定性</strong>： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是<strong>稳定</strong>的，当有两个相等键值的纪录<strong>R</strong>和<strong>S</strong>，且在原本的列表中<strong>R</strong>出现在<strong>S</strong>之前，在排序过的列表中<strong>R</strong>也将会是在<strong>S</strong>之前。</li>
<li><strong>依据排序的方法</strong>：插入、交换、选择、合并等等。  </li>
</ul>
<p>本文介绍了以下几种排序，推荐<strong>可视化网站<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo</a></strong>，下文代码都采用数组作为输入。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td>
<td style="text-align:center"><script type="math/tex">O(log_2n)</script></td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"><script type="math/tex">O(n^{1.3})</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n*k)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>均按从小到大排列 </li>
<li>k代表数值中的”数字”个数</li>
<li>n代表数据规模</li>
<li>m代表数据的最大值减最小值</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>数据分区：（无序区，有序区）。<br>从无序区透过交换找出最大元素放到有序区前端。 </p>
<p><img src="Bubble_sort_animation.gif" srcset="/img/loading.gif" alt="冒泡排序"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="bubble_sort.gif" srcset="/img/loading.gif" alt="冒泡流程"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sorted</span><span class="hljs-params">(nums)</span>:</span>
    size = len(nums)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(size<span class="hljs-number">-1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(size<span class="hljs-number">-1</span>-i):
            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>]:
                nums[j],nums[j+<span class="hljs-number">1</span>]=nums[j+<span class="hljs-number">1</span>],nums[j]
    <span class="hljs-keyword">return</span> nums</code></pre></div>
<p>但是，该算法的最优时间复杂度<a href="https://www.cnblogs.com/melon-h/archive/2012/09/20/2694941.html" target="_blank" rel="noopener">并不是O(n)，而是<script type="math/tex">O(n^2)</script></a>。需改写才能实现最优理想状态：</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sorted</span><span class="hljs-params">(nums)</span>:</span>
    size = len(nums)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(size<span class="hljs-number">-1</span>):
        didSwap=<span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(size<span class="hljs-number">-1</span>-i):
            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>]:
                nums[j],nums[j+<span class="hljs-number">1</span>]=nums[j+<span class="hljs-number">1</span>],nums[j]
                didSwap=<span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> didSwap==<span class="hljs-literal">False</span>:
            <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数据分区：（有序区，无序区）。<br/>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 </p>
<p> <img src="Selection_sort_animation.gif" srcset="/img/loading.gif" alt="选择排序"></p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><img src="selection_sort.gif" srcset="/img/loading.gif" alt="选择流程"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sorted</span><span class="hljs-params">(nums)</span>:</span>
    size = len(nums)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(size<span class="hljs-number">-1</span>):
        min_index = i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, size):
            <span class="hljs-keyword">if</span> nums[j] &lt; nums[min_index]:
               min_index = j
        nums[i], nums[min_index] = nums[min_index], nums[i]
    <span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>数据分区：（有序区，无序区）。<br/>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 </p>
<p><img src="Insertion_sort_animation.gif" srcset="/img/loading.gif" alt="插入排序"></p>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><img src="insertion_sort.gif" srcset="/img/loading.gif" alt="插入流程"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_sorted</span><span class="hljs-params">(nums)</span>:</span>
	size = len(nums)
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,size):
		cur_num=nums[i]
		pre_index=i<span class="hljs-number">-1</span>
		<span class="hljs-keyword">while</span> nums[pre_index]&gt;cur_num <span class="hljs-keyword">and</span> pre_index&gt;=<span class="hljs-number">0</span>:
			nums[pre_index+<span class="hljs-number">1</span>]=nums[pre_index]
			pre_index-=<span class="hljs-number">1</span>
		nums[pre_index+<span class="hljs-number">1</span>]=cur_num
	<span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>数据分区：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。 <a href="https://lil-q.github.io/2019/11/17/%E5%A0%86-heap/">关于堆</a></p>
<p><img src="Sorting_heapsort_anim.gif" srcset="/img/loading.gif" alt="heap"></p>
<h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_sorted</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># 调整最大堆         </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adjust_heap</span><span class="hljs-params">(idx, max_len)</span>:</span>
        left = <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>
        right = <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>
        max_loc = idx
        <span class="hljs-keyword">if</span> left &lt; max_len <span class="hljs-keyword">and</span> nums[max_loc] &lt; nums[left]:
            max_loc = left
        <span class="hljs-keyword">if</span> right &lt; max_len <span class="hljs-keyword">and</span> nums[max_loc] &lt; nums[right]:
            max_loc = right
        <span class="hljs-keyword">if</span> max_loc != idx:
            nums[idx], nums[max_loc] = nums[max_loc], nums[idx]
            adjust_heap(max_loc, max_len)  
    <span class="hljs-comment"># 建堆</span>
    n = len(nums)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):
        adjust_heap(i, n)
    <span class="hljs-comment"># 排序</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
        nums[<span class="hljs-number">0</span>], nums[-i] = nums[-i], nums[<span class="hljs-number">0</span>]
        adjust_heap(<span class="hljs-number">0</span>, n - i)
    <span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  </p>
<p><img src="Merge_sort_animation2.gif" srcset="/img/loading.gif" alt="merge"></p>
<h3 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h3><ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<p><img src="merge_sort.gif" srcset="/img/loading.gif" alt="mergef"></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="递归法（Top-down）："><a href="#递归法（Top-down）：" class="headerlink" title="递归法（Top-down）："></a>递归法（Top-down）：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span>:</span>
    result = []
    <span class="hljs-keyword">while</span> left <span class="hljs-keyword">and</span> right:
        <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]:
            result.append(left.pop(<span class="hljs-number">0</span>))
        <span class="hljs-keyword">else</span>:
            result.append(right.pop(<span class="hljs-number">0</span>))
    <span class="hljs-keyword">if</span> left:
        result += left
    <span class="hljs-keyword">if</span> right:
        result += right
    <span class="hljs-keyword">return</span> result

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(L)</span>:</span>
    <span class="hljs-keyword">if</span> len(L) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> L
    mid = len(L) // <span class="hljs-number">2</span>
    left = L[:mid]
    right = L[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    <span class="hljs-keyword">return</span> merge(left, right)</code></pre></div>
<p>时间复杂度是O(nlogn)，归并的空间复杂度为临时的数组和递归时压入栈的数据占用的空间：n + logn，所以空间复杂度为: O(n)。<a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44223225" target="_blank" rel="noopener">参考</a> </p>
<h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>重写merge()，实现O(1)</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_iter</span><span class="hljs-params">(nums,l1,l2,r2)</span>:</span>
	r1=l2<span class="hljs-number">-1</span>
	<span class="hljs-keyword">while</span> r1&gt;=l1 <span class="hljs-keyword">and</span> r2&gt;=l2:
		<span class="hljs-keyword">if</span> nums[r1]&gt;nums[r2]:
			tmp=nums[r2] <span class="hljs-comment"># 暂存较小值</span>
			nums[r2]=nums[r1]
			tmp_r1=r1<span class="hljs-number">-1</span>
             <span class="hljs-comment"># 将前半数组的大于tmp的值后移一个单位</span>
			<span class="hljs-keyword">while</span> nums[tmp_r1]&gt;tmp <span class="hljs-keyword">and</span> tmp_r1&gt;=l1: 
				nums[tmp_r1+<span class="hljs-number">1</span>]=nums[tmp_r1]
				tmp_r1-=<span class="hljs-number">1</span>
			nums[tmp_r1+<span class="hljs-number">1</span>]=tmp
		r2-=<span class="hljs-number">1</span></code></pre></div>
<p>这里参考了<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">leetcode 88.合并两个有序数组</a>，采用双指针从后往前合并两个有序数组（其实也就是一个数组切片的前一半和后一半），实现了空间复杂度O(1)。</p>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/merge.jpg" srcset="/img/loading.gif" alt="merge"></p>
<p><strong>方法一：使用生成器</strong></p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 生成器产生2的幂</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">powerOfTwo</span><span class="hljs-params">(max)</span>:</span>
	x=<span class="hljs-number">1</span>
	<span class="hljs-keyword">while</span> x&lt;=max:
		<span class="hljs-keyword">yield</span> x
		x*=<span class="hljs-number">2</span>
<span class="hljs-comment"># 方法一：用生成器产生1，2，4，8...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sorted_iter</span><span class="hljs-params">(nums)</span>:</span>
	sortedList=[]
	n=len(nums)
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> powerOfTwo(n):
	 	<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,n,i*<span class="hljs-number">2</span>):
	 		merge_iter(nums,j,min(j+i,n<span class="hljs-number">-1</span>),min(j+<span class="hljs-number">2</span>*i<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>))
	<span class="hljs-keyword">return</span> nums</code></pre></div>
<p><strong>方法二：使用位运算</strong></p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：用位操作产生1，2，4，8...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">msi</span><span class="hljs-params">(nums)</span>:</span>
	length = len(nums)
	step = <span class="hljs-number">1</span>
    <span class="hljs-comment"># 步长为1,2,4,8，...，一直合并下去</span>
	<span class="hljs-keyword">while</span> step &lt;= length:
		offset = step &lt;&lt; <span class="hljs-number">1</span>
		<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, length, offset):
			merge_iter(nums, index, min(index+step, length<span class="hljs-number">-1</span>), min(index+offset<span class="hljs-number">-1</span>, length<span class="hljs-number">-1</span>))
		step = offset</code></pre></div>
<p><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">时间复杂度是<script type="math/tex">O(nlog^2n)</script>,空间复杂度为: O(1)</a>。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>数据分区：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 </p>
<p><img src="Sorting_quicksort_anim.gif" srcset="/img/loading.gif" alt="quick"></p>
<h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p><img src="quick_sorted.gif" srcset="/img/loading.gif" alt="quicks"></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sorted</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> len(nums) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> nums
    left, right, mid = [], [], []
    pivot = random.choice(nums)
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        <span class="hljs-keyword">if</span> num == pivot:
            mid.append(num)
        <span class="hljs-keyword">elif</span> num &lt; pivot:
            left.append(num)
        <span class="hljs-keyword">else</span>:
            right.append(num)
    <span class="hljs-keyword">return</span> quick_sorted(left) + mid + quick_sorted(right)</code></pre></div>
<p>需要<script type="math/tex">{\Omega (n)}</script>的额外存储空间，也就跟归并排序一样不好。额外需要的存储空间，在实际实现时，也会极度影响速度和缓存的性能 。下面是原地排序的代码， <a href="[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#Python%E5%8E%9F%E5%9C%B0%E6%8E%92%E5%BA%8F%E7%89%88%E6%9C%AC](https://zh.wikipedia.org/wiki/快速排序#Python原地排序版本">平均可以达到<script type="math/tex">O(\log n)</script>的空间复杂度</a> )。 </p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sorted_inp</span><span class="hljs-params">(nums, first, last)</span>:</span>
    <span class="hljs-keyword">if</span> first &gt;= last:
        <span class="hljs-keyword">return</span>
    mid_value = nums[first]
    low = first
    high = last
    <span class="hljs-keyword">while</span> low &lt; high:
        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> nums[high] &gt;= mid_value:
            high -= <span class="hljs-number">1</span>
        nums[low] = nums[high]
        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> nums[low] &lt; mid_value:
            low += <span class="hljs-number">1</span>
        nums[high] = nums[low]
    nums[low] = mid_value
    quick_sorted_inp(nums, first, low<span class="hljs-number">-1</span>)
    quick_sorted_inp(nums, low+<span class="hljs-number">1</span>, last)</code></pre></div>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<blockquote>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
</blockquote>
<p><img src="Sorting_shellsort_anim.gif" srcset="/img/loading.gif" alt="shell"></p>
<h3 id="流程-6"><a href="#流程-6" class="headerlink" title="流程"></a>流程</h3><ol>
<li>选择一个增量序列<script type="math/tex">t_1</script>，<script type="math/tex">t_2</script>，…，<script type="math/tex">t_k</script>，其中<script type="math/tex">t_i</script>&gt;<script type="math/tex">t_j</script>，<script type="math/tex">t_k</script>=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量<script type="math/tex">t_i</script>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sorted</span><span class="hljs-params">(nums)</span>:</span>
    n = len(nums)
    <span class="hljs-comment"># 初始步長，理论上只要最终步长为1任何步长序列都可以工作</span>
    gap = n // <span class="hljs-number">2</span>
    <span class="hljs-keyword">while</span> gap &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gap, n):
            <span class="hljs-comment"># 每个步長進行插入排序</span>
            temp = nums[i]
            j = i
            <span class="hljs-comment"># 插入排序</span>
            <span class="hljs-keyword">while</span> j &gt;= gap <span class="hljs-keyword">and</span> nums[j - gap] &gt; temp:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = temp
        <span class="hljs-comment"># 得到新的步長</span>
        gap = gap // <span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> nums</code></pre></div>
<p>实际上使用1，2，4，8…的增量序列有时会在gap=1时浪费很多时间，[Mark Allen Weiss]指出，最好的增量序列是 Sedgewick提出的 (1, 5, 19, 41, 109,…)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。<a href="https://blog.csdn.net/u013630349/article/details/48250109" target="_blank" rel="noopener">使用 Sedgewick增量 的希尔排序的完整C语言程序</a></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h3 id="流程-7"><a href="#流程-7" class="headerlink" title="流程"></a>流程</h3><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<p><img src="counting_sorted.gif" srcset="/img/loading.gif" alt="countingsort"></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">counting_sorted</span><span class="hljs-params">(nums)</span>:</span>
	<span class="hljs-comment"># 计数排序针对非负整数，初始化最大值为-1，也可以设为nums[0]</span>
    maxValue=<span class="hljs-number">-1</span>
	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
		<span class="hljs-keyword">if</span> num&gt;maxValue:
			maxValue=num
	bucket = [<span class="hljs-number">0</span>]*(maxValue+<span class="hljs-number">1</span>)
	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
		bucket[num]+=<span class="hljs-number">1</span>
	index=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(bucket)):
		<span class="hljs-keyword">while</span> bucket[i]&gt;<span class="hljs-number">0</span>:
			nums[index] = i
			index+=<span class="hljs-number">1</span>
			bucket[i]-=<span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h3 id="流程-8"><a href="#流程-8" class="headerlink" title="流程"></a>流程</h3><ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<p><img src="radix_sorted.gif" srcset="/img/loading.gif" alt="radix"></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">radix_sorted</span><span class="hljs-params">(nums)</span>:</span>
	<span class="hljs-comment"># 基数排序针对非负整数，初始化最大值为-1,也可以设为nums[0]</span>
    maxValue=<span class="hljs-number">-1</span>
	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
		<span class="hljs-keyword">if</span> num&gt;maxValue:
			maxValue=num 
	<span class="hljs-comment"># 求最高位数n</span>
	n=len(str(maxValue))
	<span class="hljs-comment"># 进行n次排序</span>
	<span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(n):       
		s=[[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]
		<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
			s[i//(<span class="hljs-number">10</span>**k)%<span class="hljs-number">10</span>].append(i)
		nums=[a <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> s <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> b]
	<span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="流程-9"><a href="#流程-9" class="headerlink" title="流程"></a>流程</h3><ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="Bucket_sort_1.svg.png" srcset="/img/loading.gif" alt="bucket1"></p>
<p><img src="Bucket_sort_2.svg.png" srcset="/img/loading.gif" alt="bucket2"></p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bucket_sorted</span><span class="hljs-params">(nums)</span>:</span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<span class="hljs-keyword">return</span> nums
	maxValue=nums[<span class="hljs-number">0</span>]
	minValue=nums[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
		<span class="hljs-keyword">if</span> num&gt;maxValue:
			maxValue=num 
		<span class="hljs-keyword">elif</span> num&lt;minValue:
			minValue=num
	<span class="hljs-comment"># 将数据映射到桶中</span>
	bucketSize=<span class="hljs-number">100</span> <span class="hljs-comment"># 设定桶的大小</span>
	bucketCount=(maxValue-minValue)//bucketSize+<span class="hljs-number">1</span> <span class="hljs-comment"># 计算桶的数量</span>
	buckets=[[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(bucketCount)]
	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
		buckets[(num-minValue)//bucketSize].append(num)
	<span class="hljs-comment"># 对桶内排序，这里使用插入排序，也可以递归桶排序。</span>
	res=[]
	<span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> buckets:       
		res=res+insertion_sorted(k)
	<span class="hljs-keyword">return</span> res
<span class="hljs-comment"># 插入排序</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_sorted</span><span class="hljs-params">(nums)</span>:</span>
	size = len(nums)
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,size):
		cur_num=nums[i]
		pre_index=i<span class="hljs-number">-1</span>

		<span class="hljs-keyword">while</span> nums[pre_index]&gt;cur_num <span class="hljs-keyword">and</span> pre_index&gt;=<span class="hljs-number">0</span>:
			nums[pre_index+<span class="hljs-number">1</span>]=nums[pre_index]
			pre_index-=<span class="hljs-number">1</span>
		nums[pre_index+<span class="hljs-number">1</span>]=cur_num
	<span class="hljs-keyword">return</span> nums</code></pre></div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桶排序、基数排序和计数排序都属于非比较类排序，其中计数排序和基数排序都用到了桶排序的思想。计数排序一共分了0，1，2…maxValue一共maxValue+1个桶，每个桶表示一个数；而基数排序则分了十个桶，从第一位开始递归桶排序。冒泡排序，选择排序，插入排序都是比较两个数然后交换。堆排序，归并排序，快速排序则是运用了分治的思想。</p>
<p><a href="https://github.com/lil-q/sorting-algorithm-python" target="_blank" rel="noopener"><strong>完整代码</strong></a></p>
<p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a> </li>
<li><a href="https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/数据结构与算法.md" target="_blank" rel="noopener">https://github.com/amusi/Deep-Learning-Interview-Book/blob/master/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md</a> </li>
<li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a> </li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/python/">python</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/11/17/%E5%A0%86-heap/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">堆(Heap)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
          app_key: "wqRfy95wLQRm4b7BByawaNCK",
          placeholder: "说点什么吧",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <b>2019-2020</b>
      <i class="iconfont icon-love"></i>
      <b>lil-q</b>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "排序算法(Sorting algorithm)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  
















</body>
</html>
