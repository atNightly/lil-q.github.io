<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>动态规划 - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/pj70nu808l921.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Friday, April 10th 2020, 11:30 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    4.8k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      21 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          
          <div class="markdown-body">
            <p>“不如我们由头来过”</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>动态规划</strong>（Dynamic programming，DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化</strong>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<h1 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h1><ol>
<li><strong>最优子结构性质：</strong>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li><strong>无后效性：</strong>子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li><strong>子问题重叠性质：</strong>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li>
</ol>
<h1 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h1><h2 id="leetcode-300-最长上升子序列"><a href="#leetcode-300-最长上升子序列" class="headerlink" title="leetcode 300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode 300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度，时间复杂度降低到 <script type="math/tex">O(N\log N)</script> 。</p>
<p><strong>示例:</strong></p>
<pre><code class="lang-txt">输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre>
<p><strong>状态转移：</strong>求解长度为 n 的序列，需要知道前 n - 1 个序列所构成的所有子序列，如果序列结尾小于第 n 个数，则加上第 n 个数 <code>num</code> 构成新的子序列。这显然很复杂，可以根据贪心思想优化。由于这题求的是最长上升子序列，又因为向子序列添加数字只和末尾数字有关，所以对于每一个可能的子序列长度，只需要保留所有该长度序列的末尾数字中最小的那个数字即可，我们用 <code>tails</code> 保存这个信息。状态转移被优化为找到 <code>tails</code> 中所有满足 <code>tails[i] &lt; num &lt; tails[i + 1]</code>的情况，并将 <code>tails[i + 1]</code>替换为 <code>num</code>。可以证明 <code>tails</code>是递增的，所以这个数是唯一的。</p>
<p><strong>二分查找：</strong>题目要求时间复杂度在 <script type="math/tex">O(N\log N)</script> ，所以状态转移时查找第一个大于 <code>num</code>的数采用二分查找。</p>
<pre><code class="lang-java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0; // 记录右边界
        for (int num : nums) {
            // 二分法找第一个大于num的值
            int i = 0, j = res;
            while (i &lt; j) {
                int mid = (i + j) / 2 ;
                if (tails[mid] &lt; num) i = mid + 1; // 摒弃小于num的区间，包括mid
                else j = mid; // 保留大于num的区间，但保留mid
            }
            tails[i] = num;
            // 当所有数都小于num时，i会停留在res，此时需要更新边界
            if (i == res) res++; 
        }
        return res;
    }
}
</code></pre>
<h2 id="leetcode-354-俄罗斯套娃信封问题"><a href="#leetcode-354-俄罗斯套娃信封问题" class="headerlink" title="leetcode 354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">leetcode 354. 俄罗斯套娃信封问题</a></h2><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p><strong>示例:</strong></p>
<pre><code class="lang-txt">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。
</code></pre>
<p>通过对信封排序，可以把该问题简化为最长上升子序列问题。</p>
<pre><code class="lang-java">class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes.length == 0) return 0;
        int size = envelopes.length;
        // 想要对信封根据w排序，当w相同时，h按照降序排列，这样可以保证相同w的信封不能装合。
        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() {
            public int compare(int[] env1, int[] env2) {
                if (env1[0] == env2[0]) {
                    return env2[1] - env1[1]; // 降序
                } else {
                    return env1[0] - env2[0]; // 升序
                }
            }
        });
        int[] hs = new int[size];
        for (int i = 0; i &lt; size; i++) hs[i] = envelopes[i][1];
        return getMax(hs);
    }
    // 与上一题相同
    public int getMax(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 0;
        for (int num : nums) {
            int i = 0, j = res;
            while (i &lt; j) {
                int mid = (i + j) / 2;
                if (dp[mid] &lt; num) i = mid + 1;
                else j = mid;
            }
            dp[i] = num;
            if (i == res) res++;
        }
        return res;
    }
}
</code></pre>
<h2 id="leetcode-1143-最长公共子序列"><a href="#leetcode-1143-最长公共子序列" class="headerlink" title="leetcode 1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">leetcode 1143. 最长公共子序列</a></h2><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。若这两个字符串没有公共子序列，则返回 0。 </p>
<p><strong>示例:</strong></p>
<pre><code class="lang-txt">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 
输出：3  
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。
</code></pre>
<p>这里可以将二维 dp 转化为一维 dp ，但需要记录<code>dp[i - 1][j - 1]</code>。</p>
<pre><code class="lang-java">class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int[] dp = new int[text2.length() + 1];
        for (int i = text1.length() - 1; i &gt;= 0; i--) {
            int pre = 0; // pre用于记录下一次循环dp[i - 1][j - 1]，所以初始化为0
            for (int j = text2.length() - 1; j &gt;= 0; j--) {
                int tmp = dp[j];
                if (text1.charAt(i) == text2.charAt(j)) dp[j] = pre + 1;
                else dp[j] = Math.max(dp[j], dp[j + 1]);
                pre = tmp;
            }
        }
        return dp[0];
    }
}
</code></pre>
<h1 id="最优决策"><a href="#最优决策" class="headerlink" title="最优决策"></a>最优决策</h1><h2 id="leetcode-887-鸡蛋掉落"><a href="#leetcode-887-鸡蛋掉落" class="headerlink" title="leetcode 887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">leetcode 887. 鸡蛋掉落</a></h2><p>题目较复杂，请参考<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">官方题解</a>。使用二维dp的基础做法：</p>
<pre><code class="lang-java">class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        for (int i = 1; i &lt;= N; i++) dp[1][i] = i; // 一个鸡蛋的base case
        for (int i = 1; i &lt;= K; i++) dp[i][1] = 1; // 一层楼的base case
        // dp
        for (int i = 2; i &lt;= K; i++) {
            for (int j = 2; j &lt;= N; j++) {
                int x = 1, y = j;xx
                while (x + 1 &lt; y) { // 找到dp[i - 1][x - 1]和dp[i][j - x]相交点两侧的整数解
                    int mid = (x + y) / 2;
                    if (dp[i - 1][mid - 1] &gt; dp[i][j - mid]) y = mid; // 注意
                    else x = mid; // 注意
                }
                dp[i][j] = 1 + Math.min(Math.max(dp[i - 1][x - 1], dp[i][j - x]),
                                        Math.max(dp[i - 1][y - 1], dp[i][j - y]));  
            }
        }
        return dp[K][N];
    }
}
</code></pre>
<p>利用决策单调性并将二维dp简化为线性dp：</p>
<pre><code class="lang-java">class Solution {
    public int superEggDrop(int K, int N) {
        int[] dp = new int[N + 1];
        for (int i = 1; i &lt;= N; i++) dp[i] = i; // 一个鸡蛋的base case
        // dp
        for (int i = 2; i &lt;= K; i++) {
            int[] dp2 = new int[N + 1]; // 建新的数组记录
            int x = 1; // 根据决策单调性初始化一个对于下一个嵌套循环的全局变量
            for (int j = 1; j &lt;= N; j++) {
                while (x &lt; j &amp;&amp; Math.max(dp[x - 1], dp2[j - x]) 
                                &gt; Math.max(dp[x], dp2[j - x - 1])) x++;
                dp2[j] = 1 + Math.max(dp[x - 1], dp2[j - x]);
            }
            dp = dp2;
        }
        return dp[N];
    }
}
</code></pre>
<h2 id="leetcode-188-买卖股票的最佳时机-IV"><a href="#leetcode-188-买卖股票的最佳时机-IV" class="headerlink" title="leetcode 188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">leetcode 188. 买卖股票的最佳时机 IV</a></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算所能获取的最大利润。最多可以完成 k 笔交易。不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例:</strong></p>
<pre><code class="lang-txt">输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
</code></pre>
<p>股票类问题都可以用两个二维 dp 来解决，一个记录 sold 状态，另一个记录 hold 状态。dp 第一个维度对应天数，第二个维度对应第几次买卖操作，当操作次数不足时，后面会重复最后的操作。由于当天的情况只与前一天有关，第一个维度可以压缩至常量。当买卖次数不限时，只关心最优解，前若干次操作可以不记录，第二个维度可以压缩至常量。</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int k, int[] prices) {
        // k 大于天数的一半时，用简单的贪心算法即可，也简化了很多重复运算
        if(k &gt;= prices.length / 2){
            int profit = 0;
            for(int i = 1; i &lt; prices.length; i++){
                if(prices[i] &gt; prices[i-1]){
                    profit += prices[i] - prices[i-1];
                }
            }
            return profit;
        }
        // 初始化
        int[] sold = new int[k + 1];
        int[] hold = new int[k + 1];
        for (int i = 0; i &lt;= k; i++) hold[i] = Integer.MIN_VALUE;
        // dp
        for (int price : prices) {
            for (int i = 1; i &lt;= k; i++) {
                sold[i] = Math.max(sold[i], hold[i] + price);
                hold[i] = Math.max(hold[i], sold[i - 1] - price);  
            }
        }
        return sold[k];
    }
}
</code></pre>
<h2 id="leetcode-312-戳气球"><a href="#leetcode-312-戳气球" class="headerlink" title="leetcode 312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">leetcode 312. 戳气球</a></h2><p>这题正向思维会很难解，我们在决策时可以不考虑哪个先戳破，而是考虑哪个最后戳破。这样就可以用分治算法简化运算。递归不难实现，迭代时需要先把较短数组的子问题解决，再解决包含这些子问题的问题。</p>
<pre><code class="lang-java">// 自顶向下的递归
class Solution {
    int[][] memo;

    public int maxCoins(int[] nums) {
        int n = nums.length + 2;
        int[] nums2 = new int[n];
        for (int i = 1; i &lt; n - 1; i++) nums2[i] = nums[i - 1];
        nums2[0] = nums2[n - 1] = 1;
        memo = new int[n][n];
        return dp(0, n - 1, nums2);
    }

    public int dp(int l, int r, int[] nums) {
        if (l &gt; r - 2) return 0;
        if (memo[l][r] &gt; 0) return memo[l][r]; 
        for (int i = l + 1; i &lt; r; i++) {
            memo[l][r] = Math.max(memo[l][r],
            nums[i] * nums[l] * nums[r] + dp(l, i, nums) + dp(i, r, nums));
        }
        return memo[l][r];
    }
}
// 自底向上的迭代
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length + 2;
        int[] nums2 = new int[n];
        for (int i = 1; i &lt; n - 1; i++) nums2[i] = nums[i - 1];
        nums2[0] = nums2[n - 1] = 1;
        int[][] dp = new int[n][n];
        for (int l = n - 2; l &gt;= 0; l--) { // 注意
            for (int r = l + 2; r &lt; n; r++) { // 注意
                for (int i = l + 1; i &lt; r; i++){
                    dp[l][r] = Math.max(dp[l][r], 
                    nums2[i] * nums2[l] * nums2[r] + dp[l][i] + dp[i][r]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
</code></pre>
<p>类似的扫描方式还有<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">leetcode 516. 最长回文子序列</a>：</p>
<pre><code class="lang-java">class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int l = n - 1; l &gt;= 0; l--) {
            for (int r = l; r &lt; n; r++) {
                if (l == r) dp[l][r] = 1;
                else if (s.charAt(l) == s.charAt(r)) dp[l][r] = dp[l + 1][r - 1] + 2;
                else dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);
            }
        }
        return dp[0][n - 1];
    }
}
</code></pre>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/Adjustments.plist" alt=""></p>
<p>下面的这题可以展示另一种遍历方式——<a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">leetcode 1039. 多边形三角剖分的最低得分</a>：</p>
<pre><code class="lang-java">class Solution {
    public int minScoreTriangulation(int[] A) {
        int n = A.length;
        int[][] dp = new int[n][n];
        for (int len = 2; len &lt; n; len++) { // 长度逐渐变长
            for (int l = 0; l &lt; n - len; l++) { // 左端由上至下
                int r = l + len;
                dp[l][r] = Integer.MAX_VALUE;
                for (int i = l + 1; i &lt; r; i++) {
                    dp[l][r] = Math.min(dp[l][r], dp[l][i] + dp[i][r] + A[l] * A[i] * A[r]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
</code></pre>
<h2 id="leetcode-664-奇怪的打印机"><a href="#leetcode-664-奇怪的打印机" class="headerlink" title="leetcode 664. 奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">leetcode 664. 奇怪的打印机</a></h2><p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印同一个字符序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<pre><code class="lang-txt">输入: &quot;aaabbb&quot;
输出: 2
解释: 首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。
</code></pre>
<p>给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。</p>
<pre><code class="lang-java">class Solution {
    int[][] memo;

    public int strangePrinter(String s) {
        int n = s.length();
        memo = new int[n][n];
        return dp(0, n - 1, s);
    }

    public int dp(int l, int r, String s) {
        if (l &gt; r) return 0;
        if (memo[l][r] == 0) {
            int ans = dp(l + 1, r, s) + 1; // 首字符是单独打印的
            for (int i = l + 1; i &lt;= r; i++)
                // [l,i]是一起打印的，s[i]打印的次数包含于dp(l, i - 1, s)
                if (s.charAt(i) == s.charAt(l)) 
                    ans = Math.min(ans, dp(l, i - 1, s) + dp(i + 1, r, s));
            memo[l][r] = ans;
        }
        return memo[l][r];
    }
}
</code></pre>
<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p>字符串处理基本都能用动态规划来做。</p>
<h2 id="leetcode-10-正则表达式匹配"><a href="#leetcode-10-正则表达式匹配" class="headerlink" title="leetcode 10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">leetcode 10. 正则表达式匹配</a></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<pre><code class="lang-txt">&#39;.&#39; 匹配任意单个字符
&#39;*&#39; 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
</code></pre>
<p>这里采用从后往前匹配的方式，对于空字符串的匹配结果可以放在二维数组<code>memo</code>的末尾，算法更加清晰。</p>
<pre><code class="lang-java">// 迭代
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[s.length()][p.length()] = true;
        for (int i = s.length(); i &gt;= 0; i--) {
            for (int j = p.length() - 1; j &gt;= 0; j--) {
                boolean first_match = i &lt; s.length() 
                    &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;);
                if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == &#39;*&#39;) {
                    dp[i][j] = dp[i][j + 2] || first_match &amp;&amp; dp[i + 1][j];
                } else {
                    dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];
    }
}
// 递归
class Solution {
    int[][] memo;

    public boolean isMatch(String s, String p) {
        memo = new int[s.length() + 1][p.length() + 1];
        return dp(0, 0, s, p);
    }

    public boolean dp(int i, int j, String s, String p) {
        if (memo[i][j] != 0) return memo[i][j] == 1;
        boolean ans;
        if (j == p.length()) {
            ans = i == s.length();
        } else {
            boolean first_match = i &lt; s.length() 
                    &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;);
            if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == &#39;*&#39;) {
                ans = dp(i, j + 2, s, p) || first_match &amp;&amp; dp(i + 1, j, s, p);
            } else {
                ans = first_match &amp;&amp; dp(i + 1, j + 1, s, p);
            }
        }
        memo[i][j] = ans ? 1 : -1;
        return ans;
    }
}
</code></pre>
<h2 id="leetcode-72-编辑距离"><a href="#leetcode-72-编辑距离" class="headerlink" title="leetcode 72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">leetcode 72. 编辑距离</a></h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-txt">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)
</code></pre>
<p>先用二维 dp 理清思路，之后压缩空间占用。</p>
<pre><code class="lang-java">class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length(), len2 = word2.length();
        // 初始化
        int[][] dp = new int[len1 + 1][len2 + 1];
        for (int i = len1; i &gt;= 0; i--) dp[i][len2] = len1 - i;
        for (int j = len2; j &gt;= 0; j--) dp[len1][j] = len2 - j;
        // dp
        for (int i = len1 - 1; i &gt;= 0; i--) {
            for (int j = len2 - 1; j &gt;= 0; j--){
                if (word1.charAt(i) == word2.charAt(j)) {
                    dp[i][j] = dp[i + 1][j + 1]; // 字符相同时只有一种可能
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i][j + 1], dp[i + 1][j]),
                                        dp[i + 1][j + 1]) + 1;
                }
            }
        }
        return dp[0][0];
    }
}
// 一维dp
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length(), len2 = word2.length();
        int[] dp = new int[len2 + 1];
        for (int j = 0; j &lt;= len2; j++) dp[j] = j;

        for (int i = 1; i &lt;= len1; i++) {
            int[] dp2 = new int[len2 + 1];
            dp2[0] = i;
            for (int j = 1; j &lt;= len2; j++){
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp2[j] = dp[j - 1];
                } else {
                    dp2[j] = Math.min(Math.min(dp2[j - 1], dp[j]), dp[j - 1]) + 1;
                }
            }
            dp = dp2;
        }
        return dp[len2];
    }
}
</code></pre>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><a href="https://zh.wikipedia.org/wiki/背包问题" target="_blank" rel="noopener">背包问题</a>作为<a href="https://zh.wikipedia.org/wiki/NP完全" target="_blank" rel="noopener">NP完全</a>问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。 背包问题具有<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p>
<h2 id="AcWing-5-多重背包问题"><a href="#AcWing-5-多重背包问题" class="headerlink" title="AcWing 5 多重背包问题"></a><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">AcWing 5 多重背包问题</a></h2><p>有 <script type="math/tex">N</script> 种物品和一个容量是 <script type="math/tex">V</script> 的背包。第 <script type="math/tex">i</script> 种物品最多有 <script type="math/tex">s_i</script> 件，每件体积是 <script type="math/tex">v_i</script>，价值是 <script type="math/tex">w_i</script>。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大，输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，<script type="math/tex">N</script>，<script type="math/tex">V</script>，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 <script type="math/tex">N</script> 行，每行三个整数 <script type="math/tex">u</script>、<script type="math/tex">w</script>、<script type="math/tex">s</script>，用空格隔开，分别表示第 <script type="math/tex">i</script> 种物品的体积、价值和数量。</p>
<pre><code class="lang-txt">输入样例
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10
</code></pre>
<p>当 <script type="math/tex">s</script> 很大时，单纯使用0-1背包会消耗大量时间，可以使用二进制优化方法。</p>
<pre><code class="lang-java">import java.util.Scanner;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 处理输入
        Scanner jin = new Scanner(System.in);
        int n = jin.nextInt();
        int v = jin.nextInt();
        // 二进制优化
        List&lt;Integer&gt; ulist = new ArrayList();
        List&lt;Integer&gt; wlist = new ArrayList();
        for (int i = 0; i &lt; n; i++) {
            int u = jin.nextInt();
            int w = jin.nextInt();
            int s = jin.nextInt();
            // 二进制优化方法，比如9可以拆分为1、2、4、2，这四个数可以组成1-9的任意数
            int k = 1;
            while(s &gt; k) { 
                ulist.add(u * k);
                wlist.add(w * k);
                s -= k;
                k &lt;&lt;= 1;
            }
            if (s &gt; 0) {
                ulist.add(u * s);
                wlist.add(w * s);
            }
        }
        // 动态规划
        n = ulist.size();
        int[] dp = new int[v + 1];
        for (int i = 1; i &lt;= n; i++) {
            for (int j = v; j &gt; 0; j--) { // 从后往前遍历，可以重复使用上一轮的数据
                if (j &gt;= ulist.get(i - 1))
                    dp[j] = Math.max(dp[j], dp[j - ulist.get(i - 1)] + wlist.get(i - 1));          
            }
        }
        System.out.print(dp[v]);
    }
}
</code></pre>
<h1 id="树型问题"><a href="#树型问题" class="headerlink" title="树型问题"></a>树型问题</h1><h2 id="leetcode-337-打家劫舍-III"><a href="#leetcode-337-打家劫舍-III" class="headerlink" title="leetcode 337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">leetcode 337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [3,2,3,null,3,null,1]
 3
/ \
2   3
 \   \ 
  3   1
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</code></pre><p>原地修改可以减少递归次数，<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/java-ji-yi-hua-dphe-yuan-di-xiu-gai-by-lil-q/" target="_blank" rel="noopener">对比</a>：</p>
<pre><code class="lang-java">class Solution {
    public int rob(TreeNode root) {
        if(root==null) return 0;
        int f = root.val, s = 0; // f: 选取root；s: 不选取root
        s += rob(root.left) + rob(root.right); // 只递归子节点，孙子节点由递归内部完成
        if(root.left!=null) {
            f += root.left.left!=null ? root.left.left.val : 0;
            f += root.left.right!=null ? root.left.right.val : 0;
        }
        if(root.right!=null) {
            f += root.right.left!=null ? root.right.left.val : 0;
            f += root.right.right!=null ? root.right.right.val : 0;
        }
        root.val = Math.max(f, s);
        return root.val;
    }
}
</code></pre>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
              
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/java/">java</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>
      </div>
    
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="vcomments" style="width: 90%; margin: 0 auto;"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script>
    var notify = 'false' === 'true';
    var verify = 'false' === 'true';
    var oldLoad = window.onload;
    window.onload = function () {
      new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
        app_key: "wqRfy95wLQRm4b7BByawaNCK",
        placeholder: "喂？",
        avatar: "/retro",
        meta: ['nick', 'mail', 'link'],
        pageSize: "10",
      });
      oldLoad && oldLoad();
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>



    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <b>2020</b>
    <i class="iconfont icon-love"></i>
    <b>lil-q</b>

    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      <span id="busuanzi_value_site_pv"></span>次访问 |
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      <span id="busuanzi_value_site_uv"></span>人来过
    </span>
    
  </div>


    

    <!-- cnzz Analytics icon -->
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>




  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var main = $('main');
      var tocT = navHeight + (toc.offset().top - main.offset().top);
      var tocLimMin = main.offset().top - navHeight;
      var tocLimMax = $('#comments').offset().top - navHeight;
      $(window).scroll(function () {
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;
        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': tocT,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "动态规划&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script  src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  










</body>
</html>
