<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#111">
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>java-Map - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


  <script  src="/js/utils.js" ></script>
</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/max-larochelle-7YtI5565PVU-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-04-02 15:37">
      April 2, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>java学习及面试题汇总——Map及其源码分析</p>
<a id="more"></a>
<p>源码基于java 13。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/javamap.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>TreeMap：基于<strong>红黑树</strong>实现。</li>
<li>HashMap：基于<strong>哈希表</strong>实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><p>要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;...&#125;</code></pre></div>
<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;...&#125;</code></pre></div>
<h2 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h2><p>正确使用<code>Map</code>必须保证：</p>
<ol>
<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ol>
<p>自己写<code>hashCode()</code>时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">17</span>;
    result = <span class="hljs-number">31</span> * result + x;
    result = <span class="hljs-number">31</span> * result + y;
    result = <span class="hljs-number">31</span> * result + z;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>
<p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> Objects.hash(firstName, lastName, age);
&#125;</code></pre></div>
<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：<code>equals()</code>用到的用于比较的每一个字段，都<strong>必须</strong>在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，<strong>绝不可</strong>放在<code>hashCode()</code>中计算。</p>
<p>Objects.hash()内部实现实则为Arrays.hashCode()方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object... values)</span> </span>&#123;
    <span class="hljs-keyword">return</span> Arrays.hashCode(values);
&#125;</code></pre></div>
<p>Arrays.hashCode()源码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(Object a[])</span> </span>&#123;
    <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (Object element : a)
        result = <span class="hljs-number">31</span> * result + (element == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : element.hashCode());

    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>
<p>注意Objects.hash(Object…)，它的参数为不定参数，需要为Object对象。这会有以下一些影响：</p>
<ol>
<li>对基本类型做hashCode需要转换为包装类型，如long转换为Long</li>
<li>会创建一个Object[]数组</li>
</ol>
<p>如果hashCode()方法被频繁调用的话，会有一定的性能影响。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p><code>hashCode()</code>内部使用了数组，在初始化时默认的数组大小只有16，任何<code>key</code>无论<code>hashCode()</code>多大都可以用类似方式处理：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index = key.hashCode() &amp; <span class="hljs-number">0xf</span>;</code></pre></div>
<p>当这个<code>hashMap</code>添加超过16个<code>key-value</code>时，<code>hashMap</code>会自动扩容，没扩容一次容量就会翻倍。因为内存每次扩容会导致重新分配已有的<code>key-value</code>，所以频繁扩容对<code>HashMap</code>的性能影响很大。如果确定要使用n个<code>key-value</code>的<code>HashMap</code>，最好在创建时就指定容量：</p>
<div class="hljs"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(n);</code></pre></div>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><code>SortedMap</code>在遍历时严格按照Key的顺序遍历，最常用的实现类是<code>TreeMap</code>。作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>：</p>
<div class="hljs"><pre><code class="hljs java">Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;
        <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);
    &#125;
&#125;);</code></pre></div>
<p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a &lt; b</code>，则返回负数，通常是<code>-1</code>，如果<code>a == b</code>，则返回<code>0</code>，如果<code>a &gt; b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p>
<p><a href="https://www.nowcoder.com/practice/46e837a4ea9144f5ad2021658cb54c4d?tpId=98&amp;tqId=32824&amp;tPage=1&amp;rp=1&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">nowcoder面试题 找工作</a></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Scanner jin = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">int</span> N = jin.nextInt();
        <span class="hljs-keyword">int</span> M = jin.nextInt();
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][<span class="hljs-number">2</span>];
        <span class="hljs-comment">// 排序</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;
            arr[i][<span class="hljs-number">0</span>] = jin.nextInt();
            arr[i][<span class="hljs-number">1</span>] = jin.nextInt();
        &#125;
        Arrays.sort(arr, (e1, e2) -&gt; e1[<span class="hljs-number">0</span>] - e2[<span class="hljs-number">0</span>]);
        <span class="hljs-comment">// 找出难度对应的最大工资，并保存到TreeMap中</span>
        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i][<span class="hljs-number">1</span>] &lt; arr[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) arr[i][<span class="hljs-number">1</span>] = arr[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
            map.put(arr[i][<span class="hljs-number">0</span>], arr[i][<span class="hljs-number">1</span>]);
        &#125;
        <span class="hljs-comment">// 利用.floorKey()找到最大的小于等于能力值的工作</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) &#123;
            Integer index = map.floorKey(jin.nextInt());
            <span class="hljs-keyword">if</span> (index == <span class="hljs-keyword">null</span>) &#123;
                System.out.println(<span class="hljs-number">0</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(map.get(index));
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/hashmapjiegoutu.png" srcset="/img/loading.gif" alt="hashmap"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;
    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;...&#125;</code></pre></div>
<p>默认的容量是16：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span></code></pre></div>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><code>HashMap</code>内部包含了一个 <code>Node</code> 类型的数组 <code>table</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;</code></pre></div>
<p><code>Node</code> 实现了<code>Map.Entry</code>接口，包含了四个字段，存储着键值对<code>Entry</code>(<code>key</code>, <code>value</code>)、<code>hash</code>和<code>next</code>。数组<code>table</code>中的每个位置被当成一个桶，一个桶存放一个链表。<code>HashMap</code> 使用<strong>拉链法</strong>来解决冲突，同一个链表中存放<strong>哈希值和散列桶取模运算结果相同</strong>的 Node`。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**N
* Basic hash bin node, used for most entries.  (See below for
* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
*/</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
    <span class="hljs-keyword">final</span> K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        <span class="hljs-keyword">this</span>.hash = hash;
        <span class="hljs-keyword">this</span>.key = key;
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.next = next;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + value; &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;
        V oldValue = value;
        value = newValue;
        <span class="hljs-keyword">return</span> oldValue;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre></div>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>public</code>的<code>put()</code>方法调用了<code>putVal()</code>方法：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,
               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;
    <span class="hljs-comment">// 当table不存在或长度为0时，新建一个table</span>
    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
        n = (tab = resize()).length;
    <span class="hljs-comment">// 当桶下标对应的node不存在时，新建该Node加入table</span>
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)
        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
    <span class="hljs-comment">// 当桶下标对应的Node已经存在时</span>
    <span class="hljs-keyword">else</span> &#123;
        Node&lt;K,V&gt; e; K k;
        <span class="hljs-comment">// key相同时</span>
        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
            e = p;
        <span class="hljs-comment">// Node为TreeNode时</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);
        <span class="hljs-comment">// key不相同，采用尾插法插入Node</span>
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//遍历链表</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;
                <span class="hljs-comment">// 到链表末尾但没有相同key，则添加新Node</span>
                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;
                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
                    <span class="hljs-comment">// 链表过长，将链表转为树结构</span>
                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-comment">// 找到相同key</span>
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">break</span>;
                p = e;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>
            V oldValue = e.value;
            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span>
            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);
            <span class="hljs-keyword">return</span> oldValue;
        &#125;
    &#125;
    ++modCount;
    <span class="hljs-keyword">if</span> (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
    Node&lt;K,V&gt; e;
    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;
    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;
        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>
            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
            <span class="hljs-keyword">return</span> first;
        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)
                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            <span class="hljs-keyword">do</span> &#123;
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">return</span> e;
            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历所有的键时，首先要获取键集合<code>KeySet</code>对象，然后再通过 <code>KeySet</code> 的迭代器<code>KeyIterator</code>进行遍历。<code>KeyIterator</code> 类继承自 <code>HashIterator</code> 类，核心逻辑也封装在 <code>HashIterator</code> 类中。<code>HashIterator</code> 的逻辑并不复杂，在初始化时，<code>HashIterator</code> 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。</p>
<h2 id="桶下标"><a href="#桶下标" class="headerlink" title="桶下标"></a>桶下标</h2><p>首先，传入<code>putVal()</code>的<code>hash(key)</code>处理如下，对于<code>key</code>为<code>null</code>的键值对，返回的<code>hash</code>为 0；其余则是将所得<code>hashCode</code>右移16位后于原<code>hashCode</code>作异或处理：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre></div>
<p>在后续的处理中会根据<code>HashMap</code>的容量大小取余，得到桶下标：</p>
<div class="hljs"><pre><code class="hljs java">n = table.length;
i = (n - <span class="hljs-number">1</span>) &amp; hash;</code></pre></div>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>JDK1.8开始，HashMap由链表的头插法改变成了<strong>尾插法</strong>，因此不再会造成死循环，改成尾插法也是为了能够更好的维护jdk1.8中HashMap的红黑树结构。</p>
<h2 id="黑红树"><a href="#黑红树" class="headerlink" title="黑红树"></a>黑红树</h2><p>当链表变长时，查找和添加的速度会变慢，JDK1.8后加入了链表转换为黑红树的机制，当链表长度超过<code>TREEIFY_THRESHOLD</code>（默认为8）时，会转化成黑红树。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;</code></pre></div>
<p>在键类没有实现 <code>comparable</code> 接口的情况下，<code>HashMap</code> 会做以下三步处理：</p>
<ol>
<li>比较键与键之间 <code>hash</code> 的大小，如果 <code>hash</code> 相同，则</li>
<li>检测键类是否实现了 <code>Comparable</code> 接口，是则调用 <code>compareTo</code> 方法进行比较，否则</li>
<li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 <code>tieBreakOrder</code>。</li>
</ol>
<h2 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a>加载因子</h2><p>初始容量<code>initialCapacity</code>是哈希表中初始桶的数量，加载因子<code>loadFactor</code>是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了<strong>加载因子与当前容量的乘积</strong>时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。</p>
<p>通常，加载因子需要<strong>在时间和空间成本上寻求一种折衷</strong>，默认为<code>0.75f</code>。加载因子过高，例如为 1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；加载因子过低，例如 0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了 rehash 操作的次数。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>设 <code>HashMap</code> 的 <code>table</code> 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 <code>table</code> 要尽可能大。<code>HashMap</code> 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 键值对的数量</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;
<span class="hljs-comment">// 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;
<span class="hljs-comment">// size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</span>
<span class="hljs-keyword">int</span> threshold;
<span class="hljs-comment">// 默认的装载因子</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;</code></pre></div>
<p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 <code>newTable</code> 中，包括链表和黑红树的拆分，因此这一步是很费时的。</p>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，<code>HashMap</code> 使用 <code>hash % capacity</code> 来确定桶下标。<code>capacity</code> 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 <code>capacity</code> 为 16，扩容之后 <code>new capacity</code> 为 32：</p>
<div class="hljs"><pre><code class="hljs java">capacity     : <span class="hljs-number">00010000</span>
<span class="hljs-keyword">new</span> capacity : <span class="hljs-number">00100000</span></code></pre></div>
<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h2 id="与-Hashtable-的比较"><a href="#与-Hashtable-的比较" class="headerlink" title="与 Hashtable 的比较"></a>与 Hashtable 的比较</h2><ul>
<li><code>Hashtable</code> 使用 <code>synchronized</code> 来进行同步。</li>
<li><code>HashMap</code> 可以插入键为 <code>null</code> 的 <code>Entry</code>。</li>
<li><code>HashMap</code> 的迭代器是 fail-fast 迭代器。</li>
<li><code>HashMap</code> 不能保证随着时间的推移 <code>Map</code> 中的元素次序是不变的。</li>
</ul>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>待补充</p>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;
    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;...&#125;</code></pre></div>
<p>继承自 <code>HashMap</code>，因此具有和 <code>HashMap</code> 一样的快速查找特性。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
    Entry&lt;K,V&gt; before, after;
    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        <span class="hljs-keyword">super</span>(hash, key, value, next);
    &#125;
&#125;</code></pre></div>
<p><code>Entry</code>类继承自<code>HashMap.Node</code>，可见内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// The head (eldest) of the doubly linked list.</span>
<span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;

<span class="hljs-comment">// The tail (youngest) of the doubly linked list.</span>
<span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</code></pre></div>
<p><code>accessOrder</code> 决定了顺序，默认为 <code>false</code>，此时维护的是插入顺序。显式设置为 true，代表以访问顺序进行迭代。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;</code></pre></div>
<p><code>LinkedHashMap</code> 最重要的是以下用于维护顺序的函数，它们会在 <code>put()</code>、<code>get()</code> 等方法中调用。<code>LinkedHashMap</code>并没有覆写<code>put()</code>，而是覆写了<code>afterNodeAccess(Node&lt;K,V&gt; p)</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;</code></pre></div>
<h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h2><p>当一个节点被访问时，如果 <code>accessOrder</code> 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span>
    LinkedHashMap.Entry&lt;K,V&gt; last;
    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)
            head = a;
        <span class="hljs-keyword">else</span>
            b.after = a;
        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)
            a.before = b;
        <span class="hljs-keyword">else</span>
            last = b;
        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)
            head = p;
        <span class="hljs-keyword">else</span> &#123;
            p.before = last;
            last.after = p;
        &#125;
        tail = p;
        ++modCount;
    &#125;
&#125;</code></pre></div>
<h2 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h2><p>在 <code>put()</code> 等操作之后执行，当 <code>removeEldestEntry()</code> 方法返回 <code>true</code> 时会移除最晚的节点，也就是链表首部节点 <code>first</code>。<code>evict</code> 只有在构建 <code>Map</code> 的时候才为 <code>false</code>，在这里为 <code>true</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span>
    LinkedHashMap.Entry&lt;K,V&gt; first;
    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;
        K key = first.key;
        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    &#125;
&#125;Copy to clipboardErrorCopied</code></pre></div>
<p><code>removeEldestEntry()</code> 默认为 <code>false</code>，如果需要让它为 <code>true</code>，需要继承 <code>LinkedHashMap</code> 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>
<h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>以下是使用 <code>LinkedHashMap</code> 实现的一个 LRU 缓存：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123; <span class="hljs-comment">// 继承自LinkedHashMap</span>
    <span class="hljs-comment">// 最大缓存空间MAX_ENTRIES，默认值为3</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ENTRIES = <span class="hljs-number">3</span>;
    
    <span class="hljs-comment">// 覆写</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> </span>&#123;
        <span class="hljs-keyword">return</span> size() &gt; MAX_ENTRIES;
    &#125;
    
    <span class="hljs-comment">// 初始化，将 accessOrder 设置为 true</span>
    LRUCache() &#123;
        <span class="hljs-keyword">super</span>(MAX_ENTRIES, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key, -<span class="hljs-number">1</span>);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.put(key, value);
    &#125;
&#125;</code></pre></div>
<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>待补充</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration</code>：已被<code>Iterator</code>取代。</li>
</ul>
<p>Java的集合类定义在<code>java.util</code>包中，支持泛型。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java 容器" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265118019954528" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265118019954528</a></li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/04/java%E5%9F%BA%E7%A1%80%E5%85%AD/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java-I/O</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/30/java%E5%9F%BA%E7%A1%80%E5%9B%9B/">
                        <span class="hidden-mobile">java-Collection</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
          app_key: "wqRfy95wLQRm4b7BByawaNCK",
          placeholder: "说点什么吧",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java-Map&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
