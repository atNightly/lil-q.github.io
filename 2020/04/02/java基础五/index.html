<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>java-Map - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7878.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Thursday, April 2nd 2020, 3:37 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    3.7k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      16 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          
          <div class="markdown-body">
            <p>java学习及面试题汇总——Map及其源码分析</p>
<a id="more"></a>
<p>源码基于java 13。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/javamap.png" alt=""></p>
<ul>
<li>TreeMap：基于<strong>红黑树</strong>实现。</li>
<li>HashMap：基于<strong>哈希表</strong>实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><p>要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p>
<pre><code class="lang-java">for (String key : map.keySet()) {...}
</code></pre>
<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p>
<pre><code class="lang-java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {...}
</code></pre>
<h2 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h2><p>正确使用<code>Map</code>必须保证：</p>
<ol>
<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ol>
<p>自己写<code>hashCode()</code>时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<pre><code class="lang-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>
<p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>
<pre><code class="lang-java">int hashCode() {
    return Objects.hash(firstName, lastName, age);
}
</code></pre>
<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：<code>equals()</code>用到的用于比较的每一个字段，都<strong>必须</strong>在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，<strong>绝不可</strong>放在<code>hashCode()</code>中计算。</p>
<p>Objects.hash()内部实现实则为Arrays.hashCode()方法</p>
<pre><code class="lang-java">public static int hash(Object... values) {
    return Arrays.hashCode(values);
}
</code></pre>
<p>Arrays.hashCode()源码</p>
<pre><code class="lang-java">public static int hashCode(Object a[]) {
    if (a == null)
        return 0;

    int result = 1;

    for (Object element : a)
        result = 31 * result + (element == null ? 0 : element.hashCode());

    return result;
}
</code></pre>
<p>注意Objects.hash(Object…)，它的参数为不定参数，需要为Object对象。这会有以下一些影响：</p>
<ol>
<li>对基本类型做hashCode需要转换为包装类型，如long转换为Long</li>
<li>会创建一个Object[]数组</li>
</ol>
<p>如果hashCode()方法被频繁调用的话，会有一定的性能影响。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p><code>hashCode()</code>内部使用了数组，在初始化时默认的数组大小只有16，任何<code>key</code>无论<code>hashCode()</code>多大都可以用类似方式处理：</p>
<pre><code class="lang-java">int index = key.hashCode() &amp; 0xf;
</code></pre>
<p>当这个<code>hashMap</code>添加超过16个<code>key-value</code>时，<code>hashMap</code>会自动扩容，没扩容一次容量就会翻倍。因为内存每次扩容会导致重新分配已有的<code>key-value</code>，所以频繁扩容对<code>HashMap</code>的性能影响很大。如果确定要使用n个<code>key-value</code>的<code>HashMap</code>，最好在创建时就指定容量：</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(n);
</code></pre>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><code>SortedMap</code>在遍历时严格按照Key的顺序遍历，最常用的实现类是<code>TreeMap</code>。作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>：</p>
<pre><code class="lang-java">Map&lt;Person, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() {
    public int compare(Person p1, Person p2) {
        return p1.name.compareTo(p2.name);
    }
});
</code></pre>
<p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a &lt; b</code>，则返回负数，通常是<code>-1</code>，如果<code>a == b</code>，则返回<code>0</code>，如果<code>a &gt; b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/hashmapjiegoutu.png" alt="hashmap"></p>
<pre><code class="lang-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {...}
</code></pre>
<p>默认的容量是16：</p>
<pre><code class="lang-java">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
</code></pre>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><code>HashMap</code>内部包含了一个 <code>Node</code> 类型的数组 <code>table</code>。</p>
<pre><code class="lang-java">transient Node&lt;K,V&gt;[] table;
</code></pre>
<p><code>Node</code> 实现了<code>Map.Entry</code>接口，包含了四个字段，存储着键值对<code>Entry</code>(<code>key</code>, <code>value</code>)、<code>hash</code>和<code>next</code>。数组<code>table</code>中的每个位置被当成一个桶，一个桶存放一个链表。<code>HashMap</code> 使用<strong>拉链法</strong>来解决冲突，同一个链表中存放<strong>哈希值和散列桶取模运算结果相同</strong>的 Node`。</p>
<pre><code class="lang-java">/**N
* Basic hash bin node, used for most entries.  (See below for
* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
*/
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + &quot;=&quot; + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
</code></pre>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>public</code>的<code>put()</code>方法调用了<code>putVal()</code>方法：</p>
<pre><code class="lang-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<pre><code class="lang-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // 当table不存在或长度为0时，新建一个table
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 当桶下标对应的node不存在时，新建该Node加入table
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 当桶下标对应的Node已经存在时
    else {
        Node&lt;K,V&gt; e; K k;
        // key相同时
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // Node为TreeNode时
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // key不相同，采用尾插法插入Node
        else {
            //遍历链表
            for (int binCount = 0; ; ++binCount) {
                // 到链表末尾但没有相同key，则添加新Node
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 链表过长，将链表转为树结构
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 找到相同key
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            // onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><pre><code class="lang-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
</code></pre>
<pre><code class="lang-java">final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历所有的键时，首先要获取键集合<code>KeySet</code>对象，然后再通过 <code>KeySet</code> 的迭代器<code>KeyIterator</code>进行遍历。<code>KeyIterator</code> 类继承自 <code>HashIterator</code> 类，核心逻辑也封装在 <code>HashIterator</code> 类中。<code>HashIterator</code> 的逻辑并不复杂，在初始化时，<code>HashIterator</code> 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。</p>
<h2 id="桶下标"><a href="#桶下标" class="headerlink" title="桶下标"></a>桶下标</h2><p>首先，传入<code>putVal()</code>的<code>hash(key)</code>处理如下，对于<code>key</code>为<code>null</code>的键值对，返回的<code>hash</code>为 0；其余则是将所得<code>hashCode</code>右移16位后于原<code>hashCode</code>作异或处理：</p>
<pre><code class="lang-java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>在后续的处理中会根据<code>HashMap</code>的容量大小取余，得到桶下标：</p>
<pre><code class="lang-java">n = table.length;
i = (n - 1) &amp; hash;
</code></pre>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>JDK1.8开始，HashMap由链表的头插法改变成了<strong>尾插法</strong>，因此不再会造成死循环，改成尾插法也是为了能够更好的维护jdk1.8中HashMap的红黑树结构。</p>
<h2 id="黑红树"><a href="#黑红树" class="headerlink" title="黑红树"></a>黑红树</h2><p>当链表变长时，查找和添加的速度会变慢，JDK1.8后加入了链表转换为黑红树的机制，当链表长度超过<code>TREEIFY_THRESHOLD</code>（默认为8）时，会转化成黑红树。</p>
<pre><code class="lang-java">static final int TREEIFY_THRESHOLD = 8;
static final int UNTREEIFY_THRESHOLD = 6;
</code></pre>
<p>在键类没有实现 <code>comparable</code> 接口的情况下，<code>HashMap</code> 会做以下三步处理：</p>
<ol>
<li>比较键与键之间 <code>hash</code> 的大小，如果 <code>hash</code> 相同，则</li>
<li>检测键类是否实现了 <code>Comparable</code> 接口，是则调用 <code>compareTo</code> 方法进行比较，否则</li>
<li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 <code>tieBreakOrder</code>。</li>
</ol>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>设 <code>HashMap</code> 的 <code>table</code> 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 <code>table</code> 要尽可能大。<code>HashMap</code> 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<pre><code class="lang-java">// 键值对的数量
transient int size;
// 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。
final float loadFactor;
// size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。
int threshold;
// 默认的装载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 <code>newTable</code> 中，包括链表和黑红树的拆分，因此这一步是很费时的。</p>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，<code>HashMap</code> 使用 <code>hash % capacity</code> 来确定桶下标。<code>capacity</code> 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 <code>capacity</code> 为 16，扩容之后 <code>new capacity</code> 为 32：</p>
<pre><code class="lang-java">capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h2 id="与-Hashtable-的比较"><a href="#与-Hashtable-的比较" class="headerlink" title="与 Hashtable 的比较"></a>与 Hashtable 的比较</h2><ul>
<li><code>Hashtable</code> 使用 <code>synchronized</code> 来进行同步。</li>
<li><code>HashMap</code> 可以插入键为 <code>null</code> 的 <code>Entry</code>。</li>
<li><code>HashMap</code> 的迭代器是 fail-fast 迭代器。</li>
<li><code>HashMap</code> 不能保证随着时间的推移 <code>Map</code> 中的元素次序是不变的。</li>
</ul>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>待补充</p>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><pre><code class="lang-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {...}
</code></pre>
<p>继承自 <code>HashMap</code>，因此具有和 <code>HashMap</code> 一样的快速查找特性。</p>
<pre><code class="lang-java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
<p><code>Entry</code>类继承自<code>HashMap.Node</code>，可见内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre><code class="lang-java">// The head (eldest) of the doubly linked list.
transient LinkedHashMap.Entry&lt;K,V&gt; head;

// The tail (youngest) of the doubly linked list.
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p><code>accessOrder</code> 决定了顺序，默认为 <code>false</code>，此时维护的是插入顺序。显式设置为 true，代表以访问顺序进行迭代。</p>
<pre><code class="lang-java">final boolean accessOrder;Copy to clipboardErrorCopied
</code></pre>
<p><code>LinkedHashMap</code> 最重要的是以下用于维护顺序的函数，它们会在 <code>put()</code>、<code>get()</code> 等方法中调用。<code>LinkedHashMap</code>并没有覆写<code>put()</code>，而是覆写了<code>afterNodeAccess(Node&lt;K,V&gt; p)</code>。</p>
<pre><code class="lang-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre>
<h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h2><p>当一个节点被访问时，如果 <code>accessOrder</code> 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="lang-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h2 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h2><p>在 <code>put()</code> 等操作之后执行，当 <code>removeEldestEntry()</code> 方法返回 <code>true</code> 时会移除最晚的节点，也就是链表首部节点 <code>first</code>。<code>evict</code> 只有在构建 <code>Map</code> 的时候才为 <code>false</code>，在这里为 <code>true</code>。</p>
<pre><code class="lang-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}Copy to clipboardErrorCopied
</code></pre>
<p><code>removeEldestEntry()</code> 默认为 <code>false</code>，如果需要让它为 <code>true</code>，需要继承 <code>LinkedHashMap</code> 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="lang-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>
<h2 id="实现LRU缓存"><a href="#实现LRU缓存" class="headerlink" title="实现LRU缓存"></a>实现LRU缓存</h2><p>以下是使用 <code>LinkedHashMap</code> 实现的一个 LRU 缓存：</p>
<pre><code class="lang-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { // 继承自LinkedHashMap
    // 最大缓存空间MAX_ENTRIES，默认值为3
    private static final int MAX_ENTRIES = 3;

    // 覆写
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }

    // 初始化，将 accessOrder 设置为 true
    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
</code></pre>
<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>待补充</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration</code>：已被<code>Iterator</code>取代。</li>
</ul>
<p>Java的集合类定义在<code>java.util</code>包中，支持泛型。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
              
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/java/">java</a>
                
                  <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>
      </div>
    
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="vcomments" style="width: 90%; margin: 0 auto;"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script>
    var notify = 'false' === 'true';
    var verify = 'false' === 'true';
    var oldLoad = window.onload;
    window.onload = function () {
      new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
        app_key: "wqRfy95wLQRm4b7BByawaNCK",
        placeholder: "喂？",
        avatar: "/retro",
        meta: ['nick', 'mail', 'link'],
        pageSize: "10",
      });
      oldLoad && oldLoad();
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>



    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <b>2020</b>
    <i class="iconfont icon-love"></i>
    <b>lil-q</b>

    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      <span id="busuanzi_value_site_pv"></span>次访问 |
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      <span id="busuanzi_value_site_uv"></span>人来过
    </span>
    
  </div>


    

    <!-- cnzz Analytics icon -->
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>




  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var main = $('main');
      var tocT = navHeight + (toc.offset().top - main.offset().top);
      var tocLimMin = main.offset().top - navHeight;
      var tocLimMax = $('#comments').offset().top - navHeight;
      $(window).scroll(function () {
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;
        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': tocT,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java-Map&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
