<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>查并集(Union-find algorithm) - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/DSCF7878.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Thursday, January 2nd 2020, 12:54 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    2.2k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      9 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          
          <div class="markdown-body">
            <p>查并集的进化之路</p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p>
<ul>
<li>查找（Find）：确定某个元素处于哪个子集；</li>
<li>合并（Union）：将两个子集合并成一个集合。</li>
</ul>
<p>也就是说，不支持集合的分离、删除。</p>
<h1 id="Quick-Find算法"><a href="#Quick-Find算法" class="headerlink" title="Quick-Find算法"></a>Quick-Find算法</h1><p>以下图为例，连通关系为<code>[(1,2), (0, 1), (0, 3), (4, 7), (5, 6), (5, 7), (7, 8), (8, 9)]</code>。</p>
<p><img src="uf1.png" alt="uf"></p>
<p>首先初始化所有节点，认为它们属于一个组，因此不连通的节点必然就属于不同的组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>element</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>group number / id</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p>输入pair<code>(1, 2)</code>，则将<strong>所有</strong><code>group number</code>为<code>0</code>和<code>1</code>的<code>element</code>改为一致（都为<code>0</code>或都为<code>1</code>，这里以较小值为例）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>element</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>group number / id</td>
<td>0</td>
<td>1</td>
<td><strong>1</strong></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p>输入pair<code>(0， 1)</code>，这里就需要把<code>element 1</code>和<code>element 2</code>的<code>group number</code>都改为<code>0</code>，：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>element</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>group number / id</td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p>正因为每次都需要找到所有的特定<code>group number</code>的<code>element</code>，所以<code>union</code>的时间复杂度为O(N)，<code>find</code>的时间复杂度为O(1)。N为<code>element</code>的个数，下同。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickFind(object):
    id = []
    count = 0

    def __init__(self, n):
        self.count = n
        for i in range(n):
            self.id.append(i)

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p):    
        return self.id[p]

    def union(self, p, q):
        idp = self.find(p)
        idq = self.find(q)
        if idp != idq:
            for i in range(len(self.id)):
                if self.id[i] == idq: # 将q所在组内的所有节点的id都设为p的当前id
                    self.id[i] = idp
            self.count -= 1
</code></pre>
<h1 id="Quick-Union算法"><a href="#Quick-Union算法" class="headerlink" title="Quick-Union算法"></a>Quick-Union算法</h1><p>对于只需要实现查找和合并的并查集，O(n)的时间复杂度还是太高了，当时间复杂度需要降低到对数级，我们自然想到了<strong>树</strong>这个数据结构。由于并查集初始化中每一个<code>element</code>对于一个<code>group number</code>，所以可以通过数组中的跳转来实现树的寻找父节点功能。以下图为例，最开始每一个<code>element</code>的父节点都是自身，每次查找沿着父节点向上， 直到根节点。每次合并把找到的两个根节点的其中一个设置为另一个的父节点。</p>
<p><img src="1339479431_6633.png" alt="qu"></p>
<p><code>union</code>和<code>find</code>的时间复杂度取决于树的高度。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class QuickUnion(object):
    id = []
    count = 0

    def __init__(self, n):
        self.count = n
        for i in range(n):
            self.id.append(i)

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p):    
        while (p != self.id[p]):
            p = self.id[p]
        return p

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p != root_q:
            self.id[root_q] = root_p
            self.count -= 1
</code></pre>
<p><em>注意：此时<code>self.id</code>存放的不再是每个元素的组别而是父节点。</em></p>
<h1 id="Weighted-Quick-Union-算法"><a href="#Weighted-Quick-Union-算法" class="headerlink" title="Weighted Quick-Union 算法"></a>Weighted Quick-Union 算法</h1><p>既然采用了<strong>树</strong>的结构，就有可能出现极端情况，是的树操作的时间复杂度退化成O(N)。为了避免这种情况，常规方法是使用平衡树，而对于并查集，只需要在<code>union</code>时，选择将小的树合并到大树上就可以了。</p>
<p><img src="1339479587_5986.png" alt="wqu"></p>
<p>理论上在平衡树合并两个树时，应当用根的高度来衡量两个树的大小，但是这里使用根节点的子孙节点的数量来衡量，<code>union</code>和<code>find</code>的时间复杂度接近于O(log  N)。这是因为这个方法还可以优化，通过路径压缩可以将<code>union</code>和<code>find</code>的时间复杂度降低至O(1)，而这样做会改变根的高度。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">class WeightedQuickUnion(object):
    id = []
    count = 0
    sz = []

    def __init__(self, n):
        self.count = n
        for i in range(n):
            self.id.append(i)
            self.sz.append(1) # inital size of each tree is 1

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p):   
        while (p != self.id[p]):
            p = self.id[p]
        return p

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p != root_q:
            if self.sz[root_p] &lt; self.sz[root_q]:
                self.id[root_p] = root_q
                self.sz[root_q] += self.sz[root_p]
            else:
                self.id[root_q] = root_p
                self.sz[root_p] += self.sz[root_q]               
            self.count -=1
</code></pre>
<p>输出<code>self.sz</code>可以看到<code>id = 1</code>和<code>id = 5</code>的组别包含了所有元素，<code>id = 4</code>组中的<code>(4, 7)</code>实际上已经移动到<code>id = 5</code>组中。</p>
<pre><code class="lang-python">size:  [1, 4, 1, 1, 2, 6, 1, 1, 1, 1]
</code></pre>
<h1 id="Weighted-Quick-Union-With-Path-Compression-算法"><a href="#Weighted-Quick-Union-With-Path-Compression-算法" class="headerlink" title="Weighted Quick-Union With Path Compression 算法"></a>Weighted Quick-Union With Path Compression 算法</h1><p>第一种方法是在<code>find</code>方法的执行过程中保存所有路过的中间节点到一个数组中，然后在<code>while</code>循环结束之后，将这些中间节点的父节点指向根节点。但是这个方法在<code>find</code>操作很频繁时会频繁生成中间节点数组，相应的分配销毁的时间自然就上升了。另一种方法是在寻找<code>q</code>的根节点的同时不断改变父节点，相当于在寻找根节点的同时，不断地将<code>q</code>移动到上一级的节点下，对路径进行了压缩，使整个树结构扁平化。相应的实现如下，实际上只需要在<code>find</code>方法中添加一行代码。</p>
<pre><code class="lang-python">def find(self, p):   
        while (p != self.id[p]):
            self.id[p] = self.id[self.id[p]]
            p = self.id[p]
        return p
</code></pre>
<p>这样<code>self.id</code>中保存的既是个元素的组别又是各元素的父节点，正因为如此<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。</p>
<pre><code class="lang-python">final parent/id list is 1,1,1,1,5,5,5,5,5,5
</code></pre>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="leetcode-200-岛屿数量"><a href="#leetcode-200-岛屿数量" class="headerlink" title="leetcode 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode 200. 岛屿数量</a></h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<pre><code class="lang-python">输入:   1 1 1 1 0      ====&gt;     输出: 1  
        1 1 0 1 0      
        1 1 0 0 0
        1 0 0 0 0
</code></pre>
<p>简单应用<a href="https://lil-q.github.io/2020/01/02/查并集-union-find-algorithm/#Quick-Union算法" target="_blank" rel="noopener">Quick-Union算法</a>即可，用<code>dict</code>代替<code>list</code>。</p>
<pre><code class="lang-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        if not grid or not grid[0]:
            return 0 

        row = len(grid)
        col = len(grid[0])

        def find(x):
            f.setdefault(x, x)
            while f[x] != x:
                x = f[x]
            return x

        def union(x, y):
            rootx = find(x)
            rooty = find(y)
            if rootx != rooty:
                f[rootx] = rooty
                return 1
            return 0

        s = 0
        f = {}
        for i in range(row):
            for j in range(col):
                if grid[i][j] == &#39;1&#39;:
                    s += 1
                    for x, y in ((1, 0), (0, 1)):
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &#39;1&#39;:
                            # 如果需要合并那么总岛屿数就减一，不需要合并则不变（减零）
                            s -= union((i, j), (tmp_i, tmp_j))

        return s
</code></pre>
<h2 id="leetcode-684-冗余连接"><a href="#leetcode-684-冗余连接" class="headerlink" title="leetcode 684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">leetcode 684. 冗余连接</a></h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<pre><code>输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
</code></pre><p>遍历所有的边，<code>union</code>所有边的两个顶点，如果出现两个顶点已经连接的情况，说明已经构成换，删掉这条边即可。实现如下：</p>
<pre><code class="lang-python">class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:

        def find(x):
            f.setdefault(x,x)
            while x != f[x]:
                f[x] = f[f[x]]
                x = f[x]
            return x

        def union(x, y):
            rootx = find(x)
            rooty = find(y)
            if rootx != rooty:
                f[rootx] = rooty
                return 1
            return 0

        f = {}
        for x, y in edges:
            if not union(x, y): return[x, y]
</code></pre>
<h2 id="leetcode-685-冗余连接-II"><a href="#leetcode-685-冗余连接-II" class="headerlink" title="leetcode 685. 冗余连接 II"></a><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">leetcode 685. 冗余连接 II</a></h2><h2 id="leetcode-803-打砖块"><a href="#leetcode-803-打砖块" class="headerlink" title="leetcode 803. 打砖块"></a><a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">leetcode 803. 打砖块</a></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着一步步地深入，我们最终将查并集<code>union</code>和<code>find</code>的时间复杂度降低到了O(1)。本文中的四种算法的时间复杂度如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Algorithm</strong></th>
<th style="text-align:center"><strong>Constructor</strong></th>
<th style="text-align:center"><strong>Union</strong></th>
<th style="text-align:center"><strong>Find</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Quick-Find</strong></td>
<td style="text-align:center">N</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><strong>Quick-Union</strong></td>
<td style="text-align:center">N</td>
<td style="text-align:center">Tree height</td>
<td style="text-align:center">Tree height</td>
</tr>
<tr>
<td style="text-align:center"><strong>Weighted Quick-Union</strong></td>
<td style="text-align:center">N</td>
<td style="text-align:center">near to O(log N)</td>
<td style="text-align:center">near to O(log N)</td>
</tr>
<tr>
<td style="text-align:center"><strong>Weighted Quick-Union With Path Compression</strong></td>
<td style="text-align:center">N</td>
<td style="text-align:center">Very near to O(1)</td>
<td style="text-align:center">Very near to O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意<code>Path Compression</code>是将各节点压缩到根节点下，所以<code>Weighted</code>仍然有意义。当然如果还需要输出连通路径，这个方法是没办法实现的，需要BFS或DFS算法来实现。</p>
<p><a href="https://github.com/lil-q/data-structures-python/tree/master/Union-Find" target="_blank" rel="noopener">完整测试代码地址</a></p>
<p><p align="right"><u><i>错误与不足请不吝指正，转载请注明，谢谢</i></u></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/Guo15331092/article/details/78702686" target="_blank" rel="noopener">https://blog.csdn.net/Guo15331092/article/details/78702686</a></li>
<li><a href="https://www.jianshu.com/p/72da76a34db1" target="_blank" rel="noopener">https://www.jianshu.com/p/72da76a34db1</a></li>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/7655764</a></li>
</ol>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
              
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/python/">python</a>
                
                  <a class="hover-with-bg" href="/tags/%E6%9F%A5%E5%B9%B6%E9%9B%86/">查并集</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>
      </div>
    
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="vcomments" style="width: 90%; margin: 0 auto;"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script>
    var notify = 'false' === 'true';
    var verify = 'false' === 'true';
    var oldLoad = window.onload;
    window.onload = function () {
      new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
        app_key: "wqRfy95wLQRm4b7BByawaNCK",
        placeholder: "喂？",
        avatar: "/retro",
        meta: ['nick', 'mail', 'link'],
        pageSize: "10",
      });
      oldLoad && oldLoad();
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>



    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>

    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      <span id="busuanzi_value_site_pv"></span>次访问 |
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      <span id="busuanzi_value_site_uv"></span>人来过
    </span>
    
  </div>


    

    <!-- cnzz Analytics icon -->
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>




  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var main = $('main');
      var tocT = navHeight + (toc.offset().top - main.offset().top);
      var tocLimMin = main.offset().top - navHeight;
      var tocLimMax = $('#comments').offset().top - navHeight;
      $(window).scroll(function () {
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;
        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': tocT,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "查并集(Union-find algorithm)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
