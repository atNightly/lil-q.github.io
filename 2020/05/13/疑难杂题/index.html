<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#111">
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>疑难杂题 - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


  <script  src="/js/utils.js" ></script>
</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/usbizhi.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-05-13 19:54">
      May 13, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>整理一些难度较大或者十分有趣的题目。</p>
<a id="more"></a>
<h1 id="nowcoder-整理房间"><a href="#nowcoder-整理房间" class="headerlink" title="nowcoder 整理房间"></a><a href="https://www.nowcoder.com/practice/c32f4c74446541a1ad2abbe54476681f?tpId=98&amp;tqId=32835&amp;tPage=1&amp;rp=1&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">nowcoder 整理房间</a></h1><p>不难但是很全面的一题：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-comment">// 创建一个 Point 类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">int</span> b;
    <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">int</span> y;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.a = a;
        <span class="hljs-keyword">this</span>.b = b;
        <span class="hljs-keyword">this</span>.x = x;
        <span class="hljs-keyword">this</span>.y = y;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
        <span class="hljs-keyword">int</span> n = Integer.parseInt(br.readLine());
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            Point[] p = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">4</span>]; <span class="hljs-comment">// 用 p 来存放四个点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;
                String[] line = br.readLine().split(<span class="hljs-string">" "</span>);
                p[j] = <span class="hljs-keyword">new</span> Point(Integer.parseInt(line[<span class="hljs-number">0</span>]),
                                 Integer.parseInt(line[<span class="hljs-number">1</span>]),
                                 Integer.parseInt(line[<span class="hljs-number">2</span>]),
                                 Integer.parseInt(line[<span class="hljs-number">3</span>]));
            &#125;
            sb.append(minMove(p)).append(<span class="hljs-string">"\n"</span>);
        &#125;
        System.out.print(sb);
        br.close(); <span class="hljs-comment">// 关闭 io</span>
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMove</span><span class="hljs-params">(Point[] p)</span> </span>&#123;
        <span class="hljs-keyword">int</span> move = <span class="hljs-number">16</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;
            rotate(p[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">4</span>; j++) &#123;
                rotate(p[<span class="hljs-number">1</span>]);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">4</span>; k++) &#123;
                    rotate(p[<span class="hljs-number">2</span>]);
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= <span class="hljs-number">4</span>; v++) &#123;
                        rotate(p[<span class="hljs-number">3</span>]);
                        <span class="hljs-keyword">if</span> (isSquare(p)) &#123;
                            move = Math.min(move, i%<span class="hljs-number">4</span> + j%<span class="hljs-number">4</span> + k%<span class="hljs-number">4</span> + v%<span class="hljs-number">4</span>);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> move == <span class="hljs-number">16</span> ? -<span class="hljs-number">1</span> : move;
    &#125;
    
    <span class="hljs-comment">// 原地修改</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(Point point)</span> </span>&#123;
        <span class="hljs-keyword">int</span> tmp = point.a;
        point.a = point.x + point.y - point.b;
        point.b = point.y - point.x + tmp;
    &#125;
    
    <span class="hljs-comment">// 找最长的边长和最短的边长，前者出现两次，后者出现四次且不为 0 ，则正方形成立</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSquare</span><span class="hljs-params">(Point[] p)</span> </span>&#123;
        <span class="hljs-keyword">long</span> min = Long.MAX_VALUE, max = Long.MIN_VALUE;
        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;
                <span class="hljs-keyword">long</span> dis = distance(p[i], p[j]);
                <span class="hljs-keyword">if</span> (dis &gt; max) &#123; max = dis; count1 = <span class="hljs-number">1</span>; &#125;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis == max) count1++;
                <span class="hljs-keyword">if</span> (dis &lt; min) &#123; min = dis; count2 = <span class="hljs-number">1</span>; &#125;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis == min) count2++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> count1 == <span class="hljs-number">2</span> &amp;&amp; count2 == <span class="hljs-number">4</span> &amp;&amp; min != <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-comment">// 注意使用 long 类型防止溢出</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">distance</span><span class="hljs-params">(Point p1, Point p2)</span> </span>&#123;
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>) (p1.a - p2.a) * (p1.a - p2.a) 
                     + (p1.b - p2.b) * (p1.b - p2.b));
    &#125;
&#125;</code></pre></div>
<h1 id="nowcoder-小易的字典"><a href="#nowcoder-小易的字典" class="headerlink" title="nowcoder 小易的字典"></a><a href="https://www.nowcoder.com/practice/12b1b8ef17e1441f86f322b250bff4c0?tpId=98&amp;tqId=32838&amp;tPage=1&amp;rp=1&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">nowcoder 小易的字典</a></h1><p>类似于康托展开的思路，不过这里要求的是组合数。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
        String[] line = br.readLine().split(<span class="hljs-string">" "</span>);
        <span class="hljs-keyword">int</span> n = Integer.parseInt(line[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">int</span> m = Integer.parseInt(line[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">int</span> k = Integer.parseInt(line[<span class="hljs-number">2</span>]);
        <span class="hljs-comment">// 特判</span>
        <span class="hljs-keyword">if</span> (k &gt; combination(n, n + m, k)) &#123;
            System.out.print(-<span class="hljs-number">1</span> + <span class="hljs-string">""</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; m &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 开头为 a 的组合数</span>
            <span class="hljs-keyword">long</span> c = combination(n - <span class="hljs-number">1</span>, n + m - <span class="hljs-number">1</span>, k);
            <span class="hljs-keyword">if</span> (k &gt; c) &#123; <span class="hljs-comment">// 大于则以 z 开头</span>
                sb.append(<span class="hljs-string">"z"</span>);
                k -= c;
                m--;
            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 小于则以 a 开头</span>
                sb.append(<span class="hljs-string">"a"</span>); 
                n--;
            &#125;
        &#125;
        <span class="hljs-comment">// 结尾处理</span>
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) sb.append(<span class="hljs-string">"a"</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">while</span> (m-- &gt; <span class="hljs-number">0</span>) sb.append(<span class="hljs-string">"z"</span>);
        &#125;
        System.out.print(sb);
    &#125;
    
    <span class="hljs-comment">// 求组合数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">combination</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
        <span class="hljs-keyword">long</span> c = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            c *= m - i;
            c /= i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (c &gt; k) <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">return</span> c;
    &#125;
&#125;</code></pre></div>
<h1 id="leetcode-42-接雨水"><a href="#leetcode-42-接雨水" class="headerlink" title="leetcode 42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">leetcode 42. 接雨水</a></h1><p><strong>解法一：两遍扫描</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = height.length;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>[] l2r = height.clone();
        <span class="hljs-keyword">int</span>[] r2l = height.clone();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
            l2r[i] = Math.max(l2r[i - <span class="hljs-number">1</span>], height[i]);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            r2l[i] = Math.max(r2l[i + <span class="hljs-number">1</span>], height[i]);
        &#125;
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            sum += Math.min(l2r[i], r2l[i]) - height[i];
        &#125;
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre></div>
<p><strong>解法二：双指针——按列</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> left_max = <span class="hljs-number">0</span>, right_max = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (l &lt; r) &#123;
            <span class="hljs-keyword">if</span> (height[l] &lt; height[r]) &#123;
                left_max = Math.max(left_max, height[l]);
                sum += left_max - height[l];
                l++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                right_max = Math.max(right_max, height[r]);
                sum += right_max - height[r];
                r--;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre></div>
<p><strong>解法三：双指针——按行</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = height.length;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>, h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;
            <span class="hljs-keyword">if</span> (height[l] &lt; height[r]) &#123;
                <span class="hljs-keyword">if</span> (height[l] &gt; h) &#123;
                    sum += (height[l] - h) * (r - l + <span class="hljs-number">1</span>);
                    h = height[l];
                &#125;
                l++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (height[r] &gt; h) &#123;
                    sum += (height[r] - h) * (r - l + <span class="hljs-number">1</span>);
                    h = height[r];
                &#125;
                r--;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) sum -= height[i];
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre></div>
<p><strong>解法四：单调栈</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;
        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; height.length; r++) &#123;
            Integer l, m; <span class="hljs-comment">// l: 水洼的左边界，m 水洼的底，r 水洼的右边界</span>
            <span class="hljs-keyword">while</span> ((m = stack.peek()) != <span class="hljs-keyword">null</span> &amp;&amp; height[m] &lt; height[r]) &#123;
                stack.pop();
                <span class="hljs-comment">// 左边界不存在或者左边界和底同高，则跳过</span>
                <span class="hljs-keyword">if</span> ((l = stack.peek()) == <span class="hljs-keyword">null</span> || height[l] == height[m]) <span class="hljs-keyword">continue</span>;
                <span class="hljs-comment">// 注意长度为 r - l - 1, 不包括边界</span>
                sum += (Math.min(height[l], height[r]) - height[m]) * (r - l - <span class="hljs-number">1</span>);
            &#125;
            stack.push(r);
        &#125;
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre></div>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="leetcode-739-每日温度"><a href="#leetcode-739-每日温度" class="headerlink" title="leetcode 739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">leetcode 739. 每日温度</a></h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;
        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T.length; i++) &#123;
            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; T[stack.peek()] &lt; T[i]) &#123;
                res[stack.peek()] = i - stack.pop();
            &#125;
            stack.push(i);
        &#125;
        <span class="hljs-comment">//while (!stack.isEmpty()) res[stack.pop()] = 0;</span>
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;

<span class="hljs-comment">// 同样的思路，可以从后往前遍历，利用res数组跳跃检查(j += res[j])</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = T.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; T.length; j += res[j]) &#123;
                <span class="hljs-keyword">if</span> (T[i] &lt; T[j]) &#123;
                    res[i] = j - i;
                    <span class="hljs-keyword">break</span>;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[j] == <span class="hljs-number">0</span>) &#123;
                    res[i] = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h1><h2 id="剑指offer-面试题39-数组中出现次数超过一半的数字"><a href="#剑指offer-面试题39-数组中出现次数超过一半的数字" class="headerlink" title="剑指offer 面试题39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer 面试题39. 数组中出现次数超过一半的数字</a></h2><p>实际上也是利用了栈的思路，把不相同的两两一对消除，剩下的就是数量大于一般的数了。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>], flag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;
            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) res = num;
            flag += num == res ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="N数和问题"><a href="#N数和问题" class="headerlink" title="N数和问题"></a>N数和问题</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">leetcode 1. 两数之和</a></h2><p>利用 Map 将复杂度从<script type="math/tex">O(n^2)</script>降低至<script type="math/tex">O(n)</script>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;
        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) 
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;
            map.put(nums[i], i);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    &#125;
&#125;</code></pre></div>
<h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">leetcode 15. 三数之和</a></h2><p>利用双指针将复杂度从<script type="math/tex">O(n^3)</script>降低至<script type="math/tex">O(n^2)</script>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;
        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        Arrays.sort(nums); <span class="hljs-comment">// 排序以利用双指针</span>
        <span class="hljs-keyword">int</span> n = nums.length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复解</span>
            <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) &#123;
                <span class="hljs-keyword">int</span> sum = nums[i] + nums[l] + nums[r];
                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) r--;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) l++;
                <span class="hljs-keyword">else</span> &#123;
                    res.add(List.of(nums[i], nums[l], nums[r]));
                    <span class="hljs-keyword">while</span> (++l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 去除重复解</span>
                    <span class="hljs-keyword">while</span> (l &lt; --r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 去除重复解</span>
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<p><code>Arrays.asList()</code>和<code>List.of()</code>区别：<a href="https://stackoverflow.com/questions/46579074/what-is-the-difference-between-list-of-and-arrays-aslist" target="_blank" rel="noopener">What is the difference between List.of and Arrays.asList?</a></p>
<h2 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">leetcode 18. 四数之和</a></h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;
        Arrays.sort(nums); <span class="hljs-comment">// 排序以利用双指针</span>
        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">int</span> n = nums.length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复解</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) &#123;
                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复解</span>
                <span class="hljs-keyword">int</span> sum = nums[i] + nums[j];
                <span class="hljs-keyword">int</span> l = j + <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (l &lt; r) &#123;
                    <span class="hljs-keyword">int</span> tmp = sum + nums[l] + nums[r];
                    <span class="hljs-keyword">if</span> (tmp &lt; target) l++;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &gt; target) r--;
                    <span class="hljs-keyword">else</span> &#123;
                        res.add(List.of(nums[i], nums[j], nums[l], nums[r]));
                        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]); <span class="hljs-comment">// 去除重复解</span>
                        <span class="hljs-keyword">while</span> (r &gt; l &amp;&amp; nums[r] == nums[--r]); <span class="hljs-comment">// 去除重复解</span>
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h2 id="leetcode-454-四数相加-II"><a href="#leetcode-454-四数相加-II" class="headerlink" title="leetcode 454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">leetcode 454. 四数相加 II</a></h2><p>利用 Map 将复杂度从<script type="math/tex">O(n^4)</script>降低至<script type="math/tex">O(n^2)</script>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B, <span class="hljs-keyword">int</span>[] C, <span class="hljs-keyword">int</span>[] D)</span> </span>&#123;
        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, n = A.length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
                map.put(A[i] + B[j], map.getOrDefault(A[i] + B[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
                res += map.getOrDefault(-C[i] - D[j], <span class="hljs-number">0</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="前缀和与线段树"><a href="#前缀和与线段树" class="headerlink" title="前缀和与线段树"></a>前缀和与线段树</h1><h2 id="leetcode-560-和为K的子数组"><a href="#leetcode-560-和为K的子数组" class="headerlink" title="leetcode 560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">leetcode 560. 和为K的子数组</a></h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的<strong>连续</strong>的子数组的个数。</p>
<p>每扫描一个数就将这个数之前的所有数之和存进哈希表，称之为前缀和。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;
            sum += num;
            <span class="hljs-keyword">if</span> (map.containsKey(sum - k)) res += map.get(sum - k); <span class="hljs-comment">// 提取前缀和</span>
            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 计数前缀和</span>
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h2 id="leetcode-307-区域和检索-数组可修改"><a href="#leetcode-307-区域和检索-数组可修改" class="headerlink" title="leetcode 307. 区域和检索 - 数组可修改"></a><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">leetcode 307. 区域和检索 - 数组可修改</a></h2><p>前缀和并不是万能的，当需要修改数组时，修改操作的复杂度由<script type="math/tex">O(1)</script>提高至<script type="math/tex">O(n)</script>。</p>
<p>使用线段树可以把检索和修改的时间复杂度都保持在<script type="math/tex">O(log n)</script>，以保证在检索和修改次数较为均衡的情况下，能够保持良好的效率。线段树类似堆树，利用数组作为数据结构：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] na;
    <span class="hljs-keyword">int</span> n;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        n = nums.length;
        na = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span> * n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++, j++) &#123;
            na[i] = nums[j]; <span class="hljs-comment">// 叶子节点</span>
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;
            na[i] = na[<span class="hljs-number">2</span> * i] + na[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 非叶子结点，0 闲置</span>
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val)</span> </span>&#123;
        i = i + n;
        na[i] = val;
        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">int</span> left = i;
            <span class="hljs-keyword">int</span> right = i;
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;
                right = i + <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                left = i - <span class="hljs-number">1</span>;
            &#125;
            na[i / <span class="hljs-number">2</span>] = na[left] + na[right];
            i /= <span class="hljs-number">2</span>;
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        i += n;
        j += n;
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) sum += na[i++]; <span class="hljs-comment">// 左边界为父节点的右子节点</span>
            <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) sum += na[j--]; <span class="hljs-comment">// 右边界为父节点的左子节点</span>
            i /= <span class="hljs-number">2</span>;
            j /= <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre></div>
<h2 id="nowcoder-善变的同伴"><a href="#nowcoder-善变的同伴" class="headerlink" title="nowcoder 善变的同伴"></a><a href="https://www.nowcoder.com/practice/824af5cb05794606b56657bb3fa91f49?tpId=98&amp;tqId=32843&amp;tPage=1&amp;rp=1&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">nowcoder 善变的同伴</a></h2><p>有时候对数组做累加操作再处理会带来便利，这题使用类似股票问题的动态规划会超时，计算前缀和，再利用极小值和极大值的特性可以在<script type="math/tex">O(n)</script>完成：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-comment">/*                    t3 (t3 &gt; t2, 合并 b2 至 t3, 合并后如果次数还有多，
*        t1           /\  就要把合并损失的还回去，记录栈内所有 bi-1 - ti)        
*   t0   /\     t2   /
*    \  /  \    /\  /
*     \/    \  /  \/
*     b1     \/   b3
*            b2 (b2 &lt; b1, 截断 t1 至 b2部分，因为这段负数影响已经大于之前的总和，
*                记录栈内所有 ti - bi)
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
        String[] line = br.readLine().split(<span class="hljs-string">" "</span>);
        <span class="hljs-keyword">int</span> N = Integer.parseInt(line[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">int</span> M = Integer.parseInt(line[<span class="hljs-number">1</span>]);
        line = br.readLine().split(<span class="hljs-string">" "</span>);
        <span class="hljs-keyword">int</span>[] dish = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;
            dish[i] = dish[i - <span class="hljs-number">1</span>] + Integer.parseInt(line[i - <span class="hljs-number">1</span>]);
        &#125;
        
        PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((n1, n2)-&gt; n2 - n1);
        Deque&lt;Integer&gt; bs = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        Deque&lt;Integer&gt; ts = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">int</span> n = N + <span class="hljs-number">1</span>, b, t = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (t &lt; n) &#123;
            <span class="hljs-comment">// 找极小值</span>
            <span class="hljs-keyword">for</span> (b = t; b &lt; n - <span class="hljs-number">1</span> &amp;&amp; dish[b + <span class="hljs-number">1</span>] &lt;= dish[b]; b++) &#123;&#125;
            <span class="hljs-comment">// 找极大值</span>
            <span class="hljs-keyword">for</span> (t = b + <span class="hljs-number">1</span>; t &lt; n &amp;&amp; dish[t - <span class="hljs-number">1</span>] &lt;= dish[t]; t++) &#123;&#125;
            <span class="hljs-comment">// 截断情况</span>
            <span class="hljs-keyword">while</span> (!bs.isEmpty() &amp;&amp; dish[b] &lt; dish[bs.peek()]) &#123;
                maxHeap.add(dish[ts.pop() - <span class="hljs-number">1</span>] - dish[bs.pop()]);
            &#125;
            <span class="hljs-comment">// 合并情况</span>
            <span class="hljs-keyword">while</span> (!ts.isEmpty() &amp;&amp; dish[t - <span class="hljs-number">1</span>] &gt; dish[ts.peek() - <span class="hljs-number">1</span>]) &#123;
                maxHeap.add(dish[ts.pop() - <span class="hljs-number">1</span>] - dish[b]);
                b = bs.pop();
            &#125;
            <span class="hljs-comment">// 入栈</span>
            bs.push(b);
            ts.push(t);
        &#125;
        <span class="hljs-comment">// 处理余下部分</span>
        <span class="hljs-keyword">while</span> (!bs.isEmpty()) &#123;
            maxHeap.add(dish[ts.pop() - <span class="hljs-number">1</span>] - dish[bs.pop()]);
        &#125;
        
        <span class="hljs-keyword">while</span> (M-- &gt; <span class="hljs-number">0</span> &amp;&amp; !maxHeap.isEmpty()) &#123;
            res += maxHeap.poll();
        &#125;
        System.out.println(res);
    &#125;
&#125;</code></pre></div>
<h1 id="nowcoder-鸡鸭分类问题"><a href="#nowcoder-鸡鸭分类问题" class="headerlink" title="nowcoder 鸡鸭分类问题"></a><a href="https://www.nowcoder.com/practice/f87616abbac44842b43f24ddd3cf49e8?tpId=98&amp;tqId=32861&amp;tPage=2&amp;rp=2&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">nowcoder 鸡鸭分类问题</a></h1><p>所谓交换就是移动一次，所以只要求所有鸡和鸭移动到前端共用次数中较小的一个：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
        <span class="hljs-keyword">char</span>[] CD = br.readLine().toCharArray();
        <span class="hljs-keyword">int</span> C = <span class="hljs-number">0</span>, D = <span class="hljs-number">0</span>, cc = <span class="hljs-number">0</span>, dc = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; CD.length; i++) &#123;
            <span class="hljs-keyword">if</span> (CD[i] == <span class="hljs-string">'C'</span>) &#123;
                C += i - cc;
                cc++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                D += i - dc;
                dc++;
            &#125;
        &#125;
        System.out.println(Math.min(C, D));
    &#125;
&#125;</code></pre></div>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="leetcode-76-最小覆盖子串"><a href="#leetcode-76-最小覆盖子串" class="headerlink" title="leetcode 76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">leetcode 76. 最小覆盖子串</a></h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;
        <span class="hljs-comment">// map 记录 t 组成</span>
        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : t.toCharArray()) &#123;
            map.put(ch, map.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-comment">// count 记录还未完成的组分</span>
        <span class="hljs-keyword">int</span> count = map.size();
        <span class="hljs-comment">// 滑动窗口的左右边界</span>
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, minLen = s.length() + <span class="hljs-number">1</span>;
        String res = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">char</span>[] sa = s.toCharArray();
        <span class="hljs-comment">// 注意窗口是左开右闭的</span>
        <span class="hljs-keyword">while</span> (r &lt; s.length() || r == s.length() &amp;&amp; count == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 窗口内各组分都已经完成，则右移左边界</span>
                <span class="hljs-keyword">if</span> (r - l &lt; minLen) &#123;
                    res = s.substring(l, r);
                    minLen = r - l;
                &#125;
                <span class="hljs-keyword">if</span> (map.containsKey(sa[l])) &#123;
                    map.put(sa[l], map.get(sa[l]) + <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">if</span> (map.get(sa[l]) == <span class="hljs-number">1</span>)
                        count++;
                &#125;
                l++;
            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未完成，则右移右边界</span>
                <span class="hljs-keyword">if</span> (map.containsKey(sa[r])) &#123;
                    map.put(sa[r], map.get(sa[r]) - <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">if</span> (map.get(sa[r]) == <span class="hljs-number">0</span>)
                        count--;
                &#125;
                r++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="leetcode-287-寻找重复数"><a href="#leetcode-287-寻找重复数" class="headerlink" title="leetcode 287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">leetcode 287. 寻找重复数</a></h1><p><strong>解法一：将数组转化为链表</strong></p>
<p>由于这个数组没有 0 这个值，所以 0 结点的入度为 0，必定不成环。可以看出 0 为 head 的一个链表，求其环入口。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> slow = nums[<span class="hljs-number">0</span>], fast = nums[nums[<span class="hljs-number">0</span>]];
        <span class="hljs-keyword">while</span> (slow != fast) &#123;
            slow = nums[slow];
            fast = nums[nums[fast]];
        &#125;
        fast = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (slow != fast) &#123;
            slow = nums[slow];
            fast = nums[fast];
        &#125;
        <span class="hljs-keyword">return</span> slow;
    &#125;
&#125;</code></pre></div>
<p><strong>解法二：二分查找</strong></p>
<p>利用抽屉原理的思想。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt; r) &#123;
            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>, count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;
                <span class="hljs-keyword">if</span> (num &lt;= mid) count++;
            &#125;
            <span class="hljs-keyword">if</span> (count &gt; mid) r = mid; <span class="hljs-comment">// 计数大于 mid，区间为[l，mid]</span>
            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计数小于等于 mid，区间为[mid + 1, r]</span>
        &#125;
        <span class="hljs-keyword">return</span> l;
    &#125;
&#125;</code></pre></div>
<h1 id="leetcode-233-数字-1-的个数"><a href="#leetcode-233-数字-1-的个数" class="headerlink" title="leetcode 233. 数字 1 的个数"></a><a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">leetcode 233. 数字 1 的个数</a></h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i *= <span class="hljs-number">10</span>) &#123;
            <span class="hljs-keyword">long</span> divider = i * <span class="hljs-number">10</span>;
            <span class="hljs-comment">/* 以315，第二次循环（第二位1）为例，此时i = 10，divider = 100:
            *  1. (n / divider) * i 很好理解，就是300以内第二位出现1的次数,
            *     共3 * 10 = 30次(010-019，110-119，210-219).
            *  2. 所以加号后面就是300以后第二位出现1的次数，可以得到以下公式:
            *     if n % divider &lt; i 得 0;
            *     if 10 &lt;= n % divider &lt; 20 得 n % divider - i + 1;
            *     if 2 * i &lt;= n % divider 得 i.
            *     min(i, max(0, _)) 实现对0和i的截断, 这里就是 15 - 10 + 1 = 6.
            */</span>
            res += (n / divider) * i + Math.min(i, Math.max(<span class="hljs-number">0</span>, n % divider - i + <span class="hljs-number">1</span>));
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h1><p><strong>手写快排</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        String[] ns = <span class="hljs-keyword">new</span> String[nums.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            ns[i] = nums[i] + <span class="hljs-string">""</span>;
        &#125;
        fastSort(ns, <span class="hljs-number">0</span>, ns.length - <span class="hljs-number">1</span>);
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            sb.append(ns[i]);
        &#125;
        <span class="hljs-keyword">return</span> sb.toString();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastSort</span><span class="hljs-params">(String[] ns, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;
        String mid = ns[l];
        <span class="hljs-keyword">int</span> lo = l, hi = r;
        <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;
            <span class="hljs-keyword">while</span> (lo &lt; hi &amp;&amp; (ns[hi] + mid).compareTo(mid + ns[hi]) &gt;= <span class="hljs-number">0</span>) hi--;
            ns[lo] = ns[hi];
            <span class="hljs-keyword">while</span> (lo &lt; hi &amp;&amp; (ns[lo] + mid).compareTo(mid + ns[lo]) &lt;= <span class="hljs-number">0</span>) lo++;
            ns[hi] = ns[lo];
        &#125;
        ns[lo] = mid;
        fastSort(ns, l, lo - <span class="hljs-number">1</span>);
        fastSort(ns, lo + <span class="hljs-number">1</span>, r);
    &#125;
&#125;</code></pre></div>
<p><strong>库函数传入比较器</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        String[] ns = <span class="hljs-keyword">new</span> String[nums.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            ns[i] = nums[i] + <span class="hljs-string">""</span>;
        &#125;
        Arrays.sort(ns, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            sb.append(ns[i]);
        &#125;
        <span class="hljs-keyword">return</span> sb.toString();
    &#125;
&#125;</code></pre></div>
<h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><h2 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 62. 圆圈中最后剩下的数字</a></h2><p><strong>递归</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;
        <span class="hljs-keyword">return</span> func(n, m);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> x = func(n - <span class="hljs-number">1</span>, m);
        <span class="hljs-keyword">return</span> (m + x) % n;
    &#125;
&#125;</code></pre></div>
<p><strong>迭代</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
            x = (m + x) % i;
        &#125;
        <span class="hljs-keyword">return</span> x;
    &#125;
&#125;</code></pre></div>
<h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h1><p><strong>解法一：最小堆</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;
        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
        PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;
            minHeap.offer(num);
        &#125;
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) res[i] = minHeap.poll();
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<p><strong>解法二：优化快排</strong></p>
<p>并不需要整个数组进行排序，只需要递归<code>k - 1</code>坐标所在的区域，当基准值位于<code>k - 1</code>位置时就可以停止递归了。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;
        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
        fastSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> Arrays.copyOf(arr, k);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fastSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> lo = l, hi = r, p = arr[l];
        <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;
            <span class="hljs-keyword">while</span> (lo &lt; hi &amp;&amp; arr[hi] &gt; p) hi--;
            arr[lo] = arr[hi];
            <span class="hljs-keyword">while</span> (lo &lt; hi &amp;&amp; arr[lo] &lt;= p) lo++;
            arr[hi] = arr[lo]; 
        &#125;
        arr[lo] = p;
        <span class="hljs-comment">// 注意</span>
        <span class="hljs-keyword">if</span> (lo &lt; k) fastSort(arr, lo + <span class="hljs-number">1</span>, r, k);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lo &gt; k) fastSort(arr, l, lo - <span class="hljs-number">1</span>, k);
    &#125;
&#125;</code></pre></div>
<p><strong>解法三：计数排序</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;
        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10001</span>], res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) count[num]++;
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;
            k -= count[num];
            <span class="hljs-keyword">while</span> (count[num]-- &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; res.length) &#123;
                res[index++] = num;
            &#125;
            num++;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre></div>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a></h2><p>这里需要用<strong>最大堆保持较小值部分的数，用最小堆保持较大值部分的数</strong>，这样就可以实时查看中位数。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;
    Queue&lt;Integer&gt; minHeap, maxHeap;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;
        minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
        maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((n1, n2) -&gt; n2 - n1);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (minHeap.size() == maxHeap.size()) &#123;
            maxHeap.add(num);
            minHeap.add(maxHeap.remove()); <span class="hljs-comment">// 始终保证最小堆的 size 大于等于最大堆</span>
        &#125; <span class="hljs-keyword">else</span> &#123;
            minHeap.add(num);
            maxHeap.add(minHeap.remove());
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (minHeap.size() == maxHeap.size()) 
            <span class="hljs-keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="hljs-number">2.0</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> minHeap.peek(); <span class="hljs-comment">// 奇数个数时，可以直接从最小堆取</span>
    &#125;
&#125;</code></pre></div>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a>
                    
                      <a class="hover-with-bg" href="/tags/infinite-descent/">infinite descent</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/10/%E8%A5%BF%E6%B9%96/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">西湖</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%9E%8B/">
                        <span class="hidden-mobile">设计模式——创建型</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
          app_key: "wqRfy95wLQRm4b7BByawaNCK",
          placeholder: "说点什么吧",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <b>2019-2020</b>
      <i class="iconfont icon-love"></i>
      <b>lil-q</b>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "疑难杂题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  
















</body>
</html>
