<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#13100f">
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>java-反射和泛型 - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/tomorrow-night-eighties.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">



<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              Home</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              Archives</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              Categories</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              Tags</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/max-larochelle-7YtI5565PVU-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-03-27 22:45">
                    Friday, March 27th 2020, 10:45 pm
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    4.5k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    58
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>java学习及面试题汇总——反射和泛型</p>
<a id="more"></a>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为<strong>反射（Reflection）</strong>。</p>
<p>Java 反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<p><strong>重点：是运行时而不是编译时。</strong></p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>获取一个<code>class</code>的<code>Class</code>实例有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; cls = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;</code></pre></div>
<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<div class="hljs"><pre><code class="hljs java">String s = <span class="hljs-string">"Hello"</span>;
Class&lt;?&gt; cls = s.getClass();</code></pre></div>
<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">"java.lang.String"</span>);</code></pre></div>
<p>注意<code>Class</code>实例<code>==</code>比较和<code>instanceof</code>的差别：</p>
<div class="hljs"><pre><code class="hljs java">Integer n = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);

<span class="hljs-keyword">boolean</span> b1 = n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true，因为n是Integer类型</span>
<span class="hljs-keyword">boolean</span> b2 = n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true，因为n是Number类型的子类</span>

<span class="hljs-keyword">boolean</span> b3 = n.getClass() == Integer<span class="hljs-class">.<span class="hljs-keyword">class</span></span>; <span class="hljs-comment">// true，因为n.getClass()返回Integer.class</span>
<span class="hljs-keyword">boolean</span> b4 = n.getClass() == Number<span class="hljs-class">.<span class="hljs-keyword">class</span></span>; <span class="hljs-comment">// false，因为Integer.class!=Number.class</span></code></pre></div>
<p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p>
<p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 获取String的Class实例:</span>
Class&lt;?&gt; cls = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
<span class="hljs-comment">// 创建一个String实例:</span>
String s = (String) cls.newInstance();</code></pre></div>
<p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>
<h2 id="访问字段-Field"><a href="#访问字段-Field" class="headerlink" title="访问字段(Field)"></a>访问字段(Field)</h2><p>对任意的一个<code>Object</code>实例，只要获取了它的<code>Class</code>，就可以获取它的一切信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li><code>Field getField(name)</code>：根据字段名获取某个public的field（包括父类）</li>
<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个field（不包括父类）</li>
<li><code>Field[] getFields()</code>：获取所有public的field（包括父类）</li>
<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有field（不包括父类）</li>
</ul>
<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value;
&#125;</code></pre></div>
<p>我们用反射获取该字段的信息，代码如下：</p>
<div class="hljs"><pre><code class="hljs java">Field f = String.class.getDeclaredField("value");
f.getName(); // "value"
f.getType(); // class [B 表示byte[]类型
int m = f.getModifiers();
Modifier.isFinal(m); // true
Modifier.isPublic(m); // false
Modifier.isProtected(m); // false
Modifier.isPrivate(m); // true
Modifier.isStatic(m); // false</code></pre></div>
<p>以上获得了<code>Field</code>实例，获取值得方法：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-comment">// 当获取的字段不存在时会抛出错误，所以需要捕获</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        Object p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Xiao Ming"</span>);
        Class&lt;?&gt; c = p.getClass();
        Field f = c.getDeclaredField(<span class="hljs-string">"name"</span>);
        f.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置后才能访问private字段</span>
        Object value = f.get(p);
        System.out.println(value); <span class="hljs-comment">// "Xiao Ming"</span>
        f.set(p, <span class="hljs-string">"Xiao Hong"</span>); <span class="hljs-comment">// 设置字段值</span>
        System.out.println(p.getName()); <span class="hljs-comment">// "Xiao Hong"</span>
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;</code></pre></div>
<p>调用<code>Field.setAccessible(true)</code>似乎会破坏类的封装，反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h2 id="调用方法-Method"><a href="#调用方法-Method" class="headerlink" title="调用方法(Method)"></a>调用方法(Method)</h2><p>通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>用反射调用方法：</p>
<div class="hljs"><pre><code class="hljs java">String r = (String) m.invoke(s, <span class="hljs-number">6</span>);</code></pre></div>
<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>
<p>调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>:</p>
<div class="hljs"><pre><code class="hljs java">String r = (String) m.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);</code></pre></div>
<p>与访问字段相同，对于非public方法通过<code>Method.setAccessible(true)</code>允许其调用。</p>
<p>使用反射调用方法时，仍然遵循<strong>多态原则</strong>：即总是调用实际类型的覆写方法（如果存在）。</p>
<h2 id="调用构造方法-Constructor"><a href="#调用构造方法-Constructor" class="headerlink" title="调用构造方法(Constructor)"></a>调用构造方法(Constructor)</h2><p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情（甚至不去执行这个方法就可以）。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理类：由程序员创建或者由第三方工具生成，再进行编译；在程序运行之前，代理类的.class文件已经存在了。</p>
<ul>
<li>静态代理类通常只代理一个类；</li>
<li>静态代理事先知道要代理的是什么。</li>
</ul>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理类：在程序运行时，通过反射机制动态生成。</p>
<ul>
<li>动态代理类通常代理接口下的所有类；</li>
<li>动态代理事先不知道要代理的是什么，只有在运行的时候才能确定；</li>
<li>动态代理的调用处理程序必须事先InvocationHandler接口，及使用Proxy类中的newProxyInstance方法动态的创建代理类；</li>
<li>Java动态代理只能代理接口，要代理类需要使用第三方的CLIGB等类库。</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在集合中存储对象并在使用前进行类型转换非常不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p>
<p>可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</p>
<h2 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h2><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T first;
    <span class="hljs-keyword">private</span> T last;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.first = first;
        <span class="hljs-keyword">this</span>.last = last;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;

    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; <span class="hljs-function">Pair&lt;K&gt; <span class="hljs-title">create</span><span class="hljs-params">(K first, K last)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;K&gt;(first, last);
    &#125;
&#125;</code></pre></div>
<h2 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h2><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型``：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T first;
    <span class="hljs-keyword">private</span> K last;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, K last)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.first = first;
        <span class="hljs-keyword">this</span>.last = last;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
&#125;</code></pre></div>
<p>使用的时候，需要指出两种类型：</p>
<div class="hljs"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">"test"</span>, <span class="hljs-number">123</span>);</code></pre></div>
<p>Java标准库的<code>Map</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h2 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type Erasure"></a>Type Erasure</h2><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如<code>List&lt;String&gt;</code>在运行时仅用一个<code>List</code>来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<div class="hljs"><pre><code class="hljs java">Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"world"</span>);
String first = p.getFirst();
String last = p.getLast();</code></pre></div>
<p>而虚拟机执行的代码并没有泛型：</p>
<div class="hljs"><pre><code class="hljs java">Pair p = <span class="hljs-keyword">new</span> Pair(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"world"</span>);
String first = (String) p.getFirst();
String last = (String) p.getLast();</code></pre></div>
<p>java泛型的<strong>局限</strong>：</p>
<p><strong>局限一：<code>&lt;T&gt;</code>不能是基本类型</strong>，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型。</p>
<div class="hljs"><pre><code class="hljs java">Pair&lt;<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// compile error!</span></code></pre></div>
<p><strong>局限二：无法取得带泛型的<code>Class</code></strong>，如下代码最后获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"world"</span>);
        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);
        Class c1 = p1.getClass();
        Class c2 = p2.getClass();
        System.out.println(c1==c2); <span class="hljs-comment">// true</span>
        System.out.println(c1==Pair<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; <span class="hljs-comment">// true</span>

    &#125;
&#125;</code></pre></div>
<p><strong>局限三：无法判断带泛型的<code>Class</code>：</strong></p>
<div class="hljs"><pre><code class="hljs Java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);
<span class="hljs-comment">// Compile error:</span>
<span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;
&#125;</code></pre></div>
<p><strong>局限四：不能实例化<code>T</code>类型：</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T first;
    <span class="hljs-keyword">private</span> T last;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// Compile error:</span>
        first = <span class="hljs-keyword">new</span> T();
        last = <span class="hljs-keyword">new</span> T();
    &#125;
&#125;</code></pre></div>
<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<div class="hljs"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> T();
last = <span class="hljs-keyword">new</span> T();</code></pre></div>
<p>擦拭后实际上变成了：</p>
<div class="hljs"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> Object();
last = <span class="hljs-keyword">new</span> Object();</code></pre></div>
<p>这样一来，创建<code>new Pair()</code>和创建<code>new Pair()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p>
<p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class</code>参数：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T first;
    <span class="hljs-keyword">private</span> T last;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;
        first = clazz.newInstance();
        last = clazz.newInstance();
    &#125;
&#125;</code></pre></div>
<p>上述代码借助<code>Class</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class</code>。例如：</p>
<div class="hljs"><pre><code class="hljs java">Pair&lt;String&gt; pair = <span class="hljs-keyword">new</span> Pair&lt;&gt;(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></div>
<p>因为传入了<code>Class</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p>
<h3 id="避免泛型覆写"><a href="#避免泛型覆写" class="headerlink" title="避免泛型覆写"></a>避免泛型覆写</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(T t)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;
    &#125;
&#125;</code></pre></div>
<p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p>
<p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">same</span><span class="hljs-params">(T t)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;
    &#125;
&#125;</code></pre></div>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>保存到子类的class文件中。</p>
<h2 id="限定通配符"><a href="#限定通配符" class="headerlink" title="限定通配符"></a>限定通配符</h2><p>extends通配符是<code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的上界，<code>&lt;? super T&gt;</code>通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p>
<h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><p>由于<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。对于下面一个静态方法，传入<code>Pair&lt;Integer&gt;</code>会报错：<code>incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PairHelper</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> </span>&#123;
        Number first = p.getFirst();
        Number last = p.getLast();
        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();
    &#125;
&#125;</code></pre></div>
<p>解决办法是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。由于并不能确定传入值的类型，在静态方法中还是不能使用<code>Number</code>子类，否则会报错。Type Erasure会把<code>? extends Number</code>处理成<code>Number</code>。这里父类<code>Number</code>可以使用是因为向上转型是安全的。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);
        <span class="hljs-keyword">int</span> n = add(p);
        System.out.println(n);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;
        <span class="hljs-comment">// int x = p.getFirst(); // Type mismatch: cannot convert from capture#1-of ? extends Number to int</span>
        Number first = p.getFirst();
        Number last = p.getLast();
        <span class="hljs-comment">// p.setFirst(new Integer(first.intValue() + 100)); </span>
        <span class="hljs-comment">/* incompatible types: Integer cannot be converted to CAP#1
         * where CAP#1 is a fresh type-variable:
         * CAP#1 extends Number from capture of ? extends Number */</span>
        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T first;
    <span class="hljs-keyword">private</span> T last;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.first = first;
        <span class="hljs-keyword">this</span>.last = last;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> first;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> last;
    &#125;
    <span class="hljs-comment">// 传入值出错</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.first = first;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.last = last;
    &#125;
&#125;</code></pre></div>
<p>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>类型给<code>setFirst(? extends Number)</code>。即使<code>Number</code>也是不行的，因为向下转型是不安全的。正因为如此，extends通配符有以下作用：</p>
<ul>
<li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li>
<li>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</li>
</ul>
<p>因此，方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code>set(null)</code>除外）。</p>
<p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>&#123; ... &#125;</code></pre></div>
<p><code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>，而非<code>Number</code>类型<code>String</code>、<code>Object</code>将无法通过编译。</p>
<h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>
<ul>
<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>
<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>
</ul>
<p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p>
<p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<h3 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h3><p>作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>PECS原则（Producer Extends Consumer Super）可以帮助记忆何时使用<code>extends</code>，何时使用<code>super</code>。</p>
<p>如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。以<code>Collections</code>的<code>copy()</code>方法为例：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;
            T t = src.get(i); <span class="hljs-comment">// src是producer</span>
            dest.add(t); <span class="hljs-comment">// dest是consumer</span>
        &#125;
    &#125;
&#125;</code></pre></div>
<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>
<h2 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h2><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
</ul>
<p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNull</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> </span>&#123;
    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-keyword">null</span> || p.getLast() == <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNull</span><span class="hljs-params">(Pair&lt;T&gt; p)</span> </span>&#123;
    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-keyword">null</span> || p.getLast() == <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类。</p>
<h1 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h1><p><code>Class</code> 在实例化的时候，T 要替换成具体类。<code>Class</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 可以</span>
<span class="hljs-keyword">public</span> Class&lt;?&gt; clazz;
<span class="hljs-comment">// 不可以，因为 T 需要指定类型</span>
<span class="hljs-keyword">public</span> Class&lt;T&gt; clazzT;</code></pre></div>
<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super String&gt;</code>：</p>
<div class="hljs"><pre><code class="hljs java">Class&lt;? <span class="hljs-keyword">super</span> String&gt; sup = String<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getSuperclass</span>()</span>;</code></pre></div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析 Java 反射（1）- 基础</a></li>
<li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">https://www.zhihu.com/question/20794107</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></li>
<li><a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/03/30/java%E5%9F%BA%E7%A1%80%E5%9B%9B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java-Collection</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/23/java%E5%9F%BA%E7%A1%80%E4%BA%8C/">
                        <span class="hidden-mobile">java-面向对象和异常处理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.4/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
        app_key: "wqRfy95wLQRm4b7BByawaNCK",
        placeholder: "说点什么吧",
        path: window.location.pathname,
        avatar: "retro",
        meta: ["nick","mail","link"],
        pageSize: "10",
        lang: "zh-CN",
        highlight: false,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <b>2020</b>
      <i class="iconfont icon-love"></i>
      <b>lil-q</b>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      <span id="busuanzi_value_site_pv"></span>次访问 |
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      <span id="busuanzi_value_site_uv"></span>人来过
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java-反射和泛型&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
