<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logoforapple.png">
  <link rel="icon" type="image/png" href="/img/logo192.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#111">
  <meta name="description" content="Life Goes On">
  <meta name="author" content="戚天天">
  <meta name="keywords" content="python, 机器学习, cpp, 深度学习, 机器视觉, 算法, 数据结构">
  <title>java-Collection - Homeward</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  <link rel="stylesheet" href="/css/custom.css">


  <script  src="/js/utils.js" ></script>
</head>


<body>
  <header style="height: 38vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Homeward</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/usbizhi.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-03-30 18:34">
      March 30, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>java学习及面试题汇总——Collection及其源码分析</p>
<a id="more"></a>
<p>源码基于java 13。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/javacollection.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><code>List</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>void add(E e)</code></li>
<li>在指定索引添加一个元素：<code>void add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>int remove(int index)</code></li>
<li>删除某个元素：<code>int remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p><code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复，<code>List</code>还允许添加<code>null</code>。调用<code>List.of()</code>，它返回的是一个<strong>只读</strong><code>List</code>：</p>
<div class="hljs"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);</code></pre></div>
<p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p>
<h2 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List遍历</h2><p><code>List</code>的遍历采用了迭代器的设计模式：</p>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after3.26/iterator.png" srcset="/img/loading.gif" alt=""></p>
<p><code>Iterable</code>接口声明如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>
<p><code>Iterator</code>接口声明如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
    <span class="hljs-comment">// 判断是否还有下一个对象，如果有，则返回true，否则false</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>; 
    <span class="hljs-comment">// 返回集合的下个值，此方法只能在hasNext方法返回true时调用</span>
    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>; 
    <span class="hljs-comment">// 删除集合的当前值，此方法也只能在hasNext方法返回true时调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>
<p><code>ListIterator</code>接口声明如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
    <span class="hljs-comment">// 支持双向移动</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">E <span class="hljs-title">previous</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 可以使用set()方法替换它访问过的最后一个元素</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span></span>;
    <span class="hljs-comment">// 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>; 
&#125;</code></pre></div>
<p>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;String&gt; list = List.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"banana"</span>);
        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;
            String s = it.next();
            System.out.println(s);
        &#125;
    &#125;
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;String&gt; list = List.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"banana"</span>);
        <span class="hljs-keyword">for</span> (String s : list) &#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;</code></pre></div>
<h2 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h2><h3 id="List-gt-Array"><a href="#List-gt-Array" class="headerlink" title="List -&gt; Array"></a>List -&gt; Array</h3><p>给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);
        Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);
        <span class="hljs-keyword">for</span> (Integer n : array) &#123;
            System.out.println(n);
        &#125;
    &#125;
&#125;</code></pre></div>
<p><code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组。</p>
<div class="hljs"><pre><code class="hljs java">Number[] array = list.toArray(<span class="hljs-keyword">new</span> Number[<span class="hljs-number">3</span>]);</code></pre></div>
<p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。实际上，最常用的是传入一个“恰好”大小的数组：</p>
<div class="hljs"><pre><code class="hljs java">Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);</code></pre></div>
<h3 id="Array-gt-List"><a href="#Array-gt-List" class="headerlink" title="Array -&gt; List"></a>Array -&gt; List</h3><div class="hljs"><pre><code class="hljs java">Integer[] array = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;
List&lt;Integer&gt; list = List.of(array);</code></pre></div>
<p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p>
<h2 id="contains-和indexOf"><a href="#contains-和indexOf" class="headerlink" title="contains()和indexOf()"></a>contains()和indexOf()</h2><p><code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。<code>List</code>提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p>
<p><code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等，所以放入的实例必须要正确override。</p>
<p>如果<code>this.name</code>为<code>null</code>，那么<code>equals()</code>方法会报错，因此，需要继续改写如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;
        Person p = (Person) o;
        <span class="hljs-keyword">boolean</span> nameEquals = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name == <span class="hljs-keyword">null</span> &amp;&amp; p.name == <span class="hljs-keyword">null</span>) &#123;
            nameEquals = <span class="hljs-keyword">true</span>;
        &#125;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-keyword">null</span>) &#123;
            nameEquals = <span class="hljs-keyword">this</span>.name.equals(p.name);
        &#125;
        <span class="hljs-keyword">return</span> nameEquals &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>
<p>如果<code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code>Objects.equals()</code>静态方法：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;
        Person p = (Person) o;
        <span class="hljs-keyword">return</span> Objects.equals(<span class="hljs-keyword">this</span>.name, p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>
<h2 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a>List实现类</h2><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p>比较<code>ArrayList</code>和<code>LinkedList</code>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">ArrayList</th>
<th style="text-align:left">LinkedList</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">获取指定元素</td>
<td style="text-align:left">速度很快</td>
<td style="text-align:left">需要从头开始查找元素</td>
</tr>
<tr>
<td style="text-align:left">添加元素到末尾</td>
<td style="text-align:left">速度很快</td>
<td style="text-align:left">速度很快</td>
</tr>
<tr>
<td style="text-align:left">在指定位置添加/删除</td>
<td style="text-align:left">需要移动元素</td>
<td style="text-align:left">不需要移动元素</td>
</tr>
<tr>
<td style="text-align:left">内存占用</td>
<td style="text-align:left">少</td>
<td style="text-align:left">较大</td>
</tr>
</tbody>
</table>
</div>
<p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;
        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>
</span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;

    <span class="hljs-comment">// Default initial capacity</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;
    ...</code></pre></div>
<p>RandomAccess 接口标识着该类支持快速随机访问，java.io.Serializable是支持序列化接口。数组的默认大小为 10。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>添加元素时如果容量不够时，需要使用 grow() 方法进行扩容，新容量的大小默认为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。当需求的容量大于它时，则会选用两个<code>list</code>长度之和作为新容量，扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;
    Object[] a = c.toArray();
    modCount++;
    <span class="hljs-keyword">int</span> numNew = a.length;
    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    Object[] elementData;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> s;
    <span class="hljs-comment">// 加入的数组长度大于剩余空数组长度</span>
    <span class="hljs-keyword">if</span> (numNew &gt; (elementData = <span class="hljs-keyword">this</span>.elementData).length - (s = size))
        elementData = grow(s + numNew);
    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, s, numNew);
    size = s + numNew;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;

<span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-keyword">int</span> minCapacity) &#123;
    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;
    <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        <span class="hljs-keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span>
                oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* preferred growth */</span>);
        <span class="hljs-keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> elementData = <span class="hljs-keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    &#125;
&#125;

<span class="hljs-keyword">private</span> Object[] grow() &#123;
    <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);
&#125;</code></pre></div>
<p>ArraySupport.class下的<code>newLength()</code>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldLength, <span class="hljs-keyword">int</span> minGrowth, <span class="hljs-keyword">int</span> prefGrowth)</span> </span>&#123;
    <span class="hljs-comment">// assert oldLength &gt;= 0</span>
    <span class="hljs-comment">// assert minGrowth &gt; 0</span>

    <span class="hljs-keyword">int</span> newLength = Math.max(minGrowth, prefGrowth) + oldLength;
    <span class="hljs-keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> newLength;
    &#125;
    <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth); <span class="hljs-comment">// 处理溢出情况</span>
&#125;</code></pre></div>
<p>Arrays.class下的<code>copyOf()</code>：</p>
<div class="hljs"><pre><code class="hljs java">@SuppressWarnings("unchecked")
public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;
    return (T[]) copyOf(original, newLength, original.getClass());
&#125;

@HotSpotIntrinsicCandidate
    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;
        @SuppressWarnings("unchecked")
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;</code></pre></div>
<p>System.class下的<code>arraycopy()</code>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,
                                    Object dest, <span class="hljs-keyword">int</span> destPos,
                                    <span class="hljs-keyword">int</span> length)</span></span>;</code></pre></div>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>remove()</code>调用了<code>fastRemove()</code>，其中调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
    Objects.checkIndex(index, size);
    <span class="hljs-keyword">final</span> Object[] es = elementData;

    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E oldValue = (E) es[index];
    fastRemove(es, index);

    <span class="hljs-keyword">return</span> oldValue;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(Object[] es, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
    modCount++;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newSize;
    <span class="hljs-keyword">if</span> ((newSize = size - <span class="hljs-number">1</span>) &gt; i)
        System.arraycopy(es, i + <span class="hljs-number">1</span>, es, i, newSize - i);
    es[size = newSize] = <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>保存元素的数组 <code>elementData</code> 使用 <code>transient</code> 修饰，该关键字声明数组默认不会被序列化。也就是说 <code>elementData</code> 的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span></code></pre></div>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>
    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;

    <span class="hljs-comment">// Read in size, and any hidden stuff</span>
    s.defaultReadObject();

    <span class="hljs-comment">// Read in capacity</span>
    s.readInt(); <span class="hljs-comment">// ignored</span>

    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// like clone(), allocate array based upon size not capacity</span>
        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">size</span>)</span>;
        Object[] elements = <span class="hljs-keyword">new</span> Object[size];

        <span class="hljs-comment">// Read in all elements in the proper order.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
            elements[i] = s.readObject();
        &#125;

        elementData = elements;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;
        elementData = EMPTY_ELEMENTDATA;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.io.InvalidObjectException(<span class="hljs-string">"Invalid size: "</span> + size);
    &#125;
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span>
    <span class="hljs-keyword">throws</span> java.io.IOException </span>&#123;
    <span class="hljs-comment">// Write out element count, and any hidden stuff</span>
    <span class="hljs-keyword">int</span> expectedModCount = modCount;
    s.defaultWriteObject();

    <span class="hljs-comment">// Write out size as capacity for behavioral compatibility with clone()</span>
    s.writeInt(size);

    <span class="hljs-comment">// Write out all elements in the proper order.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;
        s.writeObject(elementData[i]);
    &#125;

    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
    &#125;
&#125;</code></pre></div>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<div class="hljs"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();
ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file));
oos.writeObject(list);</code></pre></div>
<h4 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h4><p> AbstractList.class中使用 <code>modCount</code> 来记录 <code>ArrayList</code> 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;</code></pre></div>
<p>迭代器在调用<code>next()</code>、<code>remove()</code>方法时都是调用<code>checkForComodification()</code>方法，它检测<code>modCount == expectedModCount</code> ？ 若不等则抛出<code>ConcurrentModificationException</code>异常，从而产生fail-fast机制。</p>
<p>有两种解决方案：</p>
<ul>
<li>在遍历过程中所有涉及到改变<code>modCount</code>值得地方全部加上<code>synchronized</code>或者直接使用<code>Collections.synchronizedList</code>（不推荐）；</li>
<li>使用<code>CopyOnWriteArrayList</code>来替换<code>ArrayList</code>。</li>
</ul>
<h4 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object[] toArray() &#123;
        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);
    &#125;</code></pre></div>
<p>注意到传入的<code>elementData</code>和返回值是<code>Object[]</code>，如果需要传回原格式：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;
        <span class="hljs-keyword">if</span> (a.length &lt; size)
            <span class="hljs-comment">// Make a new array of a's runtime type, but my contents:</span>
            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass()); <span class="hljs-comment">// 利用反射</span>
        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);
        <span class="hljs-keyword">if</span> (a.length &gt; size)
            a[size] = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">return</span> a;
    &#125;</code></pre></div>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，否则多线程写的时候会Copy出N个副本，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    <span class="hljs-comment">// 获得锁</span>
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        Object[] elements = getArray();
        <span class="hljs-keyword">int</span> len = elements.length;
        <span class="hljs-comment">// 复制新数组</span>
        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);
        <span class="hljs-comment">// 插入新值</span>
        newElements[len] = e;
        <span class="hljs-comment">// 原来的引用指向新的数组</span>
        setArray(newElements);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 释放锁</span>
        lock.unlock();
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setArray</span><span class="hljs-params">(Object[] a)</span> </span>&#123;
    array = a;
&#125;Copy to clipboardErrorCopied
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (E) a[index];
&#125;Copy to clipboardErrorCopied</code></pre></div>
<p>使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li><strong>减少扩容开销。</strong>根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li>
<li><strong>使用批量添加。</strong>因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用代码里的addBlackList方法。</li>
</ol>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合<strong>读多写少</strong>的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li><strong>内存占用：</strong>在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li><strong>数据不一致：</strong>读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList <strong>不适合内存敏感以及对实时性要求很高</strong>的场景。</p>
<h4 id="CopyOnWriteArrayList与Vector"><a href="#CopyOnWriteArrayList与Vector" class="headerlink" title="CopyOnWriteArrayList与Vector"></a>CopyOnWriteArrayList与Vector</h4><p>Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>有以下实现类：</p>
<ul>
<li>TreeSet：基于<strong>红黑树</strong>实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p>
<ul>
<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>
<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表，队列接口<code>Queue</code>定义了以下几个方法：</p>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>
<p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">throw Exception</th>
<th style="text-align:left">返回false或null</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e)</td>
<td style="text-align:left">boolean offer(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove()</td>
<td style="text-align:left">E poll()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element()</td>
<td style="text-align:left">E peek()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;...&#125;</code></pre></div>
<p><code>Deque</code>实现了一个双端队列（Double Ended Queue），比较<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Queue</th>
<th>Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e) / offer(E e)</td>
<td>addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove() / E poll()</td>
<td>E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element() / E peek()</td>
<td>E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td style="text-align:left">添加元素到队首</td>
<td style="text-align:left">无</td>
<td>addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素并删除</td>
<td style="text-align:left">无</td>
<td>E removeLast() / E pollLast()</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素但不删除</td>
<td style="text-align:left">无</td>
<td>E getLast() / E peekLast()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构，操作栈的元素的方法有：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li>
<li>取栈顶元素但不弹出：<code>peek(E)</code>。</li>
</ul>
<p>用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。实际上，以上都是对队首进行操作而不是队尾。</p>
<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">leetcode 316. 去除重复字母</a></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;
        LinkedList&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : s.toCharArray()) count[ch - <span class="hljs-string">'a'</span>] += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : s.toCharArray()) &#123;
            <span class="hljs-keyword">if</span> (stack.contains(ch)) &#123;
                count[ch - <span class="hljs-string">'a'</span>] -= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; ch &amp;&amp; count[stack.peek() - <span class="hljs-string">'a'</span>] &gt; <span class="hljs-number">1</span>) &#123;
                count[stack.pop() - <span class="hljs-string">'a'</span>] -= <span class="hljs-number">1</span>;
            &#125;
            stack.push(ch);
        &#125;
        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span> (!stack.isEmpty()) res.append(stack.removeLast());
        <span class="hljs-keyword">return</span> res.toString();
    &#125;
&#125;</code></pre></div>
<h3 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h3><p>JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p>
<h2 id="Queue实现类"><a href="#Queue实现类" class="headerlink" title="Queue实现类"></a>Queue实现类</h2><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于<strong>堆结构</strong>实现，可以用它来实现优先队列。</li>
</ul>
<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;
    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;
    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>
</span>&#123;
    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Pointer to first node.</span>
    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;

    <span class="hljs-comment">// Pointer to last node.</span>
    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;
    ...</code></pre></div>
<p>LinkedList()中的节点定义如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
        E item;
        Node&lt;E&gt; next;
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            <span class="hljs-keyword">this</span>.item = element;
            <span class="hljs-keyword">this</span>.next = next;
            <span class="hljs-keyword">this</span>.prev = prev;
        &#125;
    &#125;</code></pre></div>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue中堆结构默认是<strong>最小堆</strong>，如需实现最大堆，覆写<code>compare()</code>即可。父子节点的编号之间有如下关系：</p>
<ul>
<li>leftNo = parentNo * 2 + 1</li>
<li>rightNo = parentNo * 2 + 2</li>
<li>parentNo = (nodeNo - 1) / 2</li>
</ul>
<p>常见的topK问题使用最小堆来解决，相反的求最小的若干数则用最大堆。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java 容器" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265112034799552" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265112034799552</a></li>
<li><a href="https://stackoverflow.com/questions/29574436/what-does-java-util-arraysarraylist-mean" target="_blank" rel="noopener">Array.asList() and List.of()</a></li>
<li><a href="https://majing.io/posts/10000001141158" target="_blank" rel="noopener">https://majing.io/posts/10000001141158</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1638201147057831295&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">fail-fast</a></li>
<li><a href="https://www.cnblogs.com/vinozly/p/5171227.html" target="_blank" rel="noopener">Serializable</a></li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/02/java%E5%9F%BA%E7%A1%80%E4%BA%94/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java-Map</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/27/java%E5%9F%BA%E7%A1%80%E4%B8%89/">
                        <span class="hidden-mobile">java-反射和泛型</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "iDVdqah8oVl5qmT8UM7qmde9-gzGzoHsz",
          app_key: "wqRfy95wLQRm4b7BByawaNCK",
          placeholder: "说点什么吧",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <b>2019-2020</b>
      <i class="iconfont icon-love"></i>
      <b>lil-q</b>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java-Collection&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
